{
    "BasicOpMode Linear": {
        "prefix": "basicOpModeLinear",
        "description": "This file contains an minimal example of a Linear \"OpMode\". An OpMode is a 'program' that runs in either\nthe autonomous or the teleop period of an FTC match. The names of OpModes appear on the menu\nof the FTC Driver Station. When a selection is made from the menu, the corresponding OpMode\nclass is instantiated on the Robot Controller and executed.\n\nThis particular OpMode just executes a basic Tank Drive Teleop for a two wheeled robot\nIt includes all the skeletal structure that all linear OpModes contain.\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list\n ",
        "body": [
            "public class BasicOpMode_Linear extends LinearOpMode {",
            "",
            "    // Declare OpMode members.",
            "    private ElapsedTime runtime = new ElapsedTime();",
            "    private DcMotor leftDrive = null;",
            "    private DcMotor rightDrive = null;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "        telemetry.addData(\"Status\", \"Initialized\");",
            "        telemetry.update();",
            "",
            "        // Initialize the hardware variables. Note that the strings used here as parameters",
            "        // to 'get' must correspond to the names assigned during the robot configuration",
            "        // step (using the FTC Robot Controller app on the phone).",
            "        leftDrive  = hardwareMap.get(DcMotor.class, \"left_drive\");",
            "        rightDrive = hardwareMap.get(DcMotor.class, \"right_drive\");",
            "",
            "        // To drive forward, most robots need the motor on one side to be reversed, because the axles point in opposite directions.",
            "        // Pushing the left stick forward MUST make robot go forward. So adjust these two lines based on your first test drive.",
            "        // Note: The settings here assume direct drive on left and right wheels.  Gear Reduction or 90 Deg drives may require direction flips",
            "        leftDrive.setDirection(DcMotor.Direction.REVERSE);",
            "        rightDrive.setDirection(DcMotor.Direction.FORWARD);",
            "",
            "        // Wait for the game to start (driver presses PLAY)",
            "        waitForStart();",
            "        runtime.reset();",
            "",
            "        // run until the end of the match (driver presses STOP)",
            "        while (opModeIsActive()) {",
            "",
            "            // Setup a variable for each drive wheel to save power level for telemetry",
            "            double leftPower;",
            "            double rightPower;",
            "",
            "            // Choose to drive using either Tank Mode, or POV Mode",
            "            // Comment out the method that's not used.  The default below is POV.",
            "",
            "            // POV Mode uses left stick to go forward, and right stick to turn.",
            "            // - This uses basic math to combine motions and is easier to drive straight.",
            "            double drive = -gamepad1.left_stick_y;",
            "            double turn  =  gamepad1.right_stick_x;",
            "            leftPower    = Range.clip(drive + turn, -1.0, 1.0) ;",
            "            rightPower   = Range.clip(drive - turn, -1.0, 1.0) ;",
            "",
            "            // Tank Mode uses one stick to control each wheel.",
            "            // - This requires no math, but it is hard to drive forward slowly and keep straight.",
            "            // leftPower  = -gamepad1.left_stick_y ;",
            "            // rightPower = -gamepad1.right_stick_y ;",
            "",
            "            // Send calculated power to wheels",
            "            leftDrive.setPower(leftPower);",
            "            rightDrive.setPower(rightPower);",
            "",
            "            // Show the elapsed game time and wheel power.",
            "            telemetry.addData(\"Status\", \"Run Time: \" + runtime.toString());",
            "            telemetry.addData(\"Motors\", \"left (%.2f), right (%.2f)\", leftPower, rightPower);",
            "            telemetry.update();",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptVuforiaNavigationWebcam": {
        "prefix": "conceptVuforiaNavigationWebcam",
        "description": "    Sample one frame from the Vuforia stream and write it to a .PNG image file on the robot\n    controller in the /sdcard/FIRST/data directory. The images can be downloaded using Android\n    Studio's Device File Explorer, ADB, or the Media Transfer Protocol (MTP) integration into\n    Windows Explorer, among other means. The images can be useful during robot design and calibration\n    in order to get a sense of what the camera is actually seeing and so assist in camera\n    aiming and alignment.\n     ",
        "body": [
            "public class ConceptVuforiaNavigationWebcam extends LinearOpMode {",
            "",
            "    public static final String TAG = \"Vuforia Navigation Sample\";",
            "",
            "    OpenGLMatrix lastLocation = null;",
            "",
            "    /**",
            "     * @see #captureFrameToFile()",
            "     */",
            "    int captureCounter = 0;",
            "    File captureDirectory = AppUtil.ROBOT_DATA_DIR;",
            "",
            "    /**",
            "     * {@link #vuforia} is the variable we will use to store our instance of the Vuforia",
            "     * localization engine.",
            "     */",
            "    VuforiaLocalizer vuforia;",
            "",
            "    /**",
            "     * This is the webcam we are to use. As with other hardware devices such as motors and",
            "     * servos, this device is identified using the robot configuration tool in the FTC application.",
            "     */",
            "    WebcamName webcamName;",
            "",
            "    @Override public void runOpMode() {",
            "",
            "        /*",
            "         * Retrieve the camera we are to use.",
            "         */",
            "        webcamName = hardwareMap.get(WebcamName.class, \"Webcam 1\");",
            "",
            "        /*",
            "         * To start up Vuforia, tell it the view that we wish to use for camera monitor (on the RC phone);",
            "         * If no camera monitor is desired, use the parameterless constructor instead (commented out below).",
            "         */",
            "        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\"cameraMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());",
            "        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId);",
            "",
            "        // OR...  Do Not Activate the Camera Monitor View, to save power",
            "        // VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();",
            "",
            "        /*",
            "         * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which",
            "         * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.",
            "         * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer",
            "         * web site at https://developer.vuforia.com/license-manager.",
            "         *",
            "         * Vuforia license keys are always 380 characters long, and look as if they contain mostly",
            "         * random data. As an example, here is a example of a fragment of a valid key:",
            "         *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...",
            "         * Once you've obtained a license key, copy the string from the Vuforia web site",
            "         * and paste it in to your code on the next line, between the double quotes.",
            "         */",
            "        parameters.vuforiaLicenseKey = \" -- YOUR NEW VUFORIA KEY GOES HERE  --- \";",
            "",
            "        /**",
            "         * We also indicate which camera on the RC we wish to use.",
            "         */",
            "        parameters.cameraName = webcamName;",
            "",
            "        /**",
            "         * Instantiate the Vuforia engine",
            "         */",
            "        vuforia = ClassFactory.getInstance().createVuforia(parameters);",
            "",
            "        /**",
            "         * Because this opmode processes frames in order to write them to a file, we tell Vuforia",
            "         * that we want to ensure that certain frame formats are available in the {@link Frame}s we",
            "         * see.",
            "         */",
            "        vuforia.enableConvertFrameToBitmap();",
            "",
            "        /** @see #captureFrameToFile() */",
            "        AppUtil.getInstance().ensureDirectoryExists(captureDirectory);",
            "",
            "",
            "        /**",
            "         * Load the data sets that for the trackable objects we wish to track. These particular data",
            "         * sets are stored in the 'assets' part of our application (you'll see them in the Android",
            "         * Studio 'Project' view over there on the left of the screen). You can make your own datasets",
            "         * with the Vuforia Target Manager: https://developer.vuforia.com/target-manager. PDFs for the",
            "         * example \"StonesAndChips\", datasets can be found in in this project in the",
            "         * documentation directory.",
            "         */",
            "        VuforiaTrackables stonesAndChips = vuforia.loadTrackablesFromAsset(\"StonesAndChips\");",
            "        VuforiaTrackable redTarget = stonesAndChips.get(0);",
            "        redTarget.setName(\"RedTarget\");  // Stones",
            "",
            "        VuforiaTrackable blueTarget  = stonesAndChips.get(1);",
            "        blueTarget.setName(\"BlueTarget\");  // Chips",
            "",
            "        /** For convenience, gather together all the trackable objects in one easily-iterable collection */",
            "        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();",
            "        allTrackables.addAll(stonesAndChips);",
            "",
            "        /**",
            "         * We use units of mm here because that's the recommended units of measurement for the",
            "         * size values specified in the XML for the ImageTarget trackables in data sets. E.g.:",
            "         *      <ImageTarget name=\"stones\" size=\"247 173\"/>",
            "         * You don't *have to* use mm here, but the units here and the units used in the XML",
            "         * target configuration files *must* correspond for the math to work out correctly.",
            "         */",
            "        float mmPerInch        = 25.4f;",
            "        float mmBotWidth       = 18 * mmPerInch;            // ... or whatever is right for your robot",
            "        float mmFTCFieldWidth  = (12*12 - 2) * mmPerInch;   // the FTC field is ~11'10\" center-to-center of the glass panels",
            "",
            "        /**",
            "         * In order for localization to work, we need to tell the system where each target we",
            "         * wish to use for navigation resides on the field, and we need to specify where on the robot",
            "         * the camera resides. These specifications are in the form of <em>transformation matrices.</em>",
            "         * Transformation matrices are a central, important concept in the math here involved in localization.",
            "         * See <a href=\"https://en.wikipedia.org/wiki/Transformation_matrix\">Transformation Matrix</a>",
            "         * for detailed information. Commonly, you'll encounter transformation matrices as instances",
            "         * of the {@link OpenGLMatrix} class.",
            "         *",
            "         * For the most part, you don't need to understand the details of the math of how transformation",
            "         * matrices work inside (as fascinating as that is, truly). Just remember these key points:",
            "         * <ol>",
            "         *",
            "         *     <li>You can put two transformations together to produce a third that combines the effect of",
            "         *     both of them. If, for example, you have a rotation transform R and a translation transform T,",
            "         *     then the combined transformation matrix RT which does the rotation first and then the translation",
            "         *     is given by {@code RT = T.multiplied(R)}. That is, the transforms are multiplied in the",
            "         *     <em>reverse</em> of the chronological order in which they applied.</li>",
            "         *",
            "         *     <li>A common way to create useful transforms is to use methods in the {@link OpenGLMatrix}",
            "         *     class and the Orientation class. See, for example, {@link OpenGLMatrix#translation(float,",
            "         *     float, float)}, {@link OpenGLMatrix#rotation(AngleUnit, float, float, float, float)}, and",
            "         *     {@link Orientation#getRotationMatrix(AxesReference, AxesOrder, AngleUnit, float, float, float)}.",
            "         *     Related methods in {@link OpenGLMatrix}, such as {@link OpenGLMatrix#rotated(AngleUnit,",
            "         *     float, float, float, float)}, are syntactic shorthands for creating a new transform and",
            "         *     then immediately multiplying the receiver by it, which can be convenient at times.</li>",
            "         *",
            "         *     <li>If you want to break open the black box of a transformation matrix to understand",
            "         *     what it's doing inside, use {@link MatrixF#getTranslation()} to fetch how much the",
            "         *     transform will move you in x, y, and z, and use {@link Orientation#getOrientation(MatrixF,",
            "         *     AxesReference, AxesOrder, AngleUnit)} to determine the rotational motion that the transform",
            "         *     will impart. See {@link #format(OpenGLMatrix)} below for an example.</li>",
            "         *",
            "         * </ol>",
            "         *",
            "         * This example places the \"stones\" image on the perimeter wall to the Left",
            "         *  of the Red Driver station wall.  Similar to the Red Beacon Location on the Res-Q",
            "         *",
            "         * This example places the \"chips\" image on the perimeter wall to the Right",
            "         *  of the Blue Driver station.  Similar to the Blue Beacon Location on the Res-Q",
            "         *",
            "         * See the doc folder of this project for a description of the Field Coordinate System",
            "         * conventions.",
            "         *",
            "         * Initially the target is conceptually lying at the origin of the Field Coordinate System",
            "         * (the center of the field), facing up.",
            "         *",
            "         * In this configuration, the target's coordinate system aligns with that of the field.",
            "         *",
            "         * In a real situation we'd also account for the vertical (Z) offset of the target,",
            "         * but for simplicity, we ignore that here; for a real robot, you'll want to fix that.",
            "         *",
            "         * To place the Stones Target on the Red Audience wall:",
            "         * - First we rotate it 90 around the field's X axis to flip it upright",
            "         * - Then we rotate it  90 around the field's Z access to face it away from the audience.",
            "         * - Finally, we translate it back along the X axis towards the red audience wall.",
            "         */",
            "        OpenGLMatrix redTargetLocationOnField = OpenGLMatrix",
            "                /* Then we translate the target off to the RED WALL. Our translation here",
            "                is a negative translation in X.*/",
            "                .translation(-mmFTCFieldWidth/2, 0, 0)",
            "                .multiplied(Orientation.getRotationMatrix(",
            "                        /* First, in the fixed (field) coordinate system, we rotate 90deg in X, then 90 in Z */",
            "                        AxesReference.EXTRINSIC, AxesOrder.XZX,",
            "                        AngleUnit.DEGREES, 90, 90, 0));",
            "        redTarget.setLocationFtcFieldFromTarget(redTargetLocationOnField);",
            "        RobotLog.ii(TAG, \"Red Target=%s\", format(redTargetLocationOnField));",
            "",
            "       /*",
            "        * To place the Stones Target on the Blue Audience wall:",
            "        * - First we rotate it 90 around the field's X axis to flip it upright",
            "        * - Finally, we translate it along the Y axis towards the blue audience wall.",
            "        */",
            "        OpenGLMatrix blueTargetLocationOnField = OpenGLMatrix",
            "                /* Then we translate the target off to the Blue Audience wall.",
            "                Our translation here is a positive translation in Y.*/",
            "                .translation(0, mmFTCFieldWidth/2, 0)",
            "                .multiplied(Orientation.getRotationMatrix(",
            "                        /* First, in the fixed (field) coordinate system, we rotate 90deg in X */",
            "                        AxesReference.EXTRINSIC, AxesOrder.XZX,",
            "                        AngleUnit.DEGREES, 90, 0, 0));",
            "        blueTarget.setLocationFtcFieldFromTarget(blueTargetLocationOnField);",
            "        RobotLog.ii(TAG, \"Blue Target=%s\", format(blueTargetLocationOnField));",
            "",
            "        /**",
            "         * We also need to tell Vuforia where the <em>cameras</em> are relative to the robot.",
            "         *",
            "         * Just as there is a Field Coordinate System, so too there is a Robot Coordinate System.",
            "         * The two share many similarities. The origin of the Robot Coordinate System is wherever",
            "         * you choose to make it on the robot, but typically you'd choose somewhere in the middle",
            "         * of the robot. From that origin, the Y axis is horizontal and positive out towards the",
            "         * \"front\" of the robot (however you choose \"front\" to be defined), the X axis is horizontal",
            "         * and positive out towards the \"right\" of the robot (i.e.: 90deg horizontally clockwise from",
            "         * the positive Y axis), and the Z axis is vertical towards the sky.",
            "         *",
            "         * Similarly, for each camera there is a Camera Coordinate System. The origin of a Camera",
            "         * Coordinate System lies in the middle of the sensor inside of the camera. The Z axis is",
            "         * positive coming out of the lens of the camera in a direction perpendicular to the plane",
            "         * of the sensor. When looking at the face of the lens of the camera (down the positive Z",
            "         * axis), the X axis is positive off to the right in the plane of the sensor, and the Y axis",
            "         * is positive out the top of the lens in the plane of the sensor at 90 horizontally",
            "         * counter clockwise from the X axis.",
            "         *",
            "         * Next, there is Phone Coordinate System (for robots that have phones, of course), though",
            "         * with the advent of Vuforia support for Webcams, this coordinate system is less significant",
            "         * than it was previously. The Phone Coordinate System is defined thusly: with the phone in",
            "         * flat front of you in portrait mode (i.e. as it is when running the robot controller app)",
            "         * and you are staring straight at the face of the phone,",
            "         *     * X is positive heading off to your right,",
            "         *     * Y is positive heading up through the top edge of the phone, and",
            "         *     * Z is pointing out of the screen, toward you.",
            "         * The origin of the Phone Coordinate System is at the origin of the Camera Coordinate System",
            "         * of the front-facing camera on the phone.",
            "         *",
            "         * Finally, it is worth noting that trackable Vuforia Image Targets have their <em>own</em>",
            "         * coordinate system (see {@link VuforiaTrackable}. This is sometimes referred to as the",
            "         * Target Coordinate System. In keeping with the above, when looking at the target in its",
            "         * natural orientation, in the Target Coodinate System",
            "         *     * X is positive heading off to your right,",
            "         *     * Y is positive heading up through the top edge of the target, and",
            "         *     * Z is pointing out of the target, toward you.",
            "         *",
            "         * One can observe that the Camera Coordinate System of the front-facing camera on a phone",
            "         * coincides with the Phone Coordinate System. Further, when a phone is placed on its back",
            "         * at the origin of the Robot Coordinate System and aligned appropriately, those coordinate",
            "         * systems also coincide with the Robot Coordinate System. Got it?",
            "         *",
            "         * In this example here, we're going to assume that we put the camera on the right side",
            "         * of the robot (facing outwards, of course). To determine the transformation matrix that",
            "         * describes that location, first consider the camera as lying on its back at the origin",
            "         * of the Robot Coordinate System such that the Camera Coordinate System and Robot Coordinate",
            "         * System coincide. Then the transformation we need is",
            "         *      * first a rotation of the camera by +90deg along the robot X axis,",
            "         *      * then a rotation of the camera by +90deg along the robot Z axis, and",
            "         *      * finally a translation of the camera to the side of the robot.",
            "         *",
            "         * When determining whether a rotation is positive or negative, consider yourself as looking",
            "         * down the (positive) axis of rotation from the positive towards the origin. Positive rotations",
            "         * are then CCW, and negative rotations CW. An example: consider looking down the positive Z",
            "         * axis towards the origin. A positive rotation about Z (ie: a rotation parallel to the the X-Y",
            "         * plane) is then CCW, as one would normally expect from the usual classic 2D geometry.",
            "         */",
            "",
            "        OpenGLMatrix robotFromCamera = OpenGLMatrix",
            "                .translation(mmBotWidth/2,0,0)",
            "                .multiplied(Orientation.getRotationMatrix(",
            "                        AxesReference.EXTRINSIC, AxesOrder.XZY,",
            "                        AngleUnit.DEGREES, 90, 90, 0));",
            "        RobotLog.ii(TAG, \"camera=%s\", format(robotFromCamera));",
            "",
            "        /**",
            "         * Let the trackable listeners we care about know where the camera is. We know that each",
            "         * listener is a {@link VuforiaTrackableDefaultListener} and can so safely cast because",
            "         * we have not ourselves installed a listener of a different type.",
            "         */",
            "        ((VuforiaTrackableDefaultListener)redTarget.getListener()).setCameraLocationOnRobot(parameters.cameraName, robotFromCamera);",
            "        ((VuforiaTrackableDefaultListener)blueTarget.getListener()).setCameraLocationOnRobot(parameters.cameraName, robotFromCamera);",
            "",
            "        /**",
            "         * A brief tutorial: here's how all the math is going to work:",
            "         *",
            "         * C = robotFromCamera          maps   camera coords -> robot coords",
            "         * P = tracker.getPose()        maps   image target coords -> camera coords",
            "         * L = redTargetLocationOnField maps   image target coords -> field coords",
            "         *",
            "         * So",
            "         *",
            "         * C.inverted()                 maps   robot coords -> camera coords",
            "         * P.inverted()                 maps   camera coords -> imageTarget coords",
            "         *",
            "         * Putting that all together,",
            "         *",
            "         * L x P.inverted() x C.inverted() maps robot coords to field coords.",
            "         *",
            "         * @see VuforiaTrackableDefaultListener#getRobotLocation()",
            "         */",
            "",
            "        /** Wait for the game to begin */",
            "        telemetry.addData(\">\", \"Press Play to start tracking\");",
            "        telemetry.update();",
            "        waitForStart();",
            "",
            "        /** Start tracking the data sets we care about. */",
            "        stonesAndChips.activate();",
            "",
            "        boolean buttonPressed = false;",
            "        while (opModeIsActive()) {",
            "",
            "            if (gamepad1.a && !buttonPressed) {",
            "                captureFrameToFile();",
            "                }",
            "            buttonPressed = gamepad1.a;",
            "",
            "            for (VuforiaTrackable trackable : allTrackables) {",
            "                /**",
            "                 * getUpdatedRobotLocation() will return null if no new information is available since",
            "                 * the last time that call was made, or if the trackable is not currently visible.",
            "                 * getRobotLocation() will return null if the trackable is not currently visible.",
            "                 */",
            "                telemetry.addData(trackable.getName(), ((VuforiaTrackableDefaultListener)trackable.getListener()).isVisible() ? \"Visible\" : \"Not Visible\");    //",
            "",
            "                OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener)trackable.getListener()).getUpdatedRobotLocation();",
            "                if (robotLocationTransform != null) {",
            "                    lastLocation = robotLocationTransform;",
            "                }",
            "            }",
            "            /**",
            "             * Provide feedback as to where the robot was last located (if we know).",
            "             */",
            "            if (lastLocation != null) {",
            "                //  RobotLog.vv(TAG, \"robot=%s\", format(lastLocation));",
            "                telemetry.addData(\"Pos\", format(lastLocation));",
            "            } else {",
            "                telemetry.addData(\"Pos\", \"Unknown\");",
            "            }",
            "            telemetry.update();",
            "        }",
            "    }",
            "",
            "    /**",
            "     * A simple utility that extracts positioning information from a transformation matrix",
            "     * and formats it in a form palatable to a human being.",
            "     */",
            "    String format(OpenGLMatrix transformationMatrix) {",
            "        return transformationMatrix.formatAsTransform();",
            "    }",
            "",
            "    /**",
            "     * Sample one frame from the Vuforia stream and write it to a .PNG image file on the robot",
            "     * controller in the /sdcard/FIRST/data directory. The images can be downloaded using Android",
            "     * Studio's Device File Explorer, ADB, or the Media Transfer Protocol (MTP) integration into",
            "     * Windows Explorer, among other means. The images can be useful during robot design and calibration",
            "     * in order to get a sense of what the camera is actually seeing and so assist in camera",
            "     * aiming and alignment.",
            "     */",
            "    void captureFrameToFile() {",
            "        vuforia.getFrameOnce(Continuation.create(ThreadPool.getDefault(), new Consumer<Frame>()",
            "            {",
            "            @Override public void accept(Frame frame)",
            "                {",
            "                Bitmap bitmap = vuforia.convertFrameToBitmap(frame);",
            "                if (bitmap != null) {",
            "                    File file = new File(captureDirectory, String.format(Locale.getDefault(), \"VuforiaFrame-%d.png\", captureCounter++));",
            "                    try {",
            "                        FileOutputStream outputStream = new FileOutputStream(file);",
            "                        try {",
            "                            bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream);",
            "                        } finally {",
            "                            outputStream.close();",
            "                            telemetry.log().add(\"captured %s\", file.getName());",
            "                        }",
            "                    } catch (IOException e) {",
            "                        RobotLog.ee(TAG, e, \"exception in captureFrameToFile()\");",
            "                    }",
            "                }",
            "            }",
            "        }));",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptSoundsOnBotJava": {
        "prefix": "conceptSoundsOnBotJava",
        "description": "This file demonstrates how to play simple sounds on both the RC and DS phones.\nIt illustrates how to play sound files that have been copied to the RC Phone\nThis technique is best suited for use with OnBotJava since it does not require the app to be modified.\n\nOperation:\n\nGamepad X & B buttons are used to trigger sounds in this example, but any event can be used.\nNote: Time should be allowed for sounds to complete before playing other sounds.\n\n To play a new sound, you will need to copy the .wav files to the phone, and then provide the full path to them as part of your OpMode.\n This is done in this sample for the two sound files.  silver.wav and gold.wav\n\n You can put the files in a variety of soundPaths, but we recommend you put them in the /FIRST/blocks/sounds folder.\n Your OpModes will have guaranteed access to this folder, and you can transfer files into this folder using the BLOCKS web page.\n --  There is a link called \"sounds\" on the right hand side of the color bar on the BLOCKS page that can be used to send sound files to this folder by default.\n Or you can use Windows File Manager, or ADB to transfer the sound files\n\n To get full use of THIS sample, you will need to copy two sound file called silver.wav and gold.wav to /FIRST/blocks/sounds on the RC phone.\n They can be located here:\n     https://github.com/ftctechnh/ftc_app/tree/master/FtcRobotController/src/main/res/raw/gold.wav\n     https://github.com/ftctechnh/ftc_app/tree/master/FtcRobotController/src/main/res/raw/silver.wav\n ",
        "body": [
            "public class ConceptSoundsOnBotJava extends LinearOpMode {",
            "",
            "    // Point to sound files on the phone's drive",
            "    private String soundPath = \"/FIRST/blocks/sounds\";",
            "    private File goldFile   = new File(\"/sdcard\" + soundPath + \"/gold.wav\");",
            "    private File silverFile = new File(\"/sdcard\" + soundPath + \"/silver.wav\");",
            "",
            "    // Declare OpMode members.",
            "    private boolean isX = false;    // Gamepad button state variables",
            "    private boolean isB = false;",
            "",
            "    private boolean wasX = false;   // Gamepad button history variables",
            "    private boolean WasB = false;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        // Make sure that the sound files exist on the phone",
            "        boolean goldFound   = goldFile.exists();",
            "        boolean silverFound = silverFile.exists();",
            "",
            "        // Display sound status",
            "        telemetry.addData(\"gold sound\",   goldFound ?   \"Found\" : \"NOT Found \\nCopy gold.wav to \" + soundPath  );",
            "        telemetry.addData(\"silver sound\", silverFound ? \"Found\" : \"NOT Found \\nCopy silver.wav to \" + soundPath );",
            "",
            "        // Wait for the game to start (driver presses PLAY)",
            "        telemetry.addData(\">\", \"Press Start to continue\");",
            "        telemetry.update();",
            "        waitForStart();",
            "",
            "        telemetry.addData(\">\", \"Press X or B to play sounds.\");",
            "        telemetry.update();",
            "",
            "        // run until the end of the match (driver presses STOP)",
            "        while (opModeIsActive()) {",
            "",
            "            // say Silver each time gamepad X is pressed (This sound is a resource)",
            "            if (silverFound && (isX = gamepad1.x) && !wasX) {",
            "                SoundPlayer.getInstance().startPlaying(hardwareMap.appContext, silverFile);",
            "                telemetry.addData(\\\"Playing\\\", \\\"Silver File\\\");",
            "                telemetry.update();",
            "            }",
            "",
            "            // say Gold each time gamepad B is pressed  (This sound is a resource)",
            "            if (goldFound && (isB = gamepad1.b) && !WasB) {",
            "                SoundPlayer.getInstance().startPlaying(hardwareMap.appContext, goldFile);",
            "                telemetry.addData(\\\"Playing\\\", \\\"Gold File\\\");",
            "                telemetry.update();",
            "            }",
            "",
            "            // Save last button states",
            "            wasX = isX;",
            "            WasB = isB;",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptSoundsASJava": {
        "prefix": "conceptSoundsASJava",
        "description": "This file demonstrates how to play simple sounds on both the RC and DS phones.\nIt illustrates how to build sounds into your application as a resource.\nThis technique is best suited for use with Android Studio since it assumes you will be creating a new application\n\nIf you are using OnBotJava, please see the ConceptSoundsOnBotJava sample\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list\n\nOperation:\n\nGamepad X & B buttons are used to trigger sounds in this example, but any event can be used.\nNote: Time should be allowed for sounds to complete before playing other sounds.\n\nFor sound files to be used as a compiled-in resource, they need to be located in a folder called \"raw\" under your \"res\" (resources) folder.\nYou can create your own \"raw\" folder from scratch, or you can copy the one from the FtcRobotController module.\n\n    Android Studio coders will ultimately need a folder in your path as follows:\n      <project root>/TeamCode/src/main/res/raw\n\n    Copy any .wav files you want to play into this folder.\n    Make sure that your files ONLY use lower-case characters, and have no spaces or special characters other than underscore.\n\n    The name you give your .wav files will become the resource ID for these sounds.\n    eg:  gold.wav becomes R.raw.gold\n\n    If you wish to use the sounds provided for this sample, they are located in:\n    <project root>/FtcRobotController/src/main/res/raw\n    You can copy and paste the entire 'raw' folder using Android Studio.\n\n ",
        "body": [
            "public class ConceptSoundsASJava extends LinearOpMode {",
            "",
            "    // Declare OpMode members.",
            "    private boolean goldFound;      // Sound file present flags",
            "    private boolean silverFound;",
            "",
            "    private boolean isX = false;    // Gamepad button state variables",
            "    private boolean isB = false;",
            "",
            "    private boolean wasX = false;   // Gamepad button history variables",
            "    private boolean WasB = false;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        // Determine Resource IDs for sounds built into the RC application.",
            "        int silverSoundID = hardwareMap.appContext.getResources().getIdentifier(\"silver\\\", \\\"raw\\\", hardwareMap.appContext.getPackageName());",
            "        int goldSoundID   = hardwareMap.appContext.getResources().getIdentifier(\\\"gold\\\",   \\\"raw\\\", hardwareMap.appContext.getPackageName());",
            "",
            "        // Determine if sound resources are found.",
            "        // Note: Preloading is NOT required, but it's a good way to verify all your sounds are available before you run.",
            "        if (goldSoundID != 0)",
            "            goldFound   = SoundPlayer.getInstance().preload(hardwareMap.appContext, goldSoundID);",
            "",
            "        if (silverSoundID != 0)",
            "            silverFound = SoundPlayer.getInstance().preload(hardwareMap.appContext, silverSoundID);",
            "",
            "        // Display sound status",
            "        telemetry.addData(\\\"gold resource\\\",   goldFound ?   \\\"Found\\\" : \\\"NOT found\\n Add gold.wav to /src/main/res/raw\\\" );",
            "        telemetry.addData(\\\"silver resource\\\", silverFound ? \\\"Found\\\" : \\\"Not found\\n Add silver.wav to /src/main/res/raw\\\" );",
            "",
            "        // Wait for the game to start (driver presses PLAY)",
            "        telemetry.addData(\\\">\\\", \\\"Press Start to continue\\\");",
            "        telemetry.update();",
            "        waitForStart();",
            "",
            "        telemetry.addData(\\\">\\\", \\\"Press X, B to play sounds.\\\");",
            "        telemetry.update();",
            "",
            "        // run until the end of the match (driver presses STOP)",
            "        while (opModeIsActive()) {",
            "",
            "            // say Silver each time gamepad X is pressed (This sound is a resource)",
            "            if (silverFound && (isX = gamepad1.x) && !wasX) {",
            "                SoundPlayer.getInstance().startPlaying(hardwareMap.appContext, silverSoundID);",
            "                telemetry.addData(\\\"Playing\\\", \\\"Resource Silver\\\");",
            "                telemetry.update();",
            "            }",
            "",
            "            // say Gold each time gamepad B is pressed  (This sound is a resource)",
            "            if (goldFound && (isB = gamepad1.b) && !WasB) {",
            "                SoundPlayer.getInstance().startPlaying(hardwareMap.appContext, goldSoundID);",
            "                telemetry.addData(\\\"Playing\\\", \\\"Resource Gold\\\");",
            "                telemetry.update();",
            "            }",
            "",
            "            // Save last button states",
            "            wasX = isX;",
            "            WasB = isB;",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptRampMotorSpeed": {
        "prefix": "conceptRampMotorSpeed",
        "description": "This OpMode ramps a single motor speed up and down repeatedly until Stop is pressed.\nThe code is structured as a LinearOpMode\n\nThis code assumes a DC motor configured with the name \"left_drive\" as is found on a Robot.\n\nINCREMENT sets how much to increase/decrease the power each cycle\nCYCLE_MS sets the update period.\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list\n ",
        "body": [
            "public class ConceptRampMotorSpeed extends LinearOpMode {",
            "",
            "    static final double INCREMENT   = 0.01;     // amount to ramp motor each CYCLE_MS cycle",
            "    static final int    CYCLE_MS    =   50;     // period of each cycle",
            "    static final double MAX_FWD     =  1.0;     // Maximum FWD power applied to motor",
            "    static final double MAX_REV     = -1.0;     // Maximum REV power applied to motor",
            "",
            "    // Define class members",
            "    DcMotor motor;",
            "    double  power   = 0;",
            "    boolean rampUp  = true;",
            "",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        // Connect to motor (Assume standard left wheel)",
            "        // Change the text in quotes to match any motor name on your robot.",
            "        motor = hardwareMap.get(DcMotor.class, \"left_drive\\\");",
            "",
            "        // Wait for the start button",
            "        telemetry.addData(\\\">\\\", \\\"Press Start to run Motors.\\\" );",
            "        telemetry.update();",
            "        waitForStart();",
            "",
            "        // Ramp motor speeds till stop pressed.",
            "        while(opModeIsActive()) {",
            "",
            "            // Ramp the motors, according to the rampUp variable.",
            "            if (rampUp) {",
            "                // Keep stepping up until we hit the max value.",
            "                power += INCREMENT ;",
            "                if (power >= MAX_FWD ) {",
            "                    power = MAX_FWD;",
            "                    rampUp = !rampUp;   // Switch ramp direction",
            "                }",
            "            }",
            "            else {",
            "                // Keep stepping down until we hit the min value.",
            "                power -= INCREMENT ;",
            "                if (power <= MAX_REV ) {",
            "                    power = MAX_REV;",
            "                    rampUp = !rampUp;  // Switch ramp direction",
            "                }",
            "            }",
            "",
            "            // Display the current value",
            "            telemetry.addData(\\\"Motor Power\\\", \\\"%5.2f\\\", power);",
            "            telemetry.addData(\\\">\\\", \\\"Press Stop to end test.\\\" );",
            "            telemetry.update();",
            "",
            "            // Set the motor to the new power and pause;",
            "            motor.setPower(power);",
            "            sleep(CYCLE_MS);",
            "            idle();",
            "        }",
            "",
            "        // Turn off motor and signal done;",
            "        motor.setPower(0);",
            "        telemetry.addData(\\\">\\\", \\\"Done\\\");",
            "        telemetry.update();",
            "",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptCompassCalibration": {
        "prefix": "conceptCompassCalibration",
        "description": "This file illustrates the concept of calibrating a MR Compass\n  This code assumes there is a compass configured with the name \"compass\"\n\n  This code will put the compass into calibration mode, wait three seconds and then attempt\n  to rotate two full turns clockwise.  This will allow the compass to do a magnetic calibration.\n\n  Once compete, the program will put the compass back into measurement mode and check to see if the\n  calibration was successful.\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list\n ",
        "body": [
            "public class ConceptCompassCalibration extends LinearOpMode {",
            "",
            "    /* Declare OpMode members. */",
            "    public DcMotor leftDrive   = null;",
            "    public DcMotor  rightDrive  = null;",
            "    private ElapsedTime runtime = new ElapsedTime();",
            "    CompassSensor       compass;",
            "",
            "    final static double     MOTOR_POWER   = 0.2; // scale from 0 to 1",
            "    static final long       HOLD_TIME_MS  = 3000;",
            "    static final double     CAL_TIME_SEC  = 20;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        // Initialize the drive system variables.",
            "        leftDrive  = hardwareMap.get(DcMotor.class, \"left_drive\\\");",
            "        rightDrive = hardwareMap.get(DcMotor.class, \\\"right_drive\\\");",
            "",
            "        // To drive forward, most robots need the motor on one side to be reversed, because the axles point in opposite directions.",
            "        // Pushing the left stick forward MUST make robot go forward. So adjust these two lines based on your first test drive.",
            "        // Note: The settings here assume direct drive on left and right wheels.  Gear Reduction or 90 Deg drives may require direction flips",
            "        leftDrive.setDirection(DcMotor.Direction.REVERSE);",
            "        rightDrive.setDirection(DcMotor.Direction.FORWARD);",
            "",
            "        // get a reference to our Compass Sensor object.",
            "        compass = hardwareMap.get(CompassSensor.class, \\\"compass\\\");",
            "",
            "        // Send telemetry message to signify robot waiting;",
            "        telemetry.addData(\\\"Status\\\", \\\"Ready to cal\\\");    //",
            "        telemetry.update();",
            "",
            "        // Wait for the game to start (driver presses PLAY)",
            "        waitForStart();",
            "",
            "        // Set the compass to calibration mode",
            "        compass.setMode(CompassSensor.CompassMode.CALIBRATION_MODE);",
            "        telemetry.addData(\\\"Compass\\\", \\\"Compass in calibration mode\\\");",
            "        telemetry.update();",
            "",
            "        sleep(HOLD_TIME_MS);  // Just do a sleep while we switch modes",
            "",
            "        // Start the robot rotating clockwise",
            "        telemetry.addData(\\\"Compass\\\", \\\"Calibration mode. Turning the robot...\\\");",
            "        telemetry.update();",
            "        leftDrive.setPower(MOTOR_POWER);",
            "        rightDrive.setPower(-MOTOR_POWER);",
            "",
            "        // run until time expires OR the driver presses STOP;",
            "        runtime.reset();",
            "        while (opModeIsActive() && (runtime.time() < CAL_TIME_SEC)) {",
            "            idle();",
            "        }",
            "",
            "        // Stop all motors and turn off claibration",
            "        leftDrive.setPower(0);",
            "        rightDrive.setPower(0);",
            "        compass.setMode(CompassSensor.CompassMode.MEASUREMENT_MODE);",
            "        telemetry.addData(\\\"Compass\\\", \\\"Returning to measurement mode\\\");",
            "        telemetry.update();",
            "",
            "        sleep(HOLD_TIME_MS);  // Just do a sleep while we switch modes",
            "",
            "        // Report whether the Calibration was successful or not.",
            "        if (compass.calibrationFailed())",
            "            telemetry.addData(\\\"Compass\\\", \\\"Calibrate Failed. Try Again!\\\");",
            "        else",
            "            telemetry.addData(\\\"Compass\\\", \\\"Calibrate Passed.\\\");",
            "        telemetry.update();",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptI2cAddressChange": {
        "prefix": "conceptI2cAddressChange",
        "description": "An example of a linear op mode that shows how to change the I2C address.\n ",
        "body": [
            "public class ConceptI2cAddressChange extends LinearOpMode {",
            "",
            "  public static final int ADDRESS_SET_NEW_I2C_ADDRESS = 0x70;",
            "  // trigger bytes used to change I2C address on ModernRobotics sensors.",
            "  public static final byte TRIGGER_BYTE_1 = 0x55;",
            "  public static final byte TRIGGER_BYTE_2 = (byte) 0xaa;",
            "",
            "  // Expected bytes from the Modern Robotics IR Seeker V3 memory map",
            "  public static final byte IR_SEEKER_V3_FIRMWARE_REV = 0x12;",
            "  public static final byte IR_SEEKER_V3_SENSOR_ID = 0x49;",
            "  public static final I2cAddr IR_SEEKER_V3_ORIGINAL_ADDRESS = I2cAddr.create8bit(0x38);",
            "",
            "  // Expected bytes from the Modern Robotics Color Sensor memory map",
            "  public static final byte COLOR_SENSOR_FIRMWARE_REV = 0x10;",
            "  public static final byte COLOR_SENSOR_SENSOR_ID = 0x43;",
            "  public static final byte COLOR_SENSOR_ORIGINAL_ADDRESS = 0x3C;",
            "",
            "  public static final byte MANUFACTURER_CODE = 0x4d;",
            "  // Currently, this is set to expect the bytes from the IR Seeker.",
            "  // If you change these values so you're setting \"FIRMWARE_REV\\\" to",
            "  // COLOR_SENSOR_FIRMWARE_REV, and \\\"SENSOR_ID\\\" to \\\"COLOR_SENSOR_SENSOR_ID\\\",",
            "  // you'll be able to change the I2C address of the ModernRoboticsColorSensor.",
            "  // If the bytes you're expecting are different than what this op mode finds,",
            "  // a comparison will be printed out into the logfile.",
            "  public static final byte FIRMWARE_REV = IR_SEEKER_V3_FIRMWARE_REV;",
            "  public static final byte SENSOR_ID = IR_SEEKER_V3_SENSOR_ID;",
            "",
            "  // These byte values are common with most Modern Robotics sensors.",
            "  public static final int READ_MODE = 0x80;",
            "  public static final int ADDRESS_MEMORY_START = 0x0;",
            "  public static final int TOTAL_MEMORY_LENGTH = 0x0c;",
            "  public static final int BUFFER_CHANGE_ADDRESS_LENGTH = 0x03;",
            "",
            "  // The port where your sensor is connected.",
            "  int port = 5;",
            "",
            "  byte[] readCache;",
            "  Lock readLock;",
            "  byte[] writeCache;",
            "  Lock writeLock;",
            "",
            "  I2cAddr currentAddress = IR_SEEKER_V3_ORIGINAL_ADDRESS;",
            "  // I2c addresses on Modern Robotics devices must be divisible by 2, and between 0x7e and 0x10",
            "  // Different hardware may have different rules.",
            "  // Be sure to read the requirements for the hardware you're using!",
            "  // If you use an invalid address, you may make your device completely unusable.",
            "  I2cAddr newAddress = I2cAddr.create8bit(0x42);",
            "",
            "  DeviceInterfaceModule dim;",
            "",
            "  @Override",
            "  public void runOpMode() {",
            "",
            "    // set up the hardware devices we are going to use",
            "    dim = hardwareMap.get(DeviceInterfaceModule.class, \\\"dim\\\");",
            "",
            "    readCache = dim.getI2cReadCache(port);",
            "    readLock = dim.getI2cReadCacheLock(port);",
            "    writeCache = dim.getI2cWriteCache(port);",
            "    writeLock = dim.getI2cWriteCacheLock(port);",
            "",
            "    // I2c addresses on Modern Robotics devices must be divisible by 2, and between 0x7e and 0x10",
            "    // Different hardware may have different rules.",
            "    // Be sure to read the requirements for the hardware you're using!",
            "    ModernRoboticsUsbDeviceInterfaceModule.throwIfModernRoboticsI2cAddressIsInvalid(newAddress);",
            "",
            "    // wait for the start button to be pressed",
            "    waitForStart();",
            "",
            "    performAction(\\\"read\\\", port, currentAddress, ADDRESS_MEMORY_START, TOTAL_MEMORY_LENGTH);",
            "",
            "    while(!dim.isI2cPortReady(port)) {",
            "      telemetry.addData(\\\"I2cAddressChange\\\", \\\"waiting for the port to be ready...\\\");",
            "      telemetry.update();",
            "      sleep(1000);",
            "    }",
            "",
            "    // update the local cache",
            "    dim.readI2cCacheFromController(port);",
            "",
            "    // make sure the first bytes are what we think they should be.",
            "    int count = 0;",
            "    int[] initialArray = {READ_MODE, currentAddress.get8Bit(), ADDRESS_MEMORY_START, TOTAL_MEMORY_LENGTH, FIRMWARE_REV, MANUFACTURER_CODE, SENSOR_ID};",
            "    while (!foundExpectedBytes(initialArray, readLock, readCache)) {",
            "      telemetry.addData(\\\"I2cAddressChange\\\", \\\"Confirming that we're reading the correct bytes...\\\");",
            "      telemetry.update();",
            "      dim.readI2cCacheFromController(port);",
            "      sleep(1000);",
            "      count++;",
            "      // if we go too long with failure, we probably are expecting the wrong bytes.",
            "      if (count >= 10)  {",
            "        telemetry.addData(\\\"I2cAddressChange\\\", String.format(\\\"Looping too long with no change, probably have the wrong address. Current address: 8bit=0x%02x\\\", currentAddress.get8Bit()));",
            "        hardwareMap.irSeekerSensor.get(String.format(\\\"Looping too long with no change, probably have the wrong address. Current address: 8bit=0x%02x\\\", currentAddress.get8Bit()));",
            "        telemetry.update();",
            "      }",
            "    }",
            "",
            "    // Enable writes to the correct segment of the memory map.",
            "    performAction(\\\"write\\\", port, currentAddress, ADDRESS_SET_NEW_I2C_ADDRESS, BUFFER_CHANGE_ADDRESS_LENGTH);",
            "",
            "    // Write out the trigger bytes, and the new desired address.",
            "    writeNewAddress();",
            "    dim.setI2cPortActionFlag(port);",
            "    dim.writeI2cCacheToController(port);",
            "",
            "    telemetry.addData(\\\"I2cAddressChange\\\", \\\"Giving the hardware 60 seconds to make the change...\\\");",
            "    telemetry.update();",
            "",
            "    // Changing the I2C address takes some time.",
            "    sleep(60000);",
            "",
            "    // Query the new address and see if we can get the bytes we expect.",
            "    dim.enableI2cReadMode(port, newAddress, ADDRESS_MEMORY_START, TOTAL_MEMORY_LENGTH);",
            "    dim.setI2cPortActionFlag(port);",
            "    dim.writeI2cCacheToController(port);",
            "",
            "    int[] confirmArray = {READ_MODE, newAddress.get8Bit(), ADDRESS_MEMORY_START, TOTAL_MEMORY_LENGTH, FIRMWARE_REV, MANUFACTURER_CODE, SENSOR_ID};",
            "    while (!foundExpectedBytes(confirmArray, readLock, readCache)) {",
            "      telemetry.addData(\\\"I2cAddressChange\\\", \\\"Have not confirmed the changes yet...\\\");",
            "      telemetry.update();",
            "      dim.readI2cCacheFromController(port);",
            "      sleep(1000);",
            "    }",
            "",
            "    telemetry.addData(\\\"I2cAddressChange\\\", \\\"Successfully changed the I2C address. New address: 8bit=0x%02x\\\", newAddress.get8Bit());",
            "    telemetry.update();",
            "    RobotLog.i(\\\"Successfully changed the I2C address.\\\" + String.format(\\\"New address: 8bit=0x%02x\\\", newAddress.get8Bit()));",
            "",
            "    /**** IMPORTANT NOTE ******/",
            "    // You need to add a line like this at the top of your op mode",
            "    // to update the I2cAddress in the driver.",
            "    //irSeeker.setI2cAddress(newAddress);",
            "    /***************************/",
            "",
            "  }",
            "",
            "  private boolean foundExpectedBytes(int[] byteArray, Lock lock, byte[] cache) {",
            "    try {",
            "      lock.lock();",
            "      boolean allMatch = true;",
            "      StringBuilder s = new StringBuilder(300 * 4);",
            "      String mismatch = \\\"\\\";",
            "      for (int i = 0; i < byteArray.length; i++) {",
            "        s.append(String.format(\\\"expected: %02x, got: %02x \\n\\\", TypeConversion.unsignedByteToInt( (byte) byteArray[i]), cache[i]));",
            "        if (TypeConversion.unsignedByteToInt(cache[i]) != TypeConversion.unsignedByteToInt( (byte) byteArray[i])) {",
            "          mismatch = String.format(\\\"i: %d, byteArray[i]: %02x, cache[i]: %02x\\\", i, byteArray[i], cache[i]);",
            "          allMatch = false;",
            "        }",
            "      }",
            "      RobotLog.e(s.toString() + \\\"\\n allMatch: \\\" + allMatch + \\\", mismatch: \\\" + mismatch);",
            "      return allMatch;",
            "    } finally {",
            "      lock.unlock();",
            "    }",
            "  }",
            "",
            "  private void performAction(String actionName, int port, I2cAddr i2cAddress, int memAddress, int memLength) {",
            "    if (actionName.equalsIgnoreCase(\\\"read\\\")) dim.enableI2cReadMode(port, i2cAddress, memAddress, memLength);",
            "    if (actionName.equalsIgnoreCase(\\\"write\\\")) dim.enableI2cWriteMode(port, i2cAddress, memAddress, memLength);",
            "",
            "    dim.setI2cPortActionFlag(port);",
            "    dim.writeI2cCacheToController(port);",
            "    dim.readI2cCacheFromController(port);",
            "  }",
            "",
            "  private void writeNewAddress() {",
            "    try {",
            "      writeLock.lock();",
            "      writeCache[4] = (byte) newAddress.get8Bit();",
            "      writeCache[5] = TRIGGER_BYTE_1;",
            "      writeCache[6] = TRIGGER_BYTE_2;",
            "    } finally {",
            "      writeLock.unlock();",
            "    }",
            "  }",
            "}",
            ""
        ]
    },
    "ConceptMotorBulkRead": {
        "prefix": "conceptMotorBulkRead",
        "description": "No Description Given",
        "body": [
            "public class ConceptMotorBulkRead extends LinearOpMode {",
            "",
            "    final int       TEST_CYCLES    = 500;   // Number of control cycles to run to determine cycle times.",
            "",
            "    private DcMotorEx m1, m2, m3, m4; // Motor Objects",
            "    private long      e1, e2, e3, e4; // Encoder Values",
            "    private double    v1, v2, v3, v4; // Velocities",
            "",
            "    // Cycle Times",
            "    double t1 = 0;",
            "    double t2 = 0;",
            "    double t3 = 0;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        int cycles;",
            "",
            "        // Important Step 1:  Make sure you use DcMotorEx when you instantiate your motors.",
            "        m1 = hardwareMap.get(DcMotorEx.class, \"m1\\\");  // Configure the robot to use these 4 motor names,",
            "        m2 = hardwareMap.get(DcMotorEx.class, \\\"m2\\\");  // or change these strings to match your existing Robot Configuration.",
            "        m3 = hardwareMap.get(DcMotorEx.class, \\\"m3\\\");",
            "        m4 = hardwareMap.get(DcMotorEx.class, \\\"m4\\\");",
            "",
            "        // Important Step 2: Get access to a list of Expansion Hub Modules to enable changing caching methods.",
            "        List<LynxModule> allHubs = hardwareMap.getAll(LynxModule.class);",
            "",
            "        ElapsedTime timer = new ElapsedTime();",
            "",
            "        telemetry.addData(\\\">\\\", \\\"Press play to start tests\\\");",
            "        telemetry.addData(\\\">\\\", \\\"Test results will update for each access method.\\\");",
            "        telemetry.update();",
            "        waitForStart();",
            "",
            "        // --------------------------------------------------------------------------------------",
            "        // Run control loop using legacy encoder reads",
            "        // In this mode, a single read is done for each encoder position, and a bulk read is done for each velocity read.",
            "        // This is the worst case scenario.",
            "        // This is the same as using LynxModule.BulkCachingMode.OFF",
            "        // --------------------------------------------------------------------------------------",
            "",
            "        displayCycleTimes(\\\"Test 1 of 3 (Wait for completion)\\\");",
            "",
            "        timer.reset();",
            "        cycles = 0;",
            "        while (opModeIsActive() && (cycles++ < TEST_CYCLES)) {",
            "            e1 = m1.getCurrentPosition();",
            "            e2 = m2.getCurrentPosition();",
            "            e3 = m3.getCurrentPosition();",
            "            e4 = m4.getCurrentPosition();",
            "",
            "            v1 = m1.getVelocity();",
            "            v2 = m2.getVelocity();",
            "            v3 = m3.getVelocity();",
            "            v4 = m4.getVelocity();",
            "",
            "            // Put Control loop action code here.",
            "",
            "        }",
            "        // calculate the average cycle time.",
            "        t1 = timer.milliseconds() / cycles;",
            "        displayCycleTimes(\\\"Test 2 of 3 (Wait for completion)\\\");",
            "",
            "        // --------------------------------------------------------------------------------------",
            "        // Run test cycles using AUTO cache mode",
            "        // In this mode, only one bulk read is done per cycle, UNLESS you read a specific encoder/velocity item AGAIN in that cycle.",
            "        // --------------------------------------------------------------------------------------",
            "",
            "        // Important Step 3: Option A. Set all Expansion hubs to use the AUTO Bulk Caching mode",
            "        for (LynxModule module : allHubs) {",
            "            module.setBulkCachingMode(LynxModule.BulkCachingMode.AUTO);",
            "        }",
            "",
            "        timer.reset();",
            "        cycles = 0;",
            "        while (opModeIsActive() && (cycles++ < TEST_CYCLES)) {",
            "            e1 = m1.getCurrentPosition();  // Uses 1 bulk-read for all 4 encoder/velocity reads,",
            "            e2 = m2.getCurrentPosition();  // but don't do any `get` operations more than once per cycle.",
            "            e3 = m3.getCurrentPosition();",
            "            e4 = m4.getCurrentPosition();",
            "",
            "            v1 = m1.getVelocity();",
            "            v2 = m2.getVelocity();",
            "            v3 = m3.getVelocity();",
            "            v4 = m4.getVelocity();",
            "",
            "            // Put Control loop action code here.",
            "",
            "        }",
            "        // calculate the average cycle time.",
            "        t2 = timer.milliseconds() / cycles;",
            "        displayCycleTimes(\\\"Test 3 of 3 (Wait for completion)\\\");",
            "",
            "        // --------------------------------------------------------------------------------------",
            "        // Run test cycles using MANUAL cache mode",
            "        // In this mode, only one block read is done each control cycle.",
            "        // This is the MOST efficient method, but it does require that the cache is cleared manually each control cycle.",
            "        // --------------------------------------------------------------------------------------",
            "",
            "        // Important Step 3: Option B. Set all Expansion hubs to use the MANUAL Bulk Caching mode",
            "        for (LynxModule module : allHubs) {",
            "            module.setBulkCachingMode(LynxModule.BulkCachingMode.MANUAL);",
            "        }",
            "",
            "        timer.reset();",
            "        cycles = 0;",
            "        while (opModeIsActive() && (cycles++ < TEST_CYCLES)) {",
            "",
            "            // Important Step 4: If you are using MANUAL mode, you must clear the BulkCache once per control cycle",
            "            for (LynxModule module : allHubs) {",
            "                module.clearBulkCache();",
            "            }",
            "",
            "            e1 = m1.getCurrentPosition();   // Uses 1 bulk-read to obtain ALL the motor data",
            "            e2 = m2.getCurrentPosition();   // There is no penalty for doing more `get` operations in this cycle,",
            "            e3 = m3.getCurrentPosition();   // but they will return the same data.",
            "            e4 = m4.getCurrentPosition();",
            "",
            "            v1 = m1.getVelocity();",
            "            v2 = m2.getVelocity();",
            "            v3 = m3.getVelocity();",
            "            v4 = m4.getVelocity();",
            "",
            "            // Put Control loop action code here.",
            "",
            "        }",
            "        // calculate the average cycle time.",
            "        t3 = timer.milliseconds() / cycles;",
            "        displayCycleTimes(\\\"Complete\\\");",
            "",
            "        // wait until op-mode is stopped by user, before clearing display.",
            "        while (opModeIsActive()) ;",
            "    }",
            "",
            "    // Display three comparison times.",
            "    void displayCycleTimes(String status) {",
            "        telemetry.addData(\\\"Testing\\\", status);",
            "        telemetry.addData(\\\"Cache = OFF\\\",    \\\"%5.1f mS/cycle\\\", t1);",
            "        telemetry.addData(\\\"Cache = AUTO\\\",   \\\"%5.1f mS/cycle\\\", t2);",
            "        telemetry.addData(\\\"Cache = MANUAL\\\", \\\"%5.1f mS/cycle\\\", t3);",
            "        telemetry.update();",
            "    }",
            "}",
            "",
            ""
        ]
    },
    "ConceptTensorFlowObjectDetectionWebcam": {
        "prefix": "conceptTensorFlowObjectDetectionWebcam",
        "description": "    Initialize the TensorFlow Object Detection engine.\n     ",
        "body": [
            "public class ConceptTensorFlowObjectDetectionWebcam extends LinearOpMode {",
            "",
            "    /*",
            "     * Specify the source for the Tensor Flow Model.",
            "     * If the TensorFlowLite object model is included in the Robot Controller App as an \"asset\\\",",
            "     * the OpMode must to load it using loadModelFromAsset().  However, if a team generated model",
            "     * has been downloaded to the Robot Controller's SD FLASH memory, it must to be loaded using loadModelFromFile()",
            "     * Here we assume it's an Asset.    Also see method initTfod() below .",
            "     */",
            "    private static final String TFOD_MODEL_ASSET = \\\"PowerPlay.tflite\\\";",
            "    // private static final String TFOD_MODEL_FILE  = \\\"/sdcard/FIRST/tflitemodels/CustomTeamModel.tflite\\\";",
            "",
            "",
            "    private static final String[] LABELS = {",
            "            \\\"1 Bolt\\\",",
            "            \\\"2 Bulb\\\",",
            "            \\\"3 Panel\\\"",
            "    };",
            "",
            "    /*",
            "     * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which",
            "     * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.",
            "     * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer",
            "     * web site at https://developer.vuforia.com/license-manager.",
            "     *",
            "     * Vuforia license keys are always 380 characters long, and look as if they contain mostly",
            "     * random data. As an example, here is a example of a fragment of a valid key:",
            "     *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...",
            "     * Once you've obtained a license key, copy the string from the Vuforia web site",
            "     * and paste it in to your code on the next line, between the double quotes.",
            "     */",
            "    private static final String VUFORIA_KEY =",
            "            \\\" -- YOUR NEW VUFORIA KEY GOES HERE  --- \\\";",
            "",
            "    /**",
            "     * {@link #vuforia} is the variable we will use to store our instance of the Vuforia",
            "     * localization engine.",
            "     */",
            "    private VuforiaLocalizer vuforia;",
            "",
            "    /**",
            "     * {@link #tfod} is the variable we will use to store our instance of the TensorFlow Object",
            "     * Detection engine.",
            "     */",
            "    private TFObjectDetector tfod;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "        // The TFObjectDetector uses the camera frames from the VuforiaLocalizer, so we create that",
            "        // first.",
            "        initVuforia();",
            "        initTfod();",
            "",
            "        /**",
            "         * Activate TensorFlow Object Detection before we wait for the start command.",
            "         * Do it here so that the Camera Stream window will have the TensorFlow annotations visible.",
            "         **/",
            "        if (tfod != null) {",
            "            tfod.activate();",
            "",
            "            // The TensorFlow software will scale the input images from the camera to a lower resolution.",
            "            // This can result in lower detection accuracy at longer distances (> 55cm or 22\\\").",
            "            // If your target is at distance greater than 50 cm (20\\\") you can increase the magnification value",
            "            // to artificially zoom in to the center of image.  For best results, the \\\"aspectRatio\\\" argument",
            "            // should be set to the value of the images used to create the TensorFlow Object Detection model",
            "            // (typically 16/9).",
            "            tfod.setZoom(1.0, 16.0/9.0);",
            "        }",
            "",
            "        /** Wait for the game to begin */",
            "        telemetry.addData(\\\">\\\", \\\"Press Play to start op mode\\\");",
            "        telemetry.update();",
            "        waitForStart();",
            "",
            "        if (opModeIsActive()) {",
            "            while (opModeIsActive()) {",
            "                if (tfod != null) {",
            "                    // getUpdatedRecognitions() will return null if no new information is available since",
            "                    // the last time that call was made.",
            "                    List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();",
            "                    if (updatedRecognitions != null) {",
            "                        telemetry.addData(\\\"# Objects Detected\\\", updatedRecognitions.size());",
            "",
            "                        // step through the list of recognitions and display image position/size information for each one",
            "                        // Note: \\\"Image number\\\" refers to the randomized image orientation/number",
            "                        for (Recognition recognition : updatedRecognitions) {",
            "                            double col = (recognition.getLeft() + recognition.getRight()) / 2 ;",
            "                            double row = (recognition.getTop()  + recognition.getBottom()) / 2 ;",
            "                            double width  = Math.abs(recognition.getRight() - recognition.getLeft()) ;",
            "                            double height = Math.abs(recognition.getTop()  - recognition.getBottom()) ;",
            "",
            "                            telemetry.addData(\\\"\\\",\\\" \\\");",
            "                            telemetry.addData(\\\"Image\\\", \\\"%s (%.0f %% Conf.)\\\", recognition.getLabel(), recognition.getConfidence() * 100 );",
            "                            telemetry.addData(\\\"- Position (Row/Col)\\\",\\\"%.0f / %.0f\\\", row, col);",
            "                            telemetry.addData(\\\"- Size (Width/Height)\\\",\\\"%.0f / %.0f\\\", width, height);",
            "                        }",
            "                        telemetry.update();",
            "                    }",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    /**",
            "     * Initialize the Vuforia localization engine.",
            "     */",
            "    private void initVuforia() {",
            "        /*",
            "         * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine.",
            "         */",
            "        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();",
            "",
            "        parameters.vuforiaLicenseKey = VUFORIA_KEY;",
            "        parameters.cameraName = hardwareMap.get(WebcamName.class, \\\"Webcam 1\\\");",
            "",
            "        //  Instantiate the Vuforia engine",
            "        vuforia = ClassFactory.getInstance().createVuforia(parameters);",
            "    }",
            "",
            "    /**",
            "     * Initialize the TensorFlow Object Detection engine.",
            "     */",
            "    private void initTfod() {",
            "        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(",
            "            \\\"tfodMonitorViewId\\\", \\\"id\\\", hardwareMap.appContext.getPackageName());",
            "        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);",
            "        tfodParameters.minResultConfidence = 0.75f;",
            "        tfodParameters.isModelTensorFlow2 = true;",
            "        tfodParameters.inputSize = 300;",
            "        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);",
            "",
            "        // Use loadModelFromAsset() if the TF Model is built in as an asset by Android Studio",
            "        // Use loadModelFromFile() if you have downloaded a custom team model to the Robot Controller's FLASH.",
            "        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABELS);",
            "        // tfod.loadModelFromFile(TFOD_MODEL_FILE, LABELS);",
            "    }",
            "}",
            ""
        ]
    },
    "BasicOpMode Iterative": {
        "prefix": "basicOpModeIterative",
        "description": "This file contains an example of an iterative (Non-Linear) \"OpMode\".\nAn OpMode is a 'program' that runs in either the autonomous or the teleop period of an FTC match.\nThe names of OpModes appear on the menu of the FTC Driver Station.\nWhen a selection is made from the menu, the corresponding OpMode\nclass is instantiated on the Robot Controller and executed.\n\nThis particular OpMode just executes a basic Tank Drive Teleop for a two wheeled robot\nIt includes all the skeletal structure that all iterative OpModes contain.\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list\n ",
        "body": [
            "public class BasicOpMode_Iterative extends OpMode",
            "{",
            "    // Declare OpMode members.",
            "    private ElapsedTime runtime = new ElapsedTime();",
            "    private DcMotor leftDrive = null;",
            "    private DcMotor rightDrive = null;",
            "",
            "    /*",
            "     * Code to run ONCE when the driver hits INIT",
            "     */",
            "    @Override",
            "    public void init() {",
            "        telemetry.addData(\"Status\\\", \\\"Initialized\\\");",
            "",
            "        // Initialize the hardware variables. Note that the strings used here as parameters",
            "        // to 'get' must correspond to the names assigned during the robot configuration",
            "        // step (using the FTC Robot Controller app on the phone).",
            "        leftDrive  = hardwareMap.get(DcMotor.class, \\\"left_drive\\\");",
            "        rightDrive = hardwareMap.get(DcMotor.class, \\\"right_drive\\\");",
            "",
            "        // To drive forward, most robots need the motor on one side to be reversed, because the axles point in opposite directions.",
            "        // Pushing the left stick forward MUST make robot go forward. So adjust these two lines based on your first test drive.",
            "        // Note: The settings here assume direct drive on left and right wheels.  Gear Reduction or 90 Deg drives may require direction flips",
            "        leftDrive.setDirection(DcMotor.Direction.REVERSE);",
            "        rightDrive.setDirection(DcMotor.Direction.FORWARD);",
            "",
            "        // Tell the driver that initialization is complete.",
            "        telemetry.addData(\\\"Status\\\", \\\"Initialized\\\");",
            "    }",
            "",
            "    /*",
            "     * Code to run REPEATEDLY after the driver hits INIT, but before they hit PLAY",
            "     */",
            "    @Override",
            "    public void init_loop() {",
            "    }",
            "",
            "    /*",
            "     * Code to run ONCE when the driver hits PLAY",
            "     */",
            "    @Override",
            "    public void start() {",
            "        runtime.reset();",
            "    }",
            "",
            "    /*",
            "     * Code to run REPEATEDLY after the driver hits PLAY but before they hit STOP",
            "     */",
            "    @Override",
            "    public void loop() {",
            "        // Setup a variable for each drive wheel to save power level for telemetry",
            "        double leftPower;",
            "        double rightPower;",
            "",
            "        // Choose to drive using either Tank Mode, or POV Mode",
            "        // Comment out the method that's not used.  The default below is POV.",
            "",
            "        // POV Mode uses left stick to go forward, and right stick to turn.",
            "        // - This uses basic math to combine motions and is easier to drive straight.",
            "        double drive = -gamepad1.left_stick_y;",
            "        double turn  =  gamepad1.right_stick_x;",
            "        leftPower    = Range.clip(drive + turn, -1.0, 1.0) ;",
            "        rightPower   = Range.clip(drive - turn, -1.0, 1.0) ;",
            "",
            "        // Tank Mode uses one stick to control each wheel.",
            "        // - This requires no math, but it is hard to drive forward slowly and keep straight.",
            "        // leftPower  = -gamepad1.left_stick_y ;",
            "        // rightPower = -gamepad1.right_stick_y ;",
            "",
            "        // Send calculated power to wheels",
            "        leftDrive.setPower(leftPower);",
            "        rightDrive.setPower(rightPower);",
            "",
            "        // Show the elapsed game time and wheel power.",
            "        telemetry.addData(\\\"Status\\\", \\\"Run Time: \\\" + runtime.toString());",
            "        telemetry.addData(\\\"Motors\\\", \\\"left (%.2f), right (%.2f)\\\", leftPower, rightPower);",
            "    }",
            "",
            "    /*",
            "     * Code to run ONCE after the driver hits STOP",
            "     */",
            "    @Override",
            "    public void stop() {",
            "    }",
            "",
            "}",
            ""
        ]
    },
    "ConceptVuforiaUltimateGoalNavigation": {
        "prefix": "conceptVuforiaUltimateGoalNavigation",
        "description": "        In order for localization to work, we need to tell the system where each target is on the field, and\n        where the phone resides on the robot.  These specifications are in the form of <em>transformation matrices.</em>\n        Transformation matrices are a central, important concept in the math here involved in localization.\n        See <a href=\"https://en.wikipedia.org/wiki/Transformation_matrix\">Transformation Matrix</a>\n        for detailed information. Commonly, you'll encounter transformation matrices as instances\n        of the {@link OpenGLMatrix} class.\n        \n        If you are standing in the Red Alliance Station looking towards the center of the field,\n            - The X axis runs from your left to the right. (positive from the center to the right)\n            - The Y axis runs from the Red Alliance Station towards the other side of the field\n              where the Blue Alliance Station is. (Positive is from the center, towards the BlueAlliance station)\n            - The Z axis runs from the floor, upwards towards the ceiling.  (Positive is above the floor)\n        \n        Before being transformed, each target image is conceptually located at the origin of the field's\n         coordinate system (the center of the field), facing up.\n         ",
        "body": [
            "public class ConceptVuforiaUltimateGoalNavigation extends LinearOpMode {",
            "",
            "    // IMPORTANT:  For Phone Camera, set 1) the camera source and 2) the orientation, based on how your phone is mounted:",
            "    // 1) Camera Source.  Valid choices are:  BACK (behind screen) or FRONT (selfie side)",
            "    // 2) Phone Orientation. Choices are: PHONE_IS_PORTRAIT = true (portrait) or PHONE_IS_PORTRAIT = false (landscape)",
            "    //",
            "    // NOTE: If you are running on a CONTROL HUB, with only one USB WebCam, you must select CAMERA_CHOICE = BACK; and PHONE_IS_PORTRAIT = false;",
            "    //",
            "    private static final VuforiaLocalizer.CameraDirection CAMERA_CHOICE = BACK;",
            "    private static final boolean PHONE_IS_PORTRAIT = false  ;",
            "",
            "    /*",
            "     * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which",
            "     * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.",
            "     * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer",
            "     * web site at https://developer.vuforia.com/license-manager.",
            "     *",
            "     * Vuforia license keys are always 380 characters long, and look as if they contain mostly",
            "     * random data. As an example, here is a example of a fragment of a valid key:",
            "     *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...",
            "     * Once you've obtained a license key, copy the string from the Vuforia web site",
            "     * and paste it in to your code on the next line, between the double quotes.",
            "     */",
            "    private static final String VUFORIA_KEY =",
            "            \" -- YOUR NEW VUFORIA KEY GOES HERE  --- \\\";",
            "",
            "    // Since ImageTarget trackables use mm to specifiy their dimensions, we must use mm for all the physical dimension.",
            "    // We will define some constants and conversions here",
            "    private static final float mmPerInch        = 25.4f;",
            "    private static final float mmTargetHeight   = (6) * mmPerInch;          // the height of the center of the target image above the floor",
            "",
            "    // Constants for perimeter targets",
            "    private static final float halfField = 72 * mmPerInch;",
            "    private static final float quadField  = 36 * mmPerInch;",
            "",
            "    // Class Members",
            "    private OpenGLMatrix lastLocation = null;",
            "    private VuforiaLocalizer vuforia = null;",
            "    private boolean targetVisible = false;",
            "    private float phoneXRotate    = 0;",
            "    private float phoneYRotate    = 0;",
            "    private float phoneZRotate    = 0;",
            "",
            "    @Override public void runOpMode() {",
            "        /*",
            "         * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine.",
            "         * We can pass Vuforia the handle to a camera preview resource (on the RC phone);",
            "         * If no camera monitor is desired, use the parameter-less constructor instead (commented out below).",
            "         */",
            "        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\\\"cameraMonitorViewId\\\", \\\"id\\\", hardwareMap.appContext.getPackageName());",
            "        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId);",
            "",
            "        // VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();",
            "",
            "        parameters.vuforiaLicenseKey = VUFORIA_KEY;",
            "        parameters.cameraDirection   = CAMERA_CHOICE;",
            "",
            "        // Make sure extended tracking is disabled for this example.",
            "        parameters.useExtendedTracking = false;",
            "",
            "        //  Instantiate the Vuforia engine",
            "        vuforia = ClassFactory.getInstance().createVuforia(parameters);",
            "",
            "        // Load the data sets for the trackable objects. These particular data",
            "        // sets are stored in the 'assets' part of our application.",
            "        VuforiaTrackables targetsUltimateGoal = this.vuforia.loadTrackablesFromAsset(\\\"UltimateGoal\\\");",
            "        VuforiaTrackable blueTowerGoalTarget = targetsUltimateGoal.get(0);",
            "        blueTowerGoalTarget.setName(\\\"Blue Tower Goal Target\\\");",
            "        VuforiaTrackable redTowerGoalTarget = targetsUltimateGoal.get(1);",
            "        redTowerGoalTarget.setName(\\\"Red Tower Goal Target\\\");",
            "        VuforiaTrackable redAllianceTarget = targetsUltimateGoal.get(2);",
            "        redAllianceTarget.setName(\\\"Red Alliance Target\\\");",
            "        VuforiaTrackable blueAllianceTarget = targetsUltimateGoal.get(3);",
            "        blueAllianceTarget.setName(\\\"Blue Alliance Target\\\");",
            "        VuforiaTrackable frontWallTarget = targetsUltimateGoal.get(4);",
            "        frontWallTarget.setName(\\\"Front Wall Target\\\");",
            "",
            "        // For convenience, gather together all the trackable objects in one easily-iterable collection */",
            "        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();",
            "        allTrackables.addAll(targetsUltimateGoal);",
            "",
            "        /**",
            "         * In order for localization to work, we need to tell the system where each target is on the field, and",
            "         * where the phone resides on the robot.  These specifications are in the form of <em>transformation matrices.</em>",
            "         * Transformation matrices are a central, important concept in the math here involved in localization.",
            "         * See <a href=\\\"https://en.wikipedia.org/wiki/Transformation_matrix\\\">Transformation Matrix</a>",
            "         * for detailed information. Commonly, you'll encounter transformation matrices as instances",
            "         * of the {@link OpenGLMatrix} class.",
            "         *",
            "         * If you are standing in the Red Alliance Station looking towards the center of the field,",
            "         *     - The X axis runs from your left to the right. (positive from the center to the right)",
            "         *     - The Y axis runs from the Red Alliance Station towards the other side of the field",
            "         *       where the Blue Alliance Station is. (Positive is from the center, towards the BlueAlliance station)",
            "         *     - The Z axis runs from the floor, upwards towards the ceiling.  (Positive is above the floor)",
            "         *",
            "         * Before being transformed, each target image is conceptually located at the origin of the field's",
            "         *  coordinate system (the center of the field), facing up.",
            "         */",
            "",
            "        //Set the position of the perimeter targets with relation to origin (center of field)",
            "        redAllianceTarget.setLocation(OpenGLMatrix",
            "                .translation(0, -halfField, mmTargetHeight)",
            "                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));",
            "",
            "        blueAllianceTarget.setLocation(OpenGLMatrix",
            "                .translation(0, halfField, mmTargetHeight)",
            "                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));",
            "        frontWallTarget.setLocation(OpenGLMatrix",
            "                .translation(-halfField, 0, mmTargetHeight)",
            "                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0 , 90)));",
            "",
            "        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.",
            "        blueTowerGoalTarget.setLocation(OpenGLMatrix",
            "                .translation(halfField, quadField, mmTargetHeight)",
            "                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0 , -90)));",
            "        redTowerGoalTarget.setLocation(OpenGLMatrix",
            "                .translation(halfField, -quadField, mmTargetHeight)",
            "                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));",
            "",
            "        //",
            "        // Create a transformation matrix describing where the phone is on the robot.",
            "        //",
            "        // NOTE !!!!  It's very important that you turn OFF your phone's Auto-Screen-Rotation option.",
            "        // Lock it into Portrait for these numbers to work.",
            "        //",
            "        // Info:  The coordinate frame for the robot looks the same as the field.",
            "        // The robot's \\\"forward\\\" direction is facing out along X axis, with the LEFT side facing out along the Y axis.",
            "        // Z is UP on the robot.  This equates to a bearing angle of Zero degrees.",
            "        //",
            "        // The phone starts out lying flat, with the screen facing Up and with the physical top of the phone",
            "        // pointing to the LEFT side of the Robot.",
            "        // The two examples below assume that the camera is facing forward out the front of the robot.",
            "",
            "        // We need to rotate the camera around it's long axis to bring the correct camera forward.",
            "        if (CAMERA_CHOICE == BACK) {",
            "            phoneYRotate = -90;",
            "        } else {",
            "            phoneYRotate = 90;",
            "        }",
            "",
            "        // Rotate the phone vertical about the X axis if it's in portrait mode",
            "        if (PHONE_IS_PORTRAIT) {",
            "            phoneXRotate = 90 ;",
            "        }",
            "",
            "        // Next, translate the camera lens to where it is on the robot.",
            "        // In this example, it is centered (left to right), but forward of the middle of the robot, and above ground level.",
            "        final float CAMERA_FORWARD_DISPLACEMENT  = 4.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot center",
            "        final float CAMERA_VERTICAL_DISPLACEMENT = 8.0f * mmPerInch;   // eg: Camera is 8 Inches above ground",
            "        final float CAMERA_LEFT_DISPLACEMENT     = 0;     // eg: Camera is ON the robot's center line",
            "",
            "        OpenGLMatrix robotFromCamera = OpenGLMatrix",
            "                    .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)",
            "                    .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));",
            "",
            "        /**  Let all the trackable listeners know where the phone is.  */",
            "        for (VuforiaTrackable trackable : allTrackables) {",
            "            ((VuforiaTrackableDefaultListener) trackable.getListener()).setPhoneInformation(robotFromCamera, parameters.cameraDirection);",
            "        }",
            "",
            "        // WARNING:",
            "        // In this sample, we do not wait for PLAY to be pressed.  Target Tracking is started immediately when INIT is pressed.",
            "        // This sequence is used to enable the new remote DS Camera Preview feature to be used with this sample.",
            "        // CONSEQUENTLY do not put any driving commands in this loop.",
            "        // To restore the normal opmode structure, just un-comment the following line:",
            "",
            "        // waitForStart();",
            "",
            "        // Note: To use the remote camera preview:",
            "        // AFTER you hit Init on the Driver Station, use the \\\"options menu\\\" to select \\\"Camera Stream\\\"",
            "        // Tap the preview window to receive a fresh image.",
            "",
            "        targetsUltimateGoal.activate();",
            "        while (!isStopRequested()) {",
            "",
            "            // check all the trackable targets to see which one (if any) is visible.",
            "            targetVisible = false;",
            "            for (VuforiaTrackable trackable : allTrackables) {",
            "                if (((VuforiaTrackableDefaultListener)trackable.getListener()).isVisible()) {",
            "                    telemetry.addData(\\\"Visible Target\\\", trackable.getName());",
            "                    targetVisible = true;",
            "",
            "                    // getUpdatedRobotLocation() will return null if no new information is available since",
            "                    // the last time that call was made, or if the trackable is not currently visible.",
            "                    OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener)trackable.getListener()).getUpdatedRobotLocation();",
            "                    if (robotLocationTransform != null) {",
            "                        lastLocation = robotLocationTransform;",
            "                    }",
            "                    break;",
            "                }",
            "            }",
            "",
            "            // Provide feedback as to where the robot is located (if we know).",
            "            if (targetVisible) {",
            "                // express position (translation) of robot in inches.",
            "                VectorF translation = lastLocation.getTranslation();",
            "                telemetry.addData(\\\"Pos (in)\\\", \\\"{X, Y, Z} = %.1f, %.1f, %.1f\\\",",
            "                        translation.get(0) / mmPerInch, translation.get(1) / mmPerInch, translation.get(2) / mmPerInch);",
            "",
            "                // express the rotation of the robot in degrees.",
            "                Orientation rotation = Orientation.getOrientation(lastLocation, EXTRINSIC, XYZ, DEGREES);",
            "                telemetry.addData(\\\"Rot (deg)\\\", \\\"{Roll, Pitch, Heading} = %.0f, %.0f, %.0f\\\", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);",
            "            }",
            "            else {",
            "                telemetry.addData(\\\"Visible Target\\\", \\\"none\\\");",
            "            }",
            "            telemetry.update();",
            "        }",
            "",
            "        // Disable Tracking when we are done;",
            "        targetsUltimateGoal.deactivate();",
            "    }",
            "}",
            ""
        ]
    },
    "PushbotTeleopPOV Linear": {
        "prefix": "pushbotTeleopPOVLinear",
        "description": "This OpMode uses the common Pushbot hardware class to define the devices on the robot.\nAll device access is managed through the HardwarePushbot class.\nThe code is structured as a LinearOpMode\n\nThis particular OpMode executes a POV Game style Teleop for a PushBot\nIn this mode the left stick moves the robot FWD and back, the Right stick turns left and right.\nIt raises and lowers the claw using the Gampad Y and A buttons respectively.\nIt also opens and closes the claws slowly using the left and right Bumper buttons.\n\n\n ",
        "body": [
            "public class PushbotTeleopPOV_Linear extends LinearOpMode {",
            "",
            "    /* Declare OpMode members. */",
            "    HardwarePushbot robot           = new HardwarePushbot();   // Use a Pushbot's hardware",
            "    double          clawOffset      = 0;                       // Servo mid position",
            "    final double    CLAW_SPEED      = 0.02 ;                   // sets rate to move servo",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "        double left;",
            "        double right;",
            "        double drive;",
            "        double turn;",
            "        double max;",
            "",
            "        /* Initialize the hardware variables.",
            "         * The init() method of the hardware class does all the work here",
            "         */",
            "        robot.init(hardwareMap);",
            "",
            "        // Send telemetry message to signify robot waiting;",
            "        telemetry.addData(\"Say\\\", \\\"Hello Driver\\\");    //",
            "        telemetry.update();",
            "",
            "        // Wait for the game to start (driver presses PLAY)",
            "        waitForStart();",
            "",
            "        // run until the end of the match (driver presses STOP)",
            "        while (opModeIsActive()) {",
            "",
            "            // Run wheels in POV mode (note: The joystick goes negative when pushed forwards, so negate it)",
            "            // In this mode the Left stick moves the robot fwd and back, the Right stick turns left and right.",
            "            // This way it's also easy to just drive straight, or just turn.",
            "            drive = -gamepad1.left_stick_y;",
            "            turn  =  gamepad1.right_stick_x;",
            "",
            "            // Combine drive and turn for blended motion.",
            "            left  = drive + turn;",
            "            right = drive - turn;",
            "",
            "            // Normalize the values so neither exceed +/- 1.0",
            "            max = Math.max(Math.abs(left), Math.abs(right));",
            "            if (max > 1.0)",
            "            {",
            "                left /= max;",
            "                right /= max;",
            "            }",
            "",
            "            // Output the safe vales to the motor drives.",
            "            robot.leftDrive.setPower(left);",
            "            robot.rightDrive.setPower(right);",
            "",
            "            // Use gamepad left & right Bumpers to open and close the claw",
            "            if (gamepad1.right_bumper)",
            "                clawOffset += CLAW_SPEED;",
            "            else if (gamepad1.left_bumper)",
            "                clawOffset -= CLAW_SPEED;",
            "",
            "            // Move both servos to new position.  Assume servos are mirror image of each other.",
            "            clawOffset = Range.clip(clawOffset, -0.5, 0.5);",
            "            robot.leftClaw.setPosition(robot.MID_SERVO + clawOffset);",
            "            robot.rightClaw.setPosition(robot.MID_SERVO - clawOffset);",
            "",
            "            // Use gamepad buttons to move arm up (Y) and down (A)",
            "            if (gamepad1.y)",
            "                robot.leftArm.setPower(robot.ARM_UP_POWER);",
            "            else if (gamepad1.a)",
            "                robot.leftArm.setPower(robot.ARM_DOWN_POWER);",
            "            else",
            "                robot.leftArm.setPower(0.0);",
            "",
            "            // Send telemetry message to signify robot running;",
            "            telemetry.addData(\\\"claw\\\",  \\\"Offset = %.2f\\\", clawOffset);",
            "            telemetry.addData(\\\"left\\\",  \\\"%.2f\\\", left);",
            "            telemetry.addData(\\\"right\\\", \\\"%.2f\\\", right);",
            "            telemetry.update();",
            "",
            "            // Pace this loop so jaw action is reasonable speed.",
            "            sleep(50);",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptVuforiaUltimateGoalNavigationWebcam": {
        "prefix": "conceptVuforiaUltimateGoalNavigationWebcam",
        "description": "        In order for localization to work, we need to tell the system where each target is on the field, and\n        where the phone resides on the robot.  These specifications are in the form of <em>transformation matrices.</em>\n        Transformation matrices are a central, important concept in the math here involved in localization.\n        See <a href=\"https://en.wikipedia.org/wiki/Transformation_matrix\">Transformation Matrix</a>\n        for detailed information. Commonly, you'll encounter transformation matrices as instances\n        of the {@link OpenGLMatrix} class.\n        \n        If you are standing in the Red Alliance Station looking towards the center of the field,\n            - The X axis runs from your left to the right. (positive from the center to the right)\n            - The Y axis runs from the Red Alliance Station towards the other side of the field\n              where the Blue Alliance Station is. (Positive is from the center, towards the BlueAlliance station)\n            - The Z axis runs from the floor, upwards towards the ceiling.  (Positive is above the floor)\n        \n        Before being transformed, each target image is conceptually located at the origin of the field's\n         coordinate system (the center of the field), facing up.\n         ",
        "body": [
            "public class ConceptVuforiaUltimateGoalNavigationWebcam extends LinearOpMode {",
            "",
            "    /*",
            "     * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which",
            "     * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.",
            "     * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer",
            "     * web site at https://developer.vuforia.com/license-manager.",
            "     *",
            "     * Vuforia license keys are always 380 characters long, and look as if they contain mostly",
            "     * random data. As an example, here is a example of a fragment of a valid key:",
            "     *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...",
            "     * Once you've obtained a license key, copy the string from the Vuforia web site",
            "     * and paste it in to your code on the next line, between the double quotes.",
            "     */",
            "    private static final String VUFORIA_KEY =",
            "            \" --- YOUR NEW VUFORIA KEY GOES HERE  --- \\\";",
            "",
            "    // Since ImageTarget trackables use mm to specifiy their dimensions, we must use mm for all the physical dimension.",
            "    // We will define some constants and conversions here",
            "    private static final float mmPerInch        = 25.4f;",
            "    private static final float mmTargetHeight   = (6) * mmPerInch;          // the height of the center of the target image above the floor",
            "",
            "    // Constants for perimeter targets",
            "    private static final float halfField = 72 * mmPerInch;",
            "    private static final float quadField  = 36 * mmPerInch;",
            "",
            "    // Class Members",
            "    private OpenGLMatrix lastLocation = null;",
            "    private VuforiaLocalizer vuforia = null;",
            "",
            "    /**",
            "     * This is the webcam we are to use. As with other hardware devices such as motors and",
            "     * servos, this device is identified using the robot configuration tool in the FTC application.",
            "     */",
            "    WebcamName webcamName = null;",
            "",
            "    private boolean targetVisible = false;",
            "    private float phoneXRotate    = 0;",
            "    private float phoneYRotate    = 0;",
            "    private float phoneZRotate    = 0;",
            "",
            "    @Override public void runOpMode() {",
            "        /*",
            "         * Retrieve the camera we are to use.",
            "         */",
            "        webcamName = hardwareMap.get(WebcamName.class, \\\"Webcam 1\\\");",
            "",
            "        /*",
            "         * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine.",
            "         * We can pass Vuforia the handle to a camera preview resource (on the RC screen);",
            "         * If no camera monitor is desired, use the parameter-less constructor instead (commented out below).",
            "         * Note: A preview window is required if you want to view the camera stream on the Driver Station Phone.",
            "         */",
            "        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\\\"cameraMonitorViewId\\\", \\\"id\\\", hardwareMap.appContext.getPackageName());",
            "        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId);",
            "",
            "        // VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();",
            "",
            "        parameters.vuforiaLicenseKey = VUFORIA_KEY;",
            "",
            "        /**",
            "         * We also indicate which camera on the RC we wish to use.",
            "         */",
            "        parameters.cameraName = webcamName;",
            "",
            "        // Make sure extended tracking is disabled for this example.",
            "        parameters.useExtendedTracking = false;",
            "",
            "        //  Instantiate the Vuforia engine",
            "        vuforia = ClassFactory.getInstance().createVuforia(parameters);",
            "",
            "        // Load the data sets for the trackable objects. These particular data",
            "        // sets are stored in the 'assets' part of our application.",
            "        VuforiaTrackables targetsUltimateGoal = this.vuforia.loadTrackablesFromAsset(\\\"UltimateGoal\\\");",
            "        VuforiaTrackable blueTowerGoalTarget = targetsUltimateGoal.get(0);",
            "        blueTowerGoalTarget.setName(\\\"Blue Tower Goal Target\\\");",
            "        VuforiaTrackable redTowerGoalTarget = targetsUltimateGoal.get(1);",
            "        redTowerGoalTarget.setName(\\\"Red Tower Goal Target\\\");",
            "        VuforiaTrackable redAllianceTarget = targetsUltimateGoal.get(2);",
            "        redAllianceTarget.setName(\\\"Red Alliance Target\\\");",
            "        VuforiaTrackable blueAllianceTarget = targetsUltimateGoal.get(3);",
            "        blueAllianceTarget.setName(\\\"Blue Alliance Target\\\");",
            "        VuforiaTrackable frontWallTarget = targetsUltimateGoal.get(4);",
            "        frontWallTarget.setName(\\\"Front Wall Target\\\");",
            "",
            "        // For convenience, gather together all the trackable objects in one easily-iterable collection */",
            "        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();",
            "        allTrackables.addAll(targetsUltimateGoal);",
            "",
            "        /**",
            "         * In order for localization to work, we need to tell the system where each target is on the field, and",
            "         * where the phone resides on the robot.  These specifications are in the form of <em>transformation matrices.</em>",
            "         * Transformation matrices are a central, important concept in the math here involved in localization.",
            "         * See <a href=\\\"https://en.wikipedia.org/wiki/Transformation_matrix\\\">Transformation Matrix</a>",
            "         * for detailed information. Commonly, you'll encounter transformation matrices as instances",
            "         * of the {@link OpenGLMatrix} class.",
            "         *",
            "         * If you are standing in the Red Alliance Station looking towards the center of the field,",
            "         *     - The X axis runs from your left to the right. (positive from the center to the right)",
            "         *     - The Y axis runs from the Red Alliance Station towards the other side of the field",
            "         *       where the Blue Alliance Station is. (Positive is from the center, towards the BlueAlliance station)",
            "         *     - The Z axis runs from the floor, upwards towards the ceiling.  (Positive is above the floor)",
            "         *",
            "         * Before being transformed, each target image is conceptually located at the origin of the field's",
            "         *  coordinate system (the center of the field), facing up.",
            "         */",
            "",
            "        //Set the position of the perimeter targets with relation to origin (center of field)",
            "        redAllianceTarget.setLocation(OpenGLMatrix",
            "                .translation(0, -halfField, mmTargetHeight)",
            "                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 180)));",
            "",
            "        blueAllianceTarget.setLocation(OpenGLMatrix",
            "                .translation(0, halfField, mmTargetHeight)",
            "                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 0)));",
            "        frontWallTarget.setLocation(OpenGLMatrix",
            "                .translation(-halfField, 0, mmTargetHeight)",
            "                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, 90)));",
            "",
            "        // The tower goal targets are located a quarter field length from the ends of the back perimeter wall.",
            "        blueTowerGoalTarget.setLocation(OpenGLMatrix",
            "                .translation(halfField, quadField, mmTargetHeight)",
            "                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));",
            "        redTowerGoalTarget.setLocation(OpenGLMatrix",
            "                .translation(halfField, -quadField, mmTargetHeight)",
            "                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, 90, 0, -90)));",
            "",
            "        //",
            "        // Create a transformation matrix describing where the phone is on the robot.",
            "        //",
            "        // Info:  The coordinate frame for the robot looks the same as the field.",
            "        // The robot's \\\"forward\\\" direction is facing out along X axis, with the LEFT side facing out along the Y axis.",
            "        // Z is UP on the robot.  This equates to a bearing angle of Zero degrees.",
            "        //",
            "        // For a WebCam, the default starting orientation of the camera is looking UP (pointing in the Z direction),",
            "        // with the wide (horizontal) axis of the camera aligned with the X axis, and",
            "        // the Narrow (vertical) axis of the camera aligned with the Y axis",
            "        //",
            "        // But, this example assumes that the camera is actually facing forward out the front of the robot.",
            "        // So, the \\\"default\\\" camera position requires two rotations to get it oriented correctly.",
            "        // 1) First it must be rotated +90 degrees around the X axis to get it horizontal (it's now facing out the right side of the robot)",
            "        // 2) Next it must be be rotated +90 degrees (counter-clockwise) around the Z axis to face forward.",
            "        //",
            "        // Finally the camera can be translated to its actual mounting position on the robot.",
            "        //      In this example, it is centered (left to right), but 4\\\" forward of the middle of the robot, and 8\\\" above ground level.",
            "",
            "        final float CAMERA_FORWARD_DISPLACEMENT  = 4.0f * mmPerInch;   // eg: Camera is 4 Inches in front of robot-center",
            "        final float CAMERA_VERTICAL_DISPLACEMENT = 8.0f * mmPerInch;   // eg: Camera is 8 Inches above ground",
            "        final float CAMERA_LEFT_DISPLACEMENT     = 0;     // eg: Camera is ON the robot's center line",
            "",
            "        OpenGLMatrix cameraLocationOnRobot = OpenGLMatrix",
            "                    .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)",
            "                    .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XZY, DEGREES, 90, 90, 0));",
            "",
            "        /**  Let all the trackable listeners know where the phone is.  */",
            "        for (VuforiaTrackable trackable : allTrackables) {",
            "            ((VuforiaTrackableDefaultListener) trackable.getListener()).setCameraLocationOnRobot(parameters.cameraName, cameraLocationOnRobot);",
            "        }",
            "",
            "        // WARNING:",
            "        // In this sample, we do not wait for PLAY to be pressed.  Target Tracking is started immediately when INIT is pressed.",
            "        // This sequence is used to enable the new remote DS Camera Preview feature to be used with this sample.",
            "        // CONSEQUENTLY do not put any driving commands in this loop.",
            "        // To restore the normal opmode structure, just un-comment the following line:",
            "",
            "        // waitForStart();",
            "",
            "        // Note: To use the remote camera preview:",
            "        // AFTER you hit Init on the Driver Station, use the \\\"options menu\\\" to select \\\"Camera Stream\\\"",
            "        // Tap the preview window to receive a fresh image.",
            "",
            "        targetsUltimateGoal.activate();",
            "        while (!isStopRequested()) {",
            "",
            "            // check all the trackable targets to see which one (if any) is visible.",
            "            targetVisible = false;",
            "            for (VuforiaTrackable trackable : allTrackables) {",
            "                if (((VuforiaTrackableDefaultListener)trackable.getListener()).isVisible()) {",
            "                    telemetry.addData(\\\"Visible Target\\\", trackable.getName());",
            "                    targetVisible = true;",
            "",
            "                    // getUpdatedRobotLocation() will return null if no new information is available since",
            "                    // the last time that call was made, or if the trackable is not currently visible.",
            "                    OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener)trackable.getListener()).getUpdatedRobotLocation();",
            "                    if (robotLocationTransform != null) {",
            "                        lastLocation = robotLocationTransform;",
            "                    }",
            "                    break;",
            "                }",
            "            }",
            "",
            "            // Provide feedback as to where the robot is located (if we know).",
            "            if (targetVisible) {",
            "                // express position (translation) of robot in inches.",
            "                VectorF translation = lastLocation.getTranslation();",
            "                telemetry.addData(\\\"Pos (in)\\\", \\\"{X, Y, Z} = %.1f, %.1f, %.1f\\\",",
            "                        translation.get(0) / mmPerInch, translation.get(1) / mmPerInch, translation.get(2) / mmPerInch);",
            "",
            "                // express the rotation of the robot in degrees.",
            "                Orientation rotation = Orientation.getOrientation(lastLocation, EXTRINSIC, XYZ, DEGREES);",
            "                telemetry.addData(\\\"Rot (deg)\\\", \\\"{Roll, Pitch, Heading} = %.0f, %.0f, %.0f\\\", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);",
            "            }",
            "            else {",
            "                telemetry.addData(\\\"Visible Target\\\", \\\"none\\\");",
            "            }",
            "            telemetry.update();",
            "        }",
            "",
            "        // Disable Tracking when we are done;",
            "        targetsUltimateGoal.deactivate();",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptWebcam": {
        "prefix": "conceptWebcam",
        "description": "This OpMode illustrates how to open a webcam and retrieve images from it. It requires a configuration\ncontaining a webcam with the default name (\"Webcam 1\"). When the opmode runs, pressing the 'A' button\nwill cause a frame from the camera to be written to a file on the device, which can then be retrieved\nby various means (e.g.: Device File Explorer in Android Studio; plugging the device into a PC and\nusing Media Transfer; ADB; etc)\n ",
        "body": [
            "public class ConceptWebcam extends LinearOpMode {",
            "",
            "    //----------------------------------------------------------------------------------------------",
            "    // State",
            "    //----------------------------------------------------------------------------------------------",
            "",
            "    private static final String TAG = \"Webcam Sample\\\";",
            "",
            "    /** How long we are to wait to be granted permission to use the camera before giving up. Here,",
            "     * we wait indefinitely */",
            "    private static final int secondsPermissionTimeout = Integer.MAX_VALUE;",
            "",
            "    /** State regarding our interaction with the camera */",
            "    private CameraManager cameraManager;",
            "    private WebcamName cameraName;",
            "    private Camera camera;",
            "    private CameraCaptureSession cameraCaptureSession;",
            "",
            "    /** The queue into which all frames from the camera are placed as they become available.",
            "     * Frames which are not processed by the OpMode are automatically discarded. */",
            "    private EvictingBlockingQueue<Bitmap> frameQueue;",
            "",
            "    /** State regarding where and how to save frames when the 'A' button is pressed. */",
            "    private int captureCounter = 0;",
            "    private File captureDirectory = AppUtil.ROBOT_DATA_DIR;",
            "",
            "    /** A utility object that indicates where the asynchronous callbacks from the camera",
            "     * infrastructure are to run. In this OpMode, that's all hidden from you (but see {@link #startCamera}",
            "     * if you're curious): no knowledge of multi-threading is needed here. */",
            "    private Handler callbackHandler;",
            "",
            "    //----------------------------------------------------------------------------------------------",
            "    // Main OpMode entry",
            "    //----------------------------------------------------------------------------------------------",
            "",
            "    @Override public void runOpMode() {",
            "",
            "        callbackHandler = CallbackLooper.getDefault().getHandler();",
            "",
            "        cameraManager = ClassFactory.getInstance().getCameraManager();",
            "        cameraName = hardwareMap.get(WebcamName.class, \\\"Webcam 1\\\");",
            "",
            "        initializeFrameQueue(2);",
            "        AppUtil.getInstance().ensureDirectoryExists(captureDirectory);",
            "",
            "        try {",
            "            openCamera();",
            "            if (camera == null) return;",
            "",
            "            startCamera();",
            "            if (cameraCaptureSession == null) return;",
            "",
            "            telemetry.addData(\\\">\\\", \\\"Press Play to start\\\");",
            "            telemetry.update();",
            "            waitForStart();",
            "            telemetry.clear();",
            "            telemetry.addData(\\\">\\\", \\\"Started...Press 'A' to capture frame\\\");",
            "",
            "            boolean buttonPressSeen = false;",
            "            boolean captureWhenAvailable = false;",
            "            while (opModeIsActive()) {",
            "",
            "                boolean buttonIsPressed = gamepad1.a;",
            "                if (buttonIsPressed && !buttonPressSeen) {",
            "                    captureWhenAvailable = true;",
            "                }",
            "                buttonPressSeen = buttonIsPressed;",
            "",
            "                if (captureWhenAvailable) {",
            "                    Bitmap bmp = frameQueue.poll();",
            "                    if (bmp != null) {",
            "                        captureWhenAvailable = false;",
            "                        onNewFrame(bmp);",
            "                    }",
            "                }",
            "",
            "                telemetry.update();",
            "            }",
            "        } finally {",
            "            closeCamera();",
            "        }",
            "    }",
            "",
            "    /** Do something with the frame */",
            "    private void onNewFrame(Bitmap frame) {",
            "        saveBitmap(frame);",
            "        frame.recycle(); // not strictly necessary, but helpful",
            "    }",
            "",
            "    //----------------------------------------------------------------------------------------------",
            "    // Camera operations",
            "    //----------------------------------------------------------------------------------------------",
            "",
            "    private void initializeFrameQueue(int capacity) {",
            "        /** The frame queue will automatically throw away bitmap frames if they are not processed",
            "         * quickly by the OpMode. This avoids a buildup of frames in memory */",
            "        frameQueue = new EvictingBlockingQueue<Bitmap>(new ArrayBlockingQueue<Bitmap>(capacity));",
            "        frameQueue.setEvictAction(new Consumer<Bitmap>() {",
            "            @Override public void accept(Bitmap frame) {",
            "                // RobotLog.ii(TAG, \\\"frame recycled w/o processing\\\");",
            "                frame.recycle(); // not strictly necessary, but helpful",
            "            }",
            "        });",
            "    }",
            "",
            "    private void openCamera() {",
            "        if (camera != null) return; // be idempotent",
            "",
            "        Deadline deadline = new Deadline(secondsPermissionTimeout, TimeUnit.SECONDS);",
            "        camera = cameraManager.requestPermissionAndOpenCamera(deadline, cameraName, null);",
            "        if (camera == null) {",
            "            error(\\\"camera not found or permission to use not granted: %s\\\", cameraName);",
            "        }",
            "    }",
            "",
            "    private void startCamera() {",
            "        if (cameraCaptureSession != null) return; // be idempotent",
            "",
            "        /** YUY2 is supported by all Webcams, per the USB Webcam standard: See \\\"USB Device Class Definition",
            "         * for Video Devices: Uncompressed Payload, Table 2-1\\\". Further, often this is the *only*",
            "         * image format supported by a camera */",
            "        final int imageFormat = ImageFormat.YUY2;",
            "",
            "        /** Verify that the image is supported, and fetch size and desired frame rate if so */",
            "        CameraCharacteristics cameraCharacteristics = cameraName.getCameraCharacteristics();",
            "        if (!contains(cameraCharacteristics.getAndroidFormats(), imageFormat)) {",
            "            error(\\\"image format not supported\\\");",
            "            return;",
            "        }",
            "        final Size size = cameraCharacteristics.getDefaultSize(imageFormat);",
            "        final int fps = cameraCharacteristics.getMaxFramesPerSecond(imageFormat, size);",
            "",
            "        /** Some of the logic below runs asynchronously on other threads. Use of the synchronizer",
            "         * here allows us to wait in this method until all that asynchrony completes before returning. */",
            "        final ContinuationSynchronizer<CameraCaptureSession> synchronizer = new ContinuationSynchronizer<>();",
            "        try {",
            "            /** Create a session in which requests to capture frames can be made */",
            "            camera.createCaptureSession(Continuation.create(callbackHandler, new CameraCaptureSession.StateCallbackDefault() {",
            "                @Override public void onConfigured(@NonNull CameraCaptureSession session) {",
            "                    try {",
            "                        /** The session is ready to go. Start requesting frames */",
            "                        final CameraCaptureRequest captureRequest = camera.createCaptureRequest(imageFormat, size, fps);",
            "                        session.startCapture(captureRequest,",
            "                            new CameraCaptureSession.CaptureCallback() {",
            "                                @Override public void onNewFrame(@NonNull CameraCaptureSession session, @NonNull CameraCaptureRequest request, @NonNull CameraFrame cameraFrame) {",
            "                                    /** A new frame is available. The frame data has <em>not</em> been copied for us, and we can only access it",
            "                                     * for the duration of the callback. So we copy here manually. */",
            "                                    Bitmap bmp = captureRequest.createEmptyBitmap();",
            "                                    cameraFrame.copyToBitmap(bmp);",
            "                                    frameQueue.offer(bmp);",
            "                                }",
            "                            },",
            "                            Continuation.create(callbackHandler, new CameraCaptureSession.StatusCallback() {",
            "                                @Override public void onCaptureSequenceCompleted(@NonNull CameraCaptureSession session, CameraCaptureSequenceId cameraCaptureSequenceId, long lastFrameNumber) {",
            "                                    RobotLog.ii(TAG, \\\"capture sequence %s reports completed: lastFrame=%d\\\", cameraCaptureSequenceId, lastFrameNumber);",
            "                                }",
            "                            })",
            "                        );",
            "                        synchronizer.finish(session);",
            "                    } catch (CameraException|RuntimeException e) {",
            "                        RobotLog.ee(TAG, e, \\\"exception starting capture\\\");",
            "                        error(\\\"exception starting capture\\\");",
            "                        session.close();",
            "                        synchronizer.finish(null);",
            "                    }",
            "                }",
            "            }));",
            "        } catch (CameraException|RuntimeException e) {",
            "            RobotLog.ee(TAG, e, \\\"exception starting camera\\\");",
            "            error(\\\"exception starting camera\\\");",
            "            synchronizer.finish(null);",
            "        }",
            "",
            "        /** Wait for all the asynchrony to complete */",
            "        try {",
            "            synchronizer.await();",
            "        } catch (InterruptedException e) {",
            "            Thread.currentThread().interrupt();",
            "        }",
            "",
            "        /** Retrieve the created session. This will be null on error. */",
            "        cameraCaptureSession = synchronizer.getValue();",
            "    }",
            "",
            "    private void stopCamera() {",
            "        if (cameraCaptureSession != null) {",
            "            cameraCaptureSession.stopCapture();",
            "            cameraCaptureSession.close();",
            "            cameraCaptureSession = null;",
            "        }",
            "    }",
            "",
            "    private void closeCamera() {",
            "        stopCamera();",
            "        if (camera != null) {",
            "            camera.close();",
            "            camera = null;",
            "        }",
            "    }",
            "",
            "    //----------------------------------------------------------------------------------------------",
            "    // Utilities",
            "    //----------------------------------------------------------------------------------------------",
            "",
            "    private void error(String msg) {",
            "        telemetry.log().add(msg);",
            "        telemetry.update();",
            "    }",
            "    private void error(String format, Object...args) {",
            "        telemetry.log().add(format, args);",
            "        telemetry.update();",
            "    }",
            "",
            "    private boolean contains(int[] array, int value) {",
            "        for (int i : array) {",
            "            if (i == value) return true;",
            "        }",
            "        return false;",
            "    }",
            "",
            "    private void saveBitmap(Bitmap bitmap) {",
            "        File file = new File(captureDirectory, String.format(Locale.getDefault(), \\\"webcam-frame-%d.jpg\\\", captureCounter++));",
            "        try {",
            "            try (FileOutputStream outputStream = new FileOutputStream(file)) {",
            "                bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream);",
            "                telemetry.log().add(\\\"captured %s\\\", file.getName());",
            "            }",
            "        } catch (IOException e) {",
            "            RobotLog.ee(TAG, e, \\\"exception in saveBitmap()\\\");",
            "            error(\\\"exception saving %s\\\", file.getName());",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptTensorFlowObjectDetection": {
        "prefix": "conceptTensorFlowObjectDetection",
        "description": "    Initialize the TensorFlow Object Detection engine.\n     ",
        "body": [
            "public class ConceptTensorFlowObjectDetection extends LinearOpMode {",
            "",
            "    /*",
            "     * Specify the source for the Tensor Flow Model.",
            "     * If the TensorFlowLite object model is included in the Robot Controller App as an \"asset\\\",",
            "     * the OpMode must to load it using loadModelFromAsset().  However, if a team generated model",
            "     * has been downloaded to the Robot Controller's SD FLASH memory, it must to be loaded using loadModelFromFile()",
            "     * Here we assume it's an Asset.    Also see method initTfod() below .",
            "     */",
            "    private static final String TFOD_MODEL_ASSET = \\\"PowerPlay.tflite\\\";",
            "    // private static final String TFOD_MODEL_FILE  = \\\"/sdcard/FIRST/tflitemodels/CustomTeamModel.tflite\\\";",
            "",
            "    private static final String[] LABELS = {",
            "      \\\"1 Bolt\\\",",
            "      \\\"2 Bulb\\\",",
            "      \\\"3 Panel\\\"",
            "    };",
            "",
            "    /*",
            "     * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which",
            "     * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.",
            "     * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer",
            "     * web site at https://developer.vuforia.com/license-manager.",
            "     *",
            "     * Vuforia license keys are always 380 characters long, and look as if they contain mostly",
            "     * random data. As an example, here is a example of a fragment of a valid key:",
            "     *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...",
            "     * Once you've obtained a license key, copy the string from the Vuforia web site",
            "     * and paste it in to your code on the next line, between the double quotes.",
            "     */",
            "    private static final String VUFORIA_KEY =",
            "            \\\" -- YOUR NEW VUFORIA KEY GOES HERE  --- \\\";",
            "",
            "    /**",
            "     * {@link #vuforia} is the variable we will use to store our instance of the Vuforia",
            "     * localization engine.",
            "     */",
            "    private VuforiaLocalizer vuforia;",
            "",
            "    /**",
            "     * {@link #tfod} is the variable we will use to store our instance of the TensorFlow Object",
            "     * Detection engine.",
            "     */",
            "    private TFObjectDetector tfod;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "        // The TFObjectDetector uses the camera frames from the VuforiaLocalizer, so we create that",
            "        // first.",
            "        initVuforia();",
            "        initTfod();",
            "",
            "        /**",
            "         * Activate TensorFlow Object Detection before we wait for the start command.",
            "         * Do it here so that the Camera Stream window will have the TensorFlow annotations visible.",
            "         **/",
            "        if (tfod != null) {",
            "            tfod.activate();",
            "",
            "            // The TensorFlow software will scale the input images from the camera to a lower resolution.",
            "            // This can result in lower detection accuracy at longer distances (> 55cm or 22\\\").",
            "            // If your target is at distance greater than 50 cm (20\\\") you can increase the magnification value",
            "            // to artificially zoom in to the center of image.  For best results, the \\\"aspectRatio\\\" argument",
            "            // should be set to the value of the images used to create the TensorFlow Object Detection model",
            "            // (typically 16/9).",
            "            tfod.setZoom(1.0, 16.0/9.0);",
            "        }",
            "",
            "        /** Wait for the game to begin */",
            "        telemetry.addData(\\\">\\\", \\\"Press Play to start op mode\\\");",
            "        telemetry.update();",
            "        waitForStart();",
            "",
            "        if (opModeIsActive()) {",
            "            while (opModeIsActive()) {",
            "                if (tfod != null) {",
            "                    // getUpdatedRecognitions() will return null if no new information is available since",
            "                    // the last time that call was made.",
            "                    List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();",
            "                    if (updatedRecognitions != null) {",
            "                        telemetry.addData(\\\"# Objects Detected\\\", updatedRecognitions.size());",
            "",
            "                        // step through the list of recognitions and display image position/size information for each one",
            "                        // Note: \\\"Image number\\\" refers to the randomized image orientation/number",
            "                        for (Recognition recognition : updatedRecognitions) {",
            "                            double col = (recognition.getLeft() + recognition.getRight()) / 2 ;",
            "                            double row = (recognition.getTop()  + recognition.getBottom()) / 2 ;",
            "                            double width  = Math.abs(recognition.getRight() - recognition.getLeft()) ;",
            "                            double height = Math.abs(recognition.getTop()  - recognition.getBottom()) ;",
            "",
            "                            telemetry.addData(\\\"\\\",\\\" \\\");",
            "                            telemetry.addData(\\\"Image\\\", \\\"%s (%.0f %% Conf.)\\\", recognition.getLabel(), recognition.getConfidence() * 100 );",
            "                            telemetry.addData(\\\"- Position (Row/Col)\\\",\\\"%.0f / %.0f\\\", row, col);",
            "                            telemetry.addData(\\\"- Size (Width/Height)\\\",\\\"%.0f / %.0f\\\", width, height);",
            "                        }",
            "                        telemetry.update();",
            "                    }",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    /**",
            "     * Initialize the Vuforia localization engine.",
            "     */",
            "    private void initVuforia() {",
            "        /*",
            "         * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine.",
            "         */",
            "        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();",
            "",
            "        parameters.vuforiaLicenseKey = VUFORIA_KEY;",
            "        parameters.cameraDirection = CameraDirection.BACK;",
            "",
            "        //  Instantiate the Vuforia engine",
            "        vuforia = ClassFactory.getInstance().createVuforia(parameters);",
            "    }",
            "",
            "    /**",
            "     * Initialize the TensorFlow Object Detection engine.",
            "     */",
            "    private void initTfod() {",
            "        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(",
            "            \\\"tfodMonitorViewId\\\", \\\"id\\\", hardwareMap.appContext.getPackageName());",
            "        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);",
            "        tfodParameters.minResultConfidence = 0.75f;",
            "        tfodParameters.isModelTensorFlow2 = true;",
            "        tfodParameters.inputSize = 300;",
            "        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);",
            "",
            "        // Use loadModelFromAsset() if the TF Model is built in as an asset by Android Studio",
            "        // Use loadModelFromFile() if you have downloaded a custom team model to the Robot Controller's FLASH.",
            "        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABELS);",
            "        // tfod.loadModelFromFile(TFOD_MODEL_FILE, LABELS);",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptTelemetry": {
        "prefix": "conceptTelemetry",
        "description": "            Transmit the telemetry to the driver station, subject to throttling.\n            @see Telemetry#getMsTransmissionInterval()\n             ",
        "body": [
            "public class ConceptTelemetry extends LinearOpMode  {",
            "    /** keeps track of the line of the poem which is to be emitted next */",
            "    int poemLine = 0;",
            "",
            "    /** keeps track of how long it's been since we last emitted a line of poetry */",
            "    ElapsedTime poemElapsed = new ElapsedTime();",
            "",
            "    static final String[] poem = new String[] {",
            "",
            "        \"Mary had a little lamb,\\\",",
            "        \\\"His fleece was white as snow,\\\",",
            "        \\\"And everywhere that Mary went,\\\",",
            "        \\\"The lamb was sure to go.\\\",",
            "        \\\"\\\",",
            "        \\\"He followed her to school one day,\\\",",
            "        \\\"Which was against the rule,\\\",",
            "        \\\"It made the children laugh and play\\\",",
            "        \\\"To see a lamb at school.\\\",",
            "        \\\"\\\",",
            "        \\\"And so the teacher turned it out,\\\",",
            "        \\\"But still it lingered near,\\\",",
            "        \\\"And waited patiently about,\\\",",
            "        \\\"Till Mary did appear.\\\",",
            "        \\\"\\\",",
            "        \\\"\\\\\"Why does the lamb love Mary so?\\\\\"\\\",",
            "        \\\"The eager children cry.\\\",",
            "        \\\"\\\\\"Why, Mary loves the lamb, you know,\\\\\"\\\",",
            "        \\\"The teacher did reply.\\\",",
            "        \\\"\\\",",
            "        \\\"\\\"",
            "    };",
            "",
            "    @Override public void runOpMode() {",
            "",
            "        /* we keep track of how long it's been since the OpMode was started, just",
            "         * to have some interesting data to show */",
            "        ElapsedTime opmodeRunTime = new ElapsedTime();",
            "",
            "        // We show the log in oldest-to-newest order, as that's better for poetry",
            "        telemetry.log().setDisplayOrder(Telemetry.Log.DisplayOrder.OLDEST_FIRST);",
            "        // We can control the number of lines shown in the log",
            "        telemetry.log().setCapacity(6);",
            "        // The interval between lines of poetry, in seconds",
            "        double sPoemInterval = 0.6;",
            "",
            "        /**",
            "         * Wait until we've been given the ok to go. For something to do, we emit the",
            "         * elapsed time as we sit here and wait. If we didn't want to do anything while",
            "         * we waited, we would just call {@link #waitForStart()}.",
            "         */",
            "        while (!isStarted()) {",
            "            telemetry.addData(\\\"time\\\", \\\"%.1f seconds\\\", opmodeRunTime.seconds());",
            "            telemetry.update();",
            "            idle();",
            "        }",
            "",
            "        // Ok, we've been given the ok to go",
            "",
            "        /**",
            "         * As an illustration, the first line on our telemetry display will display the battery voltage.",
            "         * The idea here is that it's expensive to compute the voltage (at least for purposes of illustration)",
            "         * so you don't want to do it unless the data is <em>actually</em> going to make it to the",
            "         * driver station (recall that telemetry transmission is throttled to reduce bandwidth use.",
            "         * Note that getBatteryVoltage() below returns 'Infinity' if there's no voltage sensor attached.",
            "         *",
            "         * @see Telemetry#getMsTransmissionInterval()",
            "         */",
            "        telemetry.addData(\\\"voltage\\\", \\\"%.1f volts\\\", new Func<Double>() {",
            "            @Override public Double value() {",
            "                return getBatteryVoltage();",
            "            }",
            "            });",
            "",
            "        // Reset to keep some timing stats for the post-'start' part of the opmode",
            "        opmodeRunTime.reset();",
            "        int loopCount = 1;",
            "",
            "        // Go go gadget robot!",
            "        while (opModeIsActive()) {",
            "",
            "            // Emit poetry if it's been a while",
            "            if (poemElapsed.seconds() > sPoemInterval) {",
            "                emitPoemLine();",
            "            }",
            "",
            "            // As an illustration, show some loop timing information",
            "            telemetry.addData(\\\"loop count\\\", loopCount);",
            "            telemetry.addData(\\\"ms/loop\\\", \\\"%.3f ms\\\", opmodeRunTime.milliseconds() / loopCount);",
            "",
            "            // Show joystick information as some other illustrative data",
            "            telemetry.addLine(\\\"left joystick | \\\")",
            "                    .addData(\\\"x\\\", gamepad1.left_stick_x)",
            "                    .addData(\\\"y\\\", gamepad1.left_stick_y);",
            "            telemetry.addLine(\\\"right joystick | \\\")",
            "                    .addData(\\\"x\\\", gamepad1.right_stick_x)",
            "                    .addData(\\\"y\\\", gamepad1.right_stick_y);",
            "",
            "            /**",
            "             * Transmit the telemetry to the driver station, subject to throttling.",
            "             * @see Telemetry#getMsTransmissionInterval()",
            "             */",
            "            telemetry.update();",
            "",
            "            /** Update loop info and play nice with the rest of the {@link Thread}s in the system */",
            "            loopCount++;",
            "        }",
            "    }",
            "",
            "    // emits a line of poetry to the telemetry log",
            "    void emitPoemLine() {",
            "        telemetry.log().add(poem[poemLine]);",
            "        poemLine = (poemLine+1) % poem.length;",
            "        poemElapsed.reset();",
            "    }",
            "",
            "    // Computes the current battery voltage",
            "    double getBatteryVoltage() {",
            "        double result = Double.POSITIVE_INFINITY;",
            "        for (VoltageSensor sensor : hardwareMap.voltageSensor) {",
            "            double voltage = sensor.getVoltage();",
            "            if (voltage > 0) {",
            "                result = Math.min(result, voltage);",
            "            }",
            "        }",
            "        return result;",
            "    }",
            "}",
            ""
        ]
    },
    "PushbotAutoDriveByEncoder Linear": {
        "prefix": "pushbotAutoDriveByEncoderLinear",
        "description": "This file illustrates the concept of driving a path based on encoder counts.\nIt uses the common Pushbot hardware class to define the drive on the robot.\nThe code is structured as a LinearOpMode\n\nThe code REQUIRES that you DO have encoders on the wheels,\n  otherwise you would use: PushbotAutoDriveByTime;\n\n This code ALSO requires that the drive Motors have been configured such that a positive\n power command moves them forwards, and causes the encoders to count UP.\n\n  The desired path in this example is:\n  - Drive forward for 48 inches\n  - Spin right for 12 Inches\n  - Drive Backwards for 24 inches\n  - Stop and close the claw.\n\n The code is written using a method called: encoderDrive(speed, leftInches, rightInches, timeoutS)\n that performs the actual movement.\n This methods assumes that each movement is relative to the last stopping place.\n There are other ways to perform encoder based moves, but this method is probably the simplest.\n This code uses the RUN_TO_POSITION mode to enable the Motor controllers to generate the run profile\n\n\n ",
        "body": [
            "public class PushbotAutoDriveByEncoder_Linear extends LinearOpMode {",
            "",
            "    /* Declare OpMode members. */",
            "    HardwarePushbot         robot   = new HardwarePushbot();   // Use a Pushbot's hardware",
            "    private ElapsedTime     runtime = new ElapsedTime();",
            "",
            "    static final double     COUNTS_PER_MOTOR_REV    = 1440 ;    // eg: TETRIX Motor Encoder",
            "    static final double     DRIVE_GEAR_REDUCTION    = 2.0 ;     // This is < 1.0 if geared UP",
            "    static final double     WHEEL_DIAMETER_INCHES   = 4.0 ;     // For figuring circumference",
            "    static final double     COUNTS_PER_INCH         = (COUNTS_PER_MOTOR_REV * DRIVE_GEAR_REDUCTION) /",
            "                                                      (WHEEL_DIAMETER_INCHES * 3.1415);",
            "    static final double     DRIVE_SPEED             = 0.6;",
            "    static final double     TURN_SPEED              = 0.5;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        /*",
            "         * Initialize the drive system variables.",
            "         * The init() method of the hardware class does all the work here",
            "         */",
            "        robot.init(hardwareMap);",
            "",
            "        // Send telemetry message to signify robot waiting;",
            "        telemetry.addData(\"Status\\\", \\\"Resetting Encoders\\\");    //",
            "        telemetry.update();",
            "",
            "        robot.leftDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);",
            "        robot.rightDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);",
            "",
            "        robot.leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "        robot.rightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "",
            "        // Send telemetry message to indicate successful Encoder reset",
            "        telemetry.addData(\\\"Path0\\\",  \\\"Starting at %7d :%7d\\\",",
            "                          robot.leftDrive.getCurrentPosition(),",
            "                          robot.rightDrive.getCurrentPosition());",
            "        telemetry.update();",
            "",
            "        // Wait for the game to start (driver presses PLAY)",
            "        waitForStart();",
            "",
            "        // Step through each leg of the path,",
            "        // Note: Reverse movement is obtained by setting a negative distance (not speed)",
            "        encoderDrive(DRIVE_SPEED,  48,  48, 5.0);  // S1: Forward 47 Inches with 5 Sec timeout",
            "        encoderDrive(TURN_SPEED,   12, -12, 4.0);  // S2: Turn Right 12 Inches with 4 Sec timeout",
            "        encoderDrive(DRIVE_SPEED, -24, -24, 4.0);  // S3: Reverse 24 Inches with 4 Sec timeout",
            "",
            "        robot.leftClaw.setPosition(1.0);            // S4: Stop and close the claw.",
            "        robot.rightClaw.setPosition(0.0);",
            "        sleep(1000);     // pause for servos to move",
            "",
            "        telemetry.addData(\\\"Path\\\", \\\"Complete\\\");",
            "        telemetry.update();",
            "    }",
            "",
            "    /*",
            "     *  Method to perform a relative move, based on encoder counts.",
            "     *  Encoders are not reset as the move is based on the current position.",
            "     *  Move will stop if any of three conditions occur:",
            "     *  1) Move gets to the desired position",
            "     *  2) Move runs out of time",
            "     *  3) Driver stops the opmode running.",
            "     */",
            "    public void encoderDrive(double speed,",
            "                             double leftInches, double rightInches,",
            "                             double timeoutS) {",
            "        int newLeftTarget;",
            "        int newRightTarget;",
            "",
            "        // Ensure that the opmode is still active",
            "        if (opModeIsActive()) {",
            "",
            "            // Determine new target position, and pass to motor controller",
            "            newLeftTarget = robot.leftDrive.getCurrentPosition() + (int)(leftInches * COUNTS_PER_INCH);",
            "            newRightTarget = robot.rightDrive.getCurrentPosition() + (int)(rightInches * COUNTS_PER_INCH);",
            "            robot.leftDrive.setTargetPosition(newLeftTarget);",
            "            robot.rightDrive.setTargetPosition(newRightTarget);",
            "",
            "            // Turn On RUN_TO_POSITION",
            "            robot.leftDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);",
            "            robot.rightDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);",
            "",
            "            // reset the timeout time and start motion.",
            "            runtime.reset();",
            "            robot.leftDrive.setPower(Math.abs(speed));",
            "            robot.rightDrive.setPower(Math.abs(speed));",
            "",
            "            // keep looping while we are still active, and there is time left, and both motors are running.",
            "            // Note: We use (isBusy() && isBusy()) in the loop test, which means that when EITHER motor hits",
            "            // its target position, the motion will stop.  This is \\\"safer\\\" in the event that the robot will",
            "            // always end the motion as soon as possible.",
            "            // However, if you require that BOTH motors have finished their moves before the robot continues",
            "            // onto the next step, use (isBusy() || isBusy()) in the loop test.",
            "            while (opModeIsActive() &&",
            "                   (runtime.seconds() < timeoutS) &&",
            "                   (robot.leftDrive.isBusy() && robot.rightDrive.isBusy())) {",
            "",
            "                // Display it for the driver.",
            "                telemetry.addData(\\\"Path1\\\",  \\\"Running to %7d :%7d\\\", newLeftTarget,  newRightTarget);",
            "                telemetry.addData(\\\"Path2\\\",  \\\"Running at %7d :%7d\\\",",
            "                                            robot.leftDrive.getCurrentPosition(),",
            "                                            robot.rightDrive.getCurrentPosition());",
            "                telemetry.update();",
            "            }",
            "",
            "            // Stop all motion;",
            "            robot.leftDrive.setPower(0);",
            "            robot.rightDrive.setPower(0);",
            "",
            "            // Turn off RUN_TO_POSITION",
            "            robot.leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "            robot.rightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "",
            "            //  sleep(250);   // optional pause after each move",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "SensorMRRangeSensor": {
        "prefix": "sensorMRRangeSensor",
        "description": "{@link SensorMRRangeSensor} illustrates how to use the Modern Robotics\nRange Sensor.\n\nThe op mode assumes that the range sensor is configured with a name of \"sensor_range\".\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list\n\n@see <a href=\"http://modernroboticsinc.com/range-sensor\">MR Range Sensor</a>\n ",
        "body": [
            "public class SensorMRRangeSensor extends LinearOpMode {",
            "",
            "    ModernRoboticsI2cRangeSensor rangeSensor;",
            "",
            "    @Override public void runOpMode() {",
            "",
            "        // get a reference to our compass",
            "        rangeSensor = hardwareMap.get(ModernRoboticsI2cRangeSensor.class, \"sensor_range\\\");",
            "",
            "        // wait for the start button to be pressed",
            "        waitForStart();",
            "",
            "        while (opModeIsActive()) {",
            "            telemetry.addData(\\\"raw ultrasonic\\\", rangeSensor.rawUltrasonic());",
            "            telemetry.addData(\\\"raw optical\\\", rangeSensor.rawOptical());",
            "            telemetry.addData(\\\"cm optical\\\", \\\"%.2f cm\\\", rangeSensor.cmOptical());",
            "            telemetry.addData(\\\"cm\\\", \\\"%.2f cm\\\", rangeSensor.getDistance(DistanceUnit.CM));",
            "            telemetry.update();",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "PushbotAutoDriveByTime Linear": {
        "prefix": "pushbotAutoDriveByTimeLinear",
        "description": "This file illustrates the concept of driving a path based on time.\nIt uses the common Pushbot hardware class to define the drive on the robot.\nThe code is structured as a LinearOpMode\n\nThe code assumes that you do NOT have encoders on the wheels,\n  otherwise you would use: PushbotAutoDriveByEncoder;\n\n  The desired path in this example is:\n  - Drive forward for 3 seconds\n  - Spin right for 1.3 seconds\n  - Drive Backwards for 1 Second\n  - Stop and close the claw.\n\n The code is written in a simple form with no optimizations.\n However, there are several ways that this type of sequence could be streamlined,\n\n\n ",
        "body": [
            "public class PushbotAutoDriveByTime_Linear extends LinearOpMode {",
            "",
            "    /* Declare OpMode members. */",
            "    HardwarePushbot         robot   = new HardwarePushbot();   // Use a Pushbot's hardware",
            "    private ElapsedTime     runtime = new ElapsedTime();",
            "",
            "",
            "    static final double     FORWARD_SPEED = 0.6;",
            "    static final double     TURN_SPEED    = 0.5;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        /*",
            "         * Initialize the drive system variables.",
            "         * The init() method of the hardware class does all the work here",
            "         */",
            "        robot.init(hardwareMap);",
            "",
            "        // Send telemetry message to signify robot waiting;",
            "        telemetry.addData(\"Status\\\", \\\"Ready to run\\\");    //",
            "        telemetry.update();",
            "",
            "        // Wait for the game to start (driver presses PLAY)",
            "        waitForStart();",
            "",
            "        // Step through each leg of the path, ensuring that the Auto mode has not been stopped along the way",
            "",
            "        // Step 1:  Drive forward for 3 seconds",
            "        robot.leftDrive.setPower(FORWARD_SPEED);",
            "        robot.rightDrive.setPower(FORWARD_SPEED);",
            "        runtime.reset();",
            "        while (opModeIsActive() && (runtime.seconds() < 3.0)) {",
            "            telemetry.addData(\\\"Path\\\", \\\"Leg 1: %2.5f S Elapsed\\\", runtime.seconds());",
            "            telemetry.update();",
            "        }",
            "",
            "        // Step 2:  Spin right for 1.3 seconds",
            "        robot.leftDrive.setPower(TURN_SPEED);",
            "        robot.rightDrive.setPower(-TURN_SPEED);",
            "        runtime.reset();",
            "        while (opModeIsActive() && (runtime.seconds() < 1.3)) {",
            "            telemetry.addData(\\\"Path\\\", \\\"Leg 2: %2.5f S Elapsed\\\", runtime.seconds());",
            "            telemetry.update();",
            "        }",
            "",
            "        // Step 3:  Drive Backwards for 1 Second",
            "        robot.leftDrive.setPower(-FORWARD_SPEED);",
            "        robot.rightDrive.setPower(-FORWARD_SPEED);",
            "        runtime.reset();",
            "        while (opModeIsActive() && (runtime.seconds() < 1.0)) {",
            "            telemetry.addData(\\\"Path\\\", \\\"Leg 3: %2.5f S Elapsed\\\", runtime.seconds());",
            "            telemetry.update();",
            "        }",
            "",
            "        // Step 4:  Stop and close the claw.",
            "        robot.leftDrive.setPower(0);",
            "        robot.rightDrive.setPower(0);",
            "        robot.leftClaw.setPosition(1.0);",
            "        robot.rightClaw.setPosition(0.0);",
            "",
            "        telemetry.addData(\\\"Path\\\", \\\"Complete\\\");",
            "        telemetry.update();",
            "        sleep(1000);",
            "    }",
            "}",
            ""
        ]
    },
    "SensorDigitalTouch": {
        "prefix": "sensorDigitalTouch",
        "description": "    The REV Robotics Touch Sensor\n    is treated as a digital channel.  It is HIGH if the button is unpressed.\n    It pulls LOW if the button is pressed.\n    \n    Also, when you connect a REV Robotics Touch Sensor to the digital I/O port on the\n    Expansion Hub using a 4-wire JST cable, the second pin gets connected to the Touch Sensor.\n    The lower (first) pin stays unconnected.*\n     ",
        "body": [
            "public class SensorDigitalTouch extends LinearOpMode {",
            "    /**",
            "     * The REV Robotics Touch Sensor",
            "     * is treated as a digital channel.  It is HIGH if the button is unpressed.",
            "     * It pulls LOW if the button is pressed.",
            "     *",
            "     * Also, when you connect a REV Robotics Touch Sensor to the digital I/O port on the",
            "     * Expansion Hub using a 4-wire JST cable, the second pin gets connected to the Touch Sensor.",
            "     * The lower (first) pin stays unconnected.*",
            "     */",
            "",
            "    DigitalChannel digitalTouch;  // Hardware Device Object",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        // get a reference to our digitalTouch object.",
            "        digitalTouch = hardwareMap.get(DigitalChannel.class, \"sensor_digital\\\");",
            "",
            "        // set the digital channel to input.",
            "        digitalTouch.setMode(DigitalChannel.Mode.INPUT);",
            "",
            "        // wait for the start button to be pressed.",
            "        waitForStart();",
            "",
            "        // while the op mode is active, loop and read the light levels.",
            "        // Note we use opModeIsActive() as our loop condition because it is an interruptible method.",
            "        while (opModeIsActive()) {",
            "",
            "            // send the info back to driver station using telemetry function.",
            "            // if the digital channel returns true it's HIGH and the button is unpressed.",
            "            if (digitalTouch.getState() == true) {",
            "                telemetry.addData(\\\"Digital Touch\\\", \\\"Is Not Pressed\\\");",
            "            } else {",
            "                telemetry.addData(\\\"Digital Touch\\\", \\\"Is Pressed\\\");",
            "            }",
            "",
            "            telemetry.update();",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "HardwarePushbot": {
        "prefix": "hardwarePushbot",
        "description": "This is NOT an opmode.\n\nThis class can be used to define all the specific hardware for a single robot.\nIn this case that robot is a Pushbot.\nSee PushbotTeleopTank_Iterative and others classes starting with \"Pushbot\" for usage examples.\n\nThis hardware class assumes the following device names have been configured on the robot:\nNote:  All names are lower case and some have single spaces between words.\n\nMotor channel:  Left  drive motor:        \"left_drive\"\nMotor channel:  Right drive motor:        \"right_drive\"\nMotor channel:  Manipulator drive motor:  \"left_arm\"\nServo channel:  Servo to open left claw:  \"left_hand\"\nServo channel:  Servo to open right claw: \"right_hand\"\n ",
        "body": [
            "public class HardwarePushbot",
            "{",
            "    /* Public OpMode members. */",
            "    public DcMotor  leftDrive   = null;",
            "    public DcMotor  rightDrive  = null;",
            "    public DcMotor  leftArm     = null;",
            "    public Servo    leftClaw    = null;",
            "    public Servo    rightClaw   = null;",
            "",
            "    public static final double MID_SERVO       =  0.5 ;",
            "    public static final double ARM_UP_POWER    =  0.45 ;",
            "    public static final double ARM_DOWN_POWER  = -0.45 ;",
            "",
            "    /* local OpMode members. */",
            "    HardwareMap hwMap           =  null;",
            "    private ElapsedTime period  = new ElapsedTime();",
            "",
            "    /* Constructor */",
            "    public HardwarePushbot(){",
            "",
            "    }",
            "",
            "    /* Initialize standard Hardware interfaces */",
            "    public void init(HardwareMap ahwMap) {",
            "        // Save reference to Hardware map",
            "        hwMap = ahwMap;",
            "",
            "        // Define and Initialize Motors",
            "        leftDrive  = hwMap.get(DcMotor.class, \"left_drive\\\");",
            "        rightDrive = hwMap.get(DcMotor.class, \\\"right_drive\\\");",
            "        leftArm    = hwMap.get(DcMotor.class, \\\"left_arm\\\");",
            "        leftDrive.setDirection(DcMotor.Direction.FORWARD); // Set to REVERSE if using AndyMark motors",
            "        rightDrive.setDirection(DcMotor.Direction.REVERSE);// Set to FORWARD if using AndyMark motors",
            "",
            "        // Set all motors to zero power",
            "        leftDrive.setPower(0);",
            "        rightDrive.setPower(0);",
            "        leftArm.setPower(0);",
            "",
            "        // Set all motors to run without encoders.",
            "        // May want to use RUN_USING_ENCODERS if encoders are installed.",
            "        leftDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);",
            "        rightDrive.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);",
            "        leftArm.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);",
            "",
            "        // Define and initialize ALL installed servos.",
            "        leftClaw  = hwMap.get(Servo.class, \\\"left_hand\\\");",
            "        rightClaw = hwMap.get(Servo.class, \\\"right_hand\\\");",
            "        leftClaw.setPosition(MID_SERVO);",
            "        rightClaw.setPosition(MID_SERVO);",
            "    }",
            " }",
            "",
            ""
        ]
    },
    "SensorMRColor": {
        "prefix": "sensorMRColor",
        "description": "No Description Given",
        "body": [
            "public class SensorMRColor extends LinearOpMode {",
            "",
            "  ColorSensor colorSensor;    // Hardware Device Object",
            "",
            "",
            "  @Override",
            "  public void runOpMode() {",
            "",
            "    // hsvValues is an array that will hold the hue, saturation, and value information.",
            "    float hsvValues[] = {0F,0F,0F};",
            "",
            "    // values is a reference to the hsvValues array.",
            "    final float values[] = hsvValues;",
            "",
            "    // get a reference to the RelativeLayout so we can change the background",
            "    // color of the Robot Controller app to match the hue detected by the RGB sensor.",
            "    int relativeLayoutId = hardwareMap.appContext.getResources().getIdentifier(\"RelativeLayout\\\", \\\"id\\\", hardwareMap.appContext.getPackageName());",
            "    final View relativeLayout = ((Activity) hardwareMap.appContext).findViewById(relativeLayoutId);",
            "",
            "    // bPrevState and bCurrState represent the previous and current state of the button.",
            "    boolean bPrevState = false;",
            "    boolean bCurrState = false;",
            "",
            "    // bLedOn represents the state of the LED.",
            "    boolean bLedOn = true;",
            "",
            "    // get a reference to our ColorSensor object.",
            "    colorSensor = hardwareMap.get(ColorSensor.class, \\\"sensor_color\\\");",
            "",
            "    // Set the LED in the beginning",
            "    colorSensor.enableLed(bLedOn);",
            "",
            "    // wait for the start button to be pressed.",
            "    waitForStart();",
            "",
            "    // while the op mode is active, loop and read the RGB data.",
            "    // Note we use opModeIsActive() as our loop condition because it is an interruptible method.",
            "    while (opModeIsActive()) {",
            "",
            "      // check the status of the x button on either gamepad.",
            "      bCurrState = gamepad1.x;",
            "",
            "      // check for button state transitions.",
            "      if (bCurrState && (bCurrState != bPrevState))  {",
            "",
            "        // button is transitioning to a pressed state. So Toggle LED",
            "        bLedOn = !bLedOn;",
            "        colorSensor.enableLed(bLedOn);",
            "      }",
            "",
            "      // update previous state variable.",
            "      bPrevState = bCurrState;",
            "",
            "      // convert the RGB values to HSV values.",
            "      Color.RGBToHSV(colorSensor.red() * 8, colorSensor.green() * 8, colorSensor.blue() * 8, hsvValues);",
            "",
            "      // send the info back to driver station using telemetry function.",
            "      telemetry.addData(\\\"LED\\\", bLedOn ? \\\"On\\\" : \\\"Off\\\");",
            "      telemetry.addData(\\\"Clear\\\", colorSensor.alpha());",
            "      telemetry.addData(\\\"Red  \\\", colorSensor.red());",
            "      telemetry.addData(\\\"Green\\\", colorSensor.green());",
            "      telemetry.addData(\\\"Blue \\\", colorSensor.blue());",
            "      telemetry.addData(\\\"Hue\\\", hsvValues[0]);",
            "",
            "      // change the background color to match the color detected by the RGB sensor.",
            "      // pass a reference to the hue, saturation, and value array as an argument",
            "      // to the HSVToColor method.",
            "      relativeLayout.post(new Runnable() {",
            "        public void run() {",
            "          relativeLayout.setBackgroundColor(Color.HSVToColor(0xff, values));",
            "        }",
            "      });",
            "",
            "      telemetry.update();",
            "    }",
            "",
            "    // Set the panel back to the default color",
            "    relativeLayout.post(new Runnable() {",
            "      public void run() {",
            "        relativeLayout.setBackgroundColor(Color.WHITE);",
            "      }",
            "    });",
            "  }",
            "}",
            ""
        ]
    },
    "SensorAdafruitRGB": {
        "prefix": "sensorAdafruitRGB",
        "description": "No Description Given",
        "body": [
            "public class SensorAdafruitRGB extends LinearOpMode {",
            "",
            "  ColorSensor sensorRGB;",
            "  DeviceInterfaceModule cdim;",
            "",
            "  // we assume that the LED pin of the RGB sensor is connected to",
            "  // digital port 5 (zero indexed).",
            "  static final int LED_CHANNEL = 5;",
            "",
            "  @Override",
            "  public void runOpMode() {",
            "",
            "    // hsvValues is an array that will hold the hue, saturation, and value information.",
            "    float hsvValues[] = {0F,0F,0F};",
            "",
            "    // values is a reference to the hsvValues array.",
            "    final float values[] = hsvValues;",
            "",
            "    // get a reference to the RelativeLayout so we can change the background",
            "    // color of the Robot Controller app to match the hue detected by the RGB sensor.",
            "    int relativeLayoutId = hardwareMap.appContext.getResources().getIdentifier(\"RelativeLayout\\\", \\\"id\\\", hardwareMap.appContext.getPackageName());",
            "    final View relativeLayout = ((Activity) hardwareMap.appContext).findViewById(relativeLayoutId);",
            "",
            "    // bPrevState and bCurrState represent the previous and current state of the button.",
            "    boolean bPrevState = false;",
            "    boolean bCurrState = false;",
            "",
            "    // bLedOn represents the state of the LED.",
            "    boolean bLedOn = true;",
            "",
            "    // get a reference to our DeviceInterfaceModule object.",
            "    cdim = hardwareMap.deviceInterfaceModule.get(\\\"dim\\\");",
            "",
            "    // set the digital channel to output mode.",
            "    // remember, the Adafruit sensor is actually two devices.",
            "    // It's an I2C sensor and it's also an LED that can be turned on or off.",
            "    cdim.setDigitalChannelMode(LED_CHANNEL, DigitalChannel.Mode.OUTPUT);",
            "",
            "    // get a reference to our ColorSensor object.",
            "    sensorRGB = hardwareMap.colorSensor.get(\\\"sensor_color\\\");",
            "",
            "    // turn the LED on in the beginning, just so user will know that the sensor is active.",
            "    cdim.setDigitalChannelState(LED_CHANNEL, bLedOn);",
            "",
            "    // wait for the start button to be pressed.",
            "    waitForStart();",
            "",
            "    // loop and read the RGB data.",
            "    // Note we use opModeIsActive() as our loop condition because it is an interruptible method.",
            "    while (opModeIsActive())  {",
            "",
            "      // check the status of the x button on gamepad.",
            "      bCurrState = gamepad1.x;",
            "",
            "      // check for button-press state transitions.",
            "      if ((bCurrState == true) && (bCurrState != bPrevState))  {",
            "",
            "        // button is transitioning to a pressed state. Toggle the LED.",
            "        bLedOn = !bLedOn;",
            "        cdim.setDigitalChannelState(LED_CHANNEL, bLedOn);",
            "      }",
            "",
            "      // update previous state variable.",
            "      bPrevState = bCurrState;",
            "",
            "      // convert the RGB values to HSV values.",
            "      Color.RGBToHSV((sensorRGB.red() * 255) / 800, (sensorRGB.green() * 255) / 800, (sensorRGB.blue() * 255) / 800, hsvValues);",
            "",
            "      // send the info back to driver station using telemetry function.",
            "      telemetry.addData(\\\"LED\\\", bLedOn ? \\\"On\\\" : \\\"Off\\\");",
            "      telemetry.addData(\\\"Clear\\\", sensorRGB.alpha());",
            "      telemetry.addData(\\\"Red  \\\", sensorRGB.red());",
            "      telemetry.addData(\\\"Green\\\", sensorRGB.green());",
            "      telemetry.addData(\\\"Blue \\\", sensorRGB.blue());",
            "      telemetry.addData(\\\"Hue\\\", hsvValues[0]);",
            "",
            "      // change the background color to match the color detected by the RGB sensor.",
            "      // pass a reference to the hue, saturation, and value array as an argument",
            "      // to the HSVToColor method.",
            "      relativeLayout.post(new Runnable() {",
            "        public void run() {",
            "          relativeLayout.setBackgroundColor(Color.HSVToColor(0xff, values));",
            "        }",
            "      });",
            "",
            "      telemetry.update();",
            "    }",
            "",
            "    // Set the panel back to the default color",
            "    relativeLayout.post(new Runnable() {",
            "      public void run() {",
            "        relativeLayout.setBackgroundColor(Color.WHITE);",
            "      }",
            "    });",
            "  }",
            "}",
            ""
        ]
    },
    "SensorMRCompass": {
        "prefix": "sensorMRCompass",
        "description": "The {@link SensorMRCompass} op mode provides a demonstration of the\nfunctionality provided by the Modern Robotics compass sensor.\n\nThe op mode assumes that the MR compass is configured with a name of \"compass\".\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list\n\n@see <a href=\"http://www.modernroboticsinc.com/compass\">MR Compass Sensor</a>\n ",
        "body": [
            "public class SensorMRCompass extends LinearOpMode {",
            "",
            "    ModernRoboticsI2cCompassSensor compass;",
            "    ElapsedTime                    timer = new ElapsedTime();",
            "",
            "    @Override public void runOpMode() {",
            "",
            "        // get a reference to our compass",
            "        compass = hardwareMap.get(ModernRoboticsI2cCompassSensor.class, \"compass\\\");",
            "",
            "        telemetry.log().setCapacity(20);",
            "        telemetry.log().add(\\\"The compass sensor operates quite well out-of-the\\\");",
            "        telemetry.log().add(\\\"box, as shipped by the manufacturer. Precision can\\\");",
            "        telemetry.log().add(\\\"however be somewhat improved with calibration.\\\");",
            "        telemetry.log().add(\\\"\\\");",
            "        telemetry.log().add(\\\"To calibrate the compass once the opmode is\\\");",
            "        telemetry.log().add(\\\"started, make sure the compass is level, then\\\");",
            "        telemetry.log().add(\\\"press 'A' on the gamepad. Next, slowly rotate the \\\");",
            "        telemetry.log().add(\\\"compass in a full 360 degree circle while keeping\\\");",
            "        telemetry.log().add(\\\"it level. When complete, press 'B'.\\\");",
            "",
            "        // wait for the start button to be pressed",
            "        waitForStart();",
            "        telemetry.log().clear();",
            "",
            "        while (opModeIsActive()) {",
            "",
            "            // If the A button is pressed, start calibration and wait for the A button to rise",
            "            if (gamepad1.a && !compass.isCalibrating()) {",
            "",
            "                telemetry.log().clear();",
            "                telemetry.log().add(\\\"Calibration started\\\");",
            "                telemetry.log().add(\\\"Slowly rotate compass 360deg\\\");",
            "                telemetry.log().add(\\\"Press 'B' when complete\\\");",
            "                compass.setMode(CompassSensor.CompassMode.CALIBRATION_MODE);",
            "                timer.reset();",
            "",
            "                while (gamepad1.a && opModeIsActive()) {",
            "                    doTelemetry();",
            "                    idle();",
            "                }",
            "            }",
            "",
            "            // If the B button is pressed, stop calibration and wait for the B button to rise",
            "            if (gamepad1.b && compass.isCalibrating()) {",
            "",
            "                telemetry.log().clear();",
            "                telemetry.log().add(\\\"Calibration complete\\\");",
            "                compass.setMode(CompassSensor.CompassMode.MEASUREMENT_MODE);",
            "",
            "                if (compass.calibrationFailed()) {",
            "                    telemetry.log().add(\\\"Calibration failed\\\");",
            "                    compass.writeCommand(ModernRoboticsI2cCompassSensor.Command.NORMAL);",
            "                }",
            "",
            "                while (gamepad1.a && opModeIsActive()) {",
            "                    doTelemetry();",
            "                    idle();",
            "                }",
            "            }",
            "",
            "            doTelemetry();",
            "        }",
            "    }",
            "",
            "    protected void doTelemetry() {",
            "",
            "        if (compass.isCalibrating()) {",
            "",
            "            telemetry.addData(\\\"compass\\\", \\\"calibrating %s\\\", Math.round(timer.seconds())%2==0 ? \\\"|..\\\" : \\\"..|\\\");",
            "",
            "        } else {",
            "",
            "            // getDirection() returns a traditional compass heading in the range [0,360),",
            "            // with values increasing in a CW direction",
            "            telemetry.addData(\\\"heading\\\", \\\"%.1f\\\", compass.getDirection());",
            "",
            "            // getAcceleration() returns the current 3D acceleration experienced by",
            "            // the sensor. This is used internally to the sensor to compute its tilt and thence",
            "            // to correct the magnetometer reading to produce tilt-corrected values in getDirection()",
            "            Acceleration accel = compass.getAcceleration();",
            "            double accelMagnitude = Math.sqrt(accel.xAccel*accel.xAccel + accel.yAccel*accel.yAccel + accel.zAccel*accel.zAccel);",
            "            telemetry.addData(\\\"accel\\\", accel);",
            "            telemetry.addData(\\\"accel magnitude\\\", \\\"%.3f\\\", accelMagnitude);",
            "",
            "            // getMagneticFlux returns the 3D magnetic field flux experienced by the sensor",
            "            telemetry.addData(\\\"mag flux\\\", compass.getMagneticFlux());",
            "        }",
            "",
            "        // the command register provides status data",
            "        telemetry.addData(\\\"command\\\", \\\"%s\\\", compass.readCommand());",
            "",
            "        telemetry.update();",
            "    }",
            "}",
            ""
        ]
    },
    "PushbotAutoDriveByGyro Linear": {
        "prefix": "pushbotAutoDriveByGyroLinear",
        "description": "    returns desired steering force.  +/- 1 range.  +ve = steer left\n    @param error   Error angle in robot relative degrees\n    @param PCoeff  Proportional Gain Coefficient\n    @return\n     ",
        "body": [
            "public class PushbotAutoDriveByGyro_Linear extends LinearOpMode {",
            "",
            "    /* Declare OpMode members. */",
            "    HardwarePushbot         robot   = new HardwarePushbot();   // Use a Pushbot's hardware",
            "    ModernRoboticsI2cGyro   gyro    = null;                    // Additional Gyro device",
            "",
            "    static final double     COUNTS_PER_MOTOR_REV    = 1440 ;    // eg: TETRIX Motor Encoder",
            "    static final double     DRIVE_GEAR_REDUCTION    = 2.0 ;     // This is < 1.0 if geared UP",
            "    static final double     WHEEL_DIAMETER_INCHES   = 4.0 ;     // For figuring circumference",
            "    static final double     COUNTS_PER_INCH         = (COUNTS_PER_MOTOR_REV * DRIVE_GEAR_REDUCTION) /",
            "                                                      (WHEEL_DIAMETER_INCHES * 3.1415);",
            "",
            "    // These constants define the desired driving/control characteristics",
            "    // The can/should be tweaked to suite the specific robot drive train.",
            "    static final double     DRIVE_SPEED             = 0.7;     // Nominal speed for better accuracy.",
            "    static final double     TURN_SPEED              = 0.5;     // Nominal half speed for better accuracy.",
            "",
            "    static final double     HEADING_THRESHOLD       = 1 ;      // As tight as we can make it with an integer gyro",
            "    static final double     P_TURN_COEFF            = 0.1;     // Larger is more responsive, but also less stable",
            "    static final double     P_DRIVE_COEFF           = 0.15;     // Larger is more responsive, but also less stable",
            "",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        /*",
            "         * Initialize the standard drive system variables.",
            "         * The init() method of the hardware class does most of the work here",
            "         */",
            "        robot.init(hardwareMap);",
            "        gyro = (ModernRoboticsI2cGyro)hardwareMap.gyroSensor.get(\"gyro\\\");",
            "",
            "        // Ensure the robot it stationary, then reset the encoders and calibrate the gyro.",
            "        robot.leftDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);",
            "        robot.rightDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);",
            "",
            "        // Send telemetry message to alert driver that we are calibrating;",
            "        telemetry.addData(\\\">\\\", \\\"Calibrating Gyro\\\");    //",
            "        telemetry.update();",
            "",
            "        gyro.calibrate();",
            "",
            "        // make sure the gyro is calibrated before continuing",
            "        while (!isStopRequested() && gyro.isCalibrating())  {",
            "            sleep(50);",
            "            idle();",
            "        }",
            "",
            "        telemetry.addData(\\\">\\\", \\\"Robot Ready.\\\");    //",
            "        telemetry.update();",
            "",
            "        robot.leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "        robot.rightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "",
            "        // Wait for the game to start (Display Gyro value), and reset gyro before we move..",
            "        while (!isStarted()) {",
            "            telemetry.addData(\\\">\\\", \\\"Robot Heading = %d\\\", gyro.getIntegratedZValue());",
            "            telemetry.update();",
            "        }",
            "",
            "        gyro.resetZAxisIntegrator();",
            "",
            "        // Step through each leg of the path,",
            "        // Note: Reverse movement is obtained by setting a negative distance (not speed)",
            "        // Put a hold after each turn",
            "        gyroDrive(DRIVE_SPEED, 48.0, 0.0);    // Drive FWD 48 inches",
            "        gyroTurn( TURN_SPEED, -45.0);         // Turn  CCW to -45 Degrees",
            "        gyroHold( TURN_SPEED, -45.0, 0.5);    // Hold -45 Deg heading for a 1/2 second",
            "        gyroDrive(DRIVE_SPEED, 12.0, -45.0);  // Drive FWD 12 inches at 45 degrees",
            "        gyroTurn( TURN_SPEED,  45.0);         // Turn  CW  to  45 Degrees",
            "        gyroHold( TURN_SPEED,  45.0, 0.5);    // Hold  45 Deg heading for a 1/2 second",
            "        gyroTurn( TURN_SPEED,   0.0);         // Turn  CW  to   0 Degrees",
            "        gyroHold( TURN_SPEED,   0.0, 1.0);    // Hold  0 Deg heading for a 1 second",
            "        gyroDrive(DRIVE_SPEED,-48.0, 0.0);    // Drive REV 48 inches",
            "",
            "        telemetry.addData(\\\"Path\\\", \\\"Complete\\\");",
            "        telemetry.update();",
            "    }",
            "",
            "",
            "   /**",
            "    *  Method to drive on a fixed compass bearing (angle), based on encoder counts.",
            "    *  Move will stop if either of these conditions occur:",
            "    *  1) Move gets to the desired position",
            "    *  2) Driver stops the opmode running.",
            "    *",
            "    * @param speed      Target speed for forward motion.  Should allow for _/- variance for adjusting heading",
            "    * @param distance   Distance (in inches) to move from current position.  Negative distance means move backwards.",
            "    * @param angle      Absolute Angle (in Degrees) relative to last gyro reset.",
            "    *                   0 = fwd. +ve is CCW from fwd. -ve is CW from forward.",
            "    *                   If a relative angle is required, add/subtract from current heading.",
            "    */",
            "    public void gyroDrive ( double speed,",
            "                            double distance,",
            "                            double angle) {",
            "",
            "        int     newLeftTarget;",
            "        int     newRightTarget;",
            "        int     moveCounts;",
            "        double  max;",
            "        double  error;",
            "        double  steer;",
            "        double  leftSpeed;",
            "        double  rightSpeed;",
            "",
            "        // Ensure that the opmode is still active",
            "        if (opModeIsActive()) {",
            "",
            "            // Determine new target position, and pass to motor controller",
            "            moveCounts = (int)(distance * COUNTS_PER_INCH);",
            "            newLeftTarget = robot.leftDrive.getCurrentPosition() + moveCounts;",
            "            newRightTarget = robot.rightDrive.getCurrentPosition() + moveCounts;",
            "",
            "            // Set Target and Turn On RUN_TO_POSITION",
            "            robot.leftDrive.setTargetPosition(newLeftTarget);",
            "            robot.rightDrive.setTargetPosition(newRightTarget);",
            "",
            "            robot.leftDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);",
            "            robot.rightDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);",
            "",
            "            // start motion.",
            "            speed = Range.clip(Math.abs(speed), 0.0, 1.0);",
            "            robot.leftDrive.setPower(speed);",
            "            robot.rightDrive.setPower(speed);",
            "",
            "            // keep looping while we are still active, and BOTH motors are running.",
            "            while (opModeIsActive() &&",
            "                   (robot.leftDrive.isBusy() && robot.rightDrive.isBusy())) {",
            "",
            "                // adjust relative speed based on heading error.",
            "                error = getError(angle);",
            "                steer = getSteer(error, P_DRIVE_COEFF);",
            "",
            "                // if driving in reverse, the motor correction also needs to be reversed",
            "                if (distance < 0)",
            "                    steer *= -1.0;",
            "",
            "                leftSpeed = speed - steer;",
            "                rightSpeed = speed + steer;",
            "",
            "                // Normalize speeds if either one exceeds +/- 1.0;",
            "                max = Math.max(Math.abs(leftSpeed), Math.abs(rightSpeed));",
            "                if (max > 1.0)",
            "                {",
            "                    leftSpeed /= max;",
            "                    rightSpeed /= max;",
            "                }",
            "",
            "                robot.leftDrive.setPower(leftSpeed);",
            "                robot.rightDrive.setPower(rightSpeed);",
            "",
            "                // Display drive status for the driver.",
            "                telemetry.addData(\\\"Err/St\\\",  \\\"%5.1f/%5.1f\\\",  error, steer);",
            "                telemetry.addData(\\\"Target\\\",  \\\"%7d:%7d\\\",      newLeftTarget,  newRightTarget);",
            "                telemetry.addData(\\\"Actual\\\",  \\\"%7d:%7d\\\",      robot.leftDrive.getCurrentPosition(),",
            "                                                             robot.rightDrive.getCurrentPosition());",
            "                telemetry.addData(\\\"Speed\\\",   \\\"%5.2f:%5.2f\\\",  leftSpeed, rightSpeed);",
            "                telemetry.update();",
            "            }",
            "",
            "            // Stop all motion;",
            "            robot.leftDrive.setPower(0);",
            "            robot.rightDrive.setPower(0);",
            "",
            "            // Turn off RUN_TO_POSITION",
            "            robot.leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "            robot.rightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "        }",
            "    }",
            "",
            "    /**",
            "     *  Method to spin on central axis to point in a new direction.",
            "     *  Move will stop if either of these conditions occur:",
            "     *  1) Move gets to the heading (angle)",
            "     *  2) Driver stops the opmode running.",
            "     *",
            "     * @param speed Desired speed of turn.",
            "     * @param angle      Absolute Angle (in Degrees) relative to last gyro reset.",
            "     *                   0 = fwd. +ve is CCW from fwd. -ve is CW from forward.",
            "     *                   If a relative angle is required, add/subtract from current heading.",
            "     */",
            "    public void gyroTurn (  double speed, double angle) {",
            "",
            "        // keep looping while we are still active, and not on heading.",
            "        while (opModeIsActive() && !onHeading(speed, angle, P_TURN_COEFF)) {",
            "            // Update telemetry & Allow time for other processes to run.",
            "            telemetry.update();",
            "        }",
            "    }",
            "",
            "    /**",
            "     *  Method to obtain & hold a heading for a finite amount of time",
            "     *  Move will stop once the requested time has elapsed",
            "     *",
            "     * @param speed      Desired speed of turn.",
            "     * @param angle      Absolute Angle (in Degrees) relative to last gyro reset.",
            "     *                   0 = fwd. +ve is CCW from fwd. -ve is CW from forward.",
            "     *                   If a relative angle is required, add/subtract from current heading.",
            "     * @param holdTime   Length of time (in seconds) to hold the specified heading.",
            "     */",
            "    public void gyroHold( double speed, double angle, double holdTime) {",
            "",
            "        ElapsedTime holdTimer = new ElapsedTime();",
            "",
            "        // keep looping while we have time remaining.",
            "        holdTimer.reset();",
            "        while (opModeIsActive() && (holdTimer.time() < holdTime)) {",
            "            // Update telemetry & Allow time for other processes to run.",
            "            onHeading(speed, angle, P_TURN_COEFF);",
            "            telemetry.update();",
            "        }",
            "",
            "        // Stop all motion;",
            "        robot.leftDrive.setPower(0);",
            "        robot.rightDrive.setPower(0);",
            "    }",
            "",
            "    /**",
            "     * Perform one cycle of closed loop heading control.",
            "     *",
            "     * @param speed     Desired speed of turn.",
            "     * @param angle     Absolute Angle (in Degrees) relative to last gyro reset.",
            "     *                  0 = fwd. +ve is CCW from fwd. -ve is CW from forward.",
            "     *                  If a relative angle is required, add/subtract from current heading.",
            "     * @param PCoeff    Proportional Gain coefficient",
            "     * @return",
            "     */",
            "    boolean onHeading(double speed, double angle, double PCoeff) {",
            "        double   error ;",
            "        double   steer ;",
            "        boolean  onTarget = false ;",
            "        double leftSpeed;",
            "        double rightSpeed;",
            "",
            "        // determine turn power based on +/- error",
            "        error = getError(angle);",
            "",
            "        if (Math.abs(error) <= HEADING_THRESHOLD) {",
            "            steer = 0.0;",
            "            leftSpeed  = 0.0;",
            "            rightSpeed = 0.0;",
            "            onTarget = true;",
            "        }",
            "        else {",
            "            steer = getSteer(error, PCoeff);",
            "            rightSpeed  = speed * steer;",
            "            leftSpeed   = -rightSpeed;",
            "        }",
            "",
            "        // Send desired speeds to motors.",
            "        robot.leftDrive.setPower(leftSpeed);",
            "        robot.rightDrive.setPower(rightSpeed);",
            "",
            "        // Display it for the driver.",
            "        telemetry.addData(\\\"Target\\\", \\\"%5.2f\\\", angle);",
            "        telemetry.addData(\\\"Err/St\\\", \\\"%5.2f/%5.2f\\\", error, steer);",
            "        telemetry.addData(\\\"Speed.\\\", \\\"%5.2f:%5.2f\\\", leftSpeed, rightSpeed);",
            "",
            "        return onTarget;",
            "    }",
            "",
            "    /**",
            "     * getError determines the error between the target angle and the robot's current heading",
            "     * @param   targetAngle  Desired angle (relative to global reference established at last Gyro Reset).",
            "     * @return  error angle: Degrees in the range +/- 180. Centered on the robot's frame of reference",
            "     *          +ve error means the robot should turn LEFT (CCW) to reduce error.",
            "     */",
            "    public double getError(double targetAngle) {",
            "",
            "        double robotError;",
            "",
            "        // calculate error in -179 to +180 range  (",
            "        robotError = targetAngle - gyro.getIntegratedZValue();",
            "        while (robotError > 180)  robotError -= 360;",
            "        while (robotError <= -180) robotError += 360;",
            "        return robotError;",
            "    }",
            "",
            "    /**",
            "     * returns desired steering force.  +/- 1 range.  +ve = steer left",
            "     * @param error   Error angle in robot relative degrees",
            "     * @param PCoeff  Proportional Gain Coefficient",
            "     * @return",
            "     */",
            "    public double getSteer(double error, double PCoeff) {",
            "        return Range.clip(error * PCoeff, -1, 1);",
            "    }",
            "",
            "}",
            ""
        ]
    },
    "ConceptNullOp": {
        "prefix": "conceptNullOp",
        "description": "Demonstrates empty OpMode\n ",
        "body": [
            "public class ConceptNullOp extends OpMode {",
            "",
            "  private ElapsedTime runtime = new ElapsedTime();",
            "",
            "  @Override",
            "  public void init() {",
            "    telemetry.addData(\"Status\\\", \\\"Initialized\\\");",
            "  }",
            "",
            "  /*",
            "     * Code to run when the op mode is first enabled goes here",
            "     * @see com.qualcomm.robotcore.eventloop.opmode.OpMode#start()",
            "     */",
            "  @Override",
            "  public void init_loop() {",
            "  }",
            "",
            "  /*",
            "   * This method will be called ONCE when start is pressed",
            "   * @see com.qualcomm.robotcore.eventloop.opmode.OpMode#loop()",
            "   */",
            "  @Override",
            "  public void start() {",
            "    runtime.reset();",
            "  }",
            "",
            "  /*",
            "   * This method will be called repeatedly in a loop",
            "   * @see com.qualcomm.robotcore.eventloop.opmode.OpMode#loop()",
            "   */",
            "  @Override",
            "  public void loop() {",
            "    telemetry.addData(\\\"Status\\\", \\\"Run Time: \\\" + runtime.toString());",
            "  }",
            "}",
            ""
        ]
    },
    "ConceptDIMAsIndicator": {
        "prefix": "conceptDIMAsIndicator",
        "description": "This OpMode illustrates using the Device Interface Module as a signalling device.\nThe code is structured as a LinearOpMode\n\nThis code assumes a DIM name \"dim\".\n\nThere are many examples where the robot might like to signal the driver, without requiring them\nto look at the driver station.  This might be something like a \"ball in hopper\" condition or a\n\"ready to shoot\" condition.\n\nThe DIM has two user settable indicator LEDs (one red one blue).  These can be controlled\ndirectly from your program.\n\n\n ",
        "body": [
            "public class ConceptDIMAsIndicator extends LinearOpMode {",
            "",
            "    static final int    BLUE_LED    = 0;     // Blue LED channel on DIM",
            "    static final int    RED_LED     = 1;     // Red LED Channel on DIM",
            "",
            "    // Create timer to toggle LEDs",
            "    private ElapsedTime runtime = new ElapsedTime();",
            "",
            "    // Define class members",
            "    DeviceInterfaceModule   dim;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        // Connect to motor (Assume standard left wheel)",
            "        // Change the text in quotes to match any motor name on your robot.",
            "        dim = hardwareMap.get(DeviceInterfaceModule.class, \"dim\\\");",
            "",
            "        // Toggle LEDs while Waiting for the start button",
            "        telemetry.addData(\\\">\\\", \\\"Press Play to test LEDs.\\\" );",
            "        telemetry.update();",
            "",
            "        while (!isStarted()) {",
            "            // Determine if we are on an odd or even second",
            "            boolean even = (((int)(runtime.time()) & 0x01) == 0);",
            "            dim.setLED(RED_LED,   even); // Red for even",
            "            dim.setLED(BLUE_LED, !even); // Blue for odd",
            "            idle();",
            "        }",
            "",
            "        // Running now",
            "        telemetry.addData(\\\">\\\", \\\"Press X for Blue, B for Red.\\\" );",
            "        telemetry.update();",
            "",
            "        // Now just use red and blue buttons to set red and blue LEDs",
            "        while(opModeIsActive()){",
            "            dim.setLED(BLUE_LED, gamepad1.x);",
            "            dim.setLED(RED_LED,  gamepad1.b);",
            "            idle();",
            "        }",
            "",
            "        // Turn off LEDs;",
            "        dim.setLED(BLUE_LED, false);",
            "        dim.setLED(RED_LED,  false);",
            "        telemetry.addData(\\\">\\\", \\\"Done\\\");",
            "        telemetry.update();",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptVuMarkIdentification": {
        "prefix": "conceptVuMarkIdentification",
        "description": "            See if any of the instances of {@link relicTemplate} are currently visible.\n            {@link RelicRecoveryVuMark} is an enum which can have the following values:\n            UNKNOWN, LEFT, CENTER, and RIGHT. When a VuMark is visible, something other than\n            UNKNOWN will be returned by {@link RelicRecoveryVuMark#from(VuforiaTrackable)}.\n             ",
        "body": [
            "public class ConceptVuMarkIdentification extends LinearOpMode {",
            "",
            "    public static final String TAG = \"Vuforia VuMark Sample\\\";",
            "",
            "    OpenGLMatrix lastLocation = null;",
            "",
            "    /**",
            "     * {@link #vuforia} is the variable we will use to store our instance of the Vuforia",
            "     * localization engine.",
            "     */",
            "    VuforiaLocalizer vuforia;",
            "",
            "    @Override public void runOpMode() {",
            "",
            "        /*",
            "         * To start up Vuforia, tell it the view that we wish to use for camera monitor (on the RC phone);",
            "         */",
            "        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\\\"cameraMonitorViewId\\\", \\\"id\\\", hardwareMap.appContext.getPackageName());",
            "        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId);",
            "",
            "        // OR...  Do Not Activate the Camera Monitor View, to save power",
            "        // VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();",
            "",
            "        /*",
            "         * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which",
            "         * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.",
            "         * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer",
            "         * web site at https://developer.vuforia.com/license-manager.",
            "         *",
            "         * Vuforia license keys are always 380 characters long, and look as if they contain mostly",
            "         * random data. As an example, here is a example of a fragment of a valid key:",
            "         *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...",
            "         * Once you've obtained a license key, copy the string from the Vuforia web site",
            "         * and paste it in to your code on the next line, between the double quotes.",
            "         */",
            "        parameters.vuforiaLicenseKey = \\\" -- YOUR NEW VUFORIA KEY GOES HERE  --- \\\";",
            "",
            "        /*",
            "         * We also indicate which camera on the RC that we wish to use.",
            "         * Here we chose the back (HiRes) camera (for greater range), but",
            "         * for a competition robot, the front camera might be more convenient.",
            "         */",
            "        parameters.cameraDirection = VuforiaLocalizer.CameraDirection.BACK;",
            "",
            "        /**",
            "         * Instantiate the Vuforia engine",
            "         */",
            "        vuforia = ClassFactory.getInstance().createVuforia(parameters);",
            "",
            "",
            "        /**",
            "         * Load the data set containing the VuMarks for Relic Recovery. There's only one trackable",
            "         * in this data set: all three of the VuMarks in the game were created from this one template,",
            "         * but differ in their instance id information.",
            "         * @see VuMarkInstanceId",
            "         */",
            "        VuforiaTrackables relicTrackables = this.vuforia.loadTrackablesFromAsset(\\\"RelicVuMark\\\");",
            "        VuforiaTrackable relicTemplate = relicTrackables.get(0);",
            "        relicTemplate.setName(\\\"relicVuMarkTemplate\\\"); // can help in debugging; otherwise not necessary",
            "",
            "        telemetry.addData(\\\">\\\", \\\"Press Play to start\\\");",
            "        telemetry.update();",
            "        waitForStart();",
            "",
            "        relicTrackables.activate();",
            "",
            "        while (opModeIsActive()) {",
            "",
            "            /**",
            "             * See if any of the instances of {@link relicTemplate} are currently visible.",
            "             * {@link RelicRecoveryVuMark} is an enum which can have the following values:",
            "             * UNKNOWN, LEFT, CENTER, and RIGHT. When a VuMark is visible, something other than",
            "             * UNKNOWN will be returned by {@link RelicRecoveryVuMark#from(VuforiaTrackable)}.",
            "             */",
            "            RelicRecoveryVuMark vuMark = RelicRecoveryVuMark.from(relicTemplate);",
            "            if (vuMark != RelicRecoveryVuMark.UNKNOWN) {",
            "",
            "                /* Found an instance of the template. In the actual game, you will probably",
            "                 * loop until this condition occurs, then move on to act accordingly depending",
            "                 * on which VuMark was visible. */",
            "                telemetry.addData(\\\"VuMark\\\", \\\"%s visible\\\", vuMark);",
            "",
            "                /* For fun, we also exhibit the navigational pose. In the Relic Recovery game,",
            "                 * it is perhaps unlikely that you will actually need to act on this pose information, but",
            "                 * we illustrate it nevertheless, for completeness. */",
            "                OpenGLMatrix pose = ((VuforiaTrackableDefaultListener)relicTemplate.getListener()).getPose();",
            "                telemetry.addData(\\\"Pose\\\", format(pose));",
            "",
            "                /* We further illustrate how to decompose the pose into useful rotational and",
            "                 * translational components */",
            "                if (pose != null) {",
            "                    VectorF trans = pose.getTranslation();",
            "                    Orientation rot = Orientation.getOrientation(pose, AxesReference.EXTRINSIC, AxesOrder.XYZ, AngleUnit.DEGREES);",
            "",
            "                    // Extract the X, Y, and Z components of the offset of the target relative to the robot",
            "                    double tX = trans.get(0);",
            "                    double tY = trans.get(1);",
            "                    double tZ = trans.get(2);",
            "",
            "                    // Extract the rotational components of the target relative to the robot",
            "                    double rX = rot.firstAngle;",
            "                    double rY = rot.secondAngle;",
            "                    double rZ = rot.thirdAngle;",
            "                }",
            "            }",
            "            else {",
            "                telemetry.addData(\\\"VuMark\\\", \\\"not visible\\\");",
            "            }",
            "",
            "            telemetry.update();",
            "        }",
            "    }",
            "",
            "    String format(OpenGLMatrix transformationMatrix) {",
            "        return (transformationMatrix != null) ? transformationMatrix.formatAsTransform() : \\\"null\\\";",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptTensorFlowObjectDetectionSwitchableCameras": {
        "prefix": "conceptTensorFlowObjectDetectionSwitchableCameras",
        "description": "    Initialize the TensorFlow Object Detection engine.\n     ",
        "body": [
            "public class ConceptTensorFlowObjectDetectionSwitchableCameras extends LinearOpMode {",
            "",
            "    /*",
            "     * Specify the source for the Tensor Flow Model.",
            "     * If the TensorFlowLite object model is included in the Robot Controller App as an \"asset\\\",",
            "     * the OpMode must to load it using loadModelFromAsset().  However, if a team generated model",
            "     * has been downloaded to the Robot Controller's SD FLASH memory, it must to be loaded using loadModelFromFile()",
            "     * Here we assume it's an Asset.    Also see method initTfod() below .",
            "     */",
            "    private static final String TFOD_MODEL_ASSET = \\\"PowerPlay.tflite\\\";",
            "    // private static final String TFOD_MODEL_FILE  = \\\"/sdcard/FIRST/tflitemodels/CustomTeamModel.tflite\\\";",
            "",
            "    private static final String[] LABELS = {",
            "            \\\"1 Bolt\\\",",
            "            \\\"2 Bulb\\\",",
            "            \\\"3 Panel\\\"",
            "    };",
            "",
            "    /*",
            "     * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which",
            "     * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.",
            "     * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer",
            "     * web site at https://developer.vuforia.com/license-manager.",
            "     *",
            "     * Vuforia license keys are always 380 characters long, and look as if they contain mostly",
            "     * random data. As an example, here is a example of a fragment of a valid key:",
            "     *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...",
            "     * Once you've obtained a license key, copy the string from the Vuforia web site",
            "     * and paste it in to your code on the next line, between the double quotes.",
            "     */",
            "    private static final String VUFORIA_KEY =",
            "            \\\" -- YOUR NEW VUFORIA KEY GOES HERE  --- \\\";",
            "",
            "    /**",
            "     * {@link #vuforia} is the variable we will use to store our instance of the Vuforia",
            "     * localization engine.",
            "     */",
            "    private VuforiaLocalizer vuforia;",
            "",
            "    /**",
            "     * Variables used for switching cameras.",
            "     */",
            "    private WebcamName webcam1, webcam2;",
            "    private SwitchableCamera switchableCamera;",
            "    private boolean oldLeftBumper;",
            "    private boolean oldRightBumper;",
            "",
            "    /**",
            "     * {@link #tfod} is the variable we will use to store our instance of the TensorFlow Object",
            "     * Detection engine.",
            "     */",
            "    private TFObjectDetector tfod;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "        // The TFObjectDetector uses the camera frames from the VuforiaLocalizer, so we create that",
            "        // first.",
            "        initVuforia();",
            "        initTfod();",
            "",
            "        /**",
            "         * Activate TensorFlow Object Detection before we wait for the start command.",
            "         * Do it here so that the Camera Stream window will have the TensorFlow annotations visible.",
            "         **/",
            "        if (tfod != null) {",
            "            tfod.activate();",
            "",
            "            // The TensorFlow software will scale the input images from the camera to a lower resolution.",
            "            // This can result in lower detection accuracy at longer distances (> 55cm or 22\\\").",
            "            // If your target is at distance greater than 50 cm (20\\\") you can increase the magnification value",
            "            // to artificially zoom in to the center of image.  For best results, the \\\"aspectRatio\\\" argument",
            "            // should be set to the value of the images used to create the TensorFlow Object Detection model",
            "            // (typically 16/9).",
            "            tfod.setZoom(1.0, 16.0/9.0);",
            "        }",
            "",
            "        /** Wait for the game to begin */",
            "        telemetry.addData(\\\">\\\", \\\"Press Play to start op mode\\\");",
            "        telemetry.update();",
            "        waitForStart();",
            "",
            "        if (opModeIsActive()) {",
            "            while (opModeIsActive()) {",
            "                if (tfod != null) {",
            "                    doCameraSwitching();",
            "                    List<Recognition> recognitions = tfod.getRecognitions();",
            "                    telemetry.addData(\\\"# Objects Detected\\\", recognitions.size());",
            "                    // step through the list of recognitions and display image size and position",
            "                    // Note: \\\"Image number\\\" refers to the randomized image orientation/number",
            "                    for (Recognition recognition : recognitions) {",
            "                        double col = (recognition.getLeft() + recognition.getRight()) / 2 ;",
            "                        double row = (recognition.getTop()  + recognition.getBottom()) / 2 ;",
            "                        double width  = Math.abs(recognition.getRight() - recognition.getLeft()) ;",
            "                        double height = Math.abs(recognition.getTop()  - recognition.getBottom()) ;",
            "",
            "                        telemetry.addData(\\\"\\\",\\\" \\\");",
            "                        telemetry.addData(\\\"Image\\\", \\\"%s (%.0f %% Conf.)\\\", recognition.getLabel(), recognition.getConfidence() * 100 );",
            "                        telemetry.addData(\\\"- Position (Row/Col)\\\",\\\"%.0f / %.0f\\\", row, col);",
            "                        telemetry.addData(\\\"- Size (Width/Height)\\\",\\\"%.0f / %.0f\\\", width, height);",
            "                    }",
            "                    telemetry.update();",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    /**",
            "     * Initialize the Vuforia localization engine.",
            "     */",
            "    private void initVuforia() {",
            "        /*",
            "         * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine.",
            "         */",
            "        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();",
            "",
            "        parameters.vuforiaLicenseKey = VUFORIA_KEY;",
            "",
            "        // Indicate that we wish to be able to switch cameras.",
            "        webcam1 = hardwareMap.get(WebcamName.class, \\\"Webcam 1\\\");",
            "        webcam2 = hardwareMap.get(WebcamName.class, \\\"Webcam 2\\\");",
            "        parameters.cameraName = ClassFactory.getInstance().getCameraManager().nameForSwitchableCamera(webcam1, webcam2);",
            "",
            "        //  Instantiate the Vuforia engine",
            "        vuforia = ClassFactory.getInstance().createVuforia(parameters);",
            "",
            "        // Set the active camera to Webcam 1.",
            "        switchableCamera = (SwitchableCamera) vuforia.getCamera();",
            "        switchableCamera.setActiveCamera(webcam1);",
            "    }",
            "",
            "    /**",
            "     * Initialize the TensorFlow Object Detection engine.",
            "     */",
            "    private void initTfod() {",
            "        int tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(",
            "            \\\"tfodMonitorViewId\\\", \\\"id\\\", hardwareMap.appContext.getPackageName());",
            "        TFObjectDetector.Parameters tfodParameters = new TFObjectDetector.Parameters(tfodMonitorViewId);",
            "        tfodParameters.minResultConfidence = 0.75f;",
            "        tfodParameters.isModelTensorFlow2 = true;",
            "        tfodParameters.inputSize = 300;",
            "        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia);",
            "",
            "        // Use loadModelFromAsset() if the TF Model is built in as an asset by Android Studio",
            "        // Use loadModelFromFile() if you have downloaded a custom team model to the Robot Controller's FLASH.",
            "        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABELS);",
            "        // tfod.loadModelFromFile(TFOD_MODEL_FILE, LABELS);",
            "    }",
            "",
            "    private void doCameraSwitching() {",
            "        // If the left bumper is pressed, use Webcam 1.",
            "        // If the right bumper is pressed, use Webcam 2.",
            "        boolean newLeftBumper = gamepad1.left_bumper;",
            "        boolean newRightBumper = gamepad1.right_bumper;",
            "        if (newLeftBumper && !oldLeftBumper) {",
            "            switchableCamera.setActiveCamera(webcam1);",
            "        } else if (newRightBumper && !oldRightBumper) {",
            "            switchableCamera.setActiveCamera(webcam2);",
            "        }",
            "        oldLeftBumper = newLeftBumper;",
            "        oldRightBumper = newRightBumper;",
            "",
            "        if (switchableCamera.getActiveCamera().equals(webcam1)) {",
            "            telemetry.addData(\\\"activeCamera\\\", \\\"Webcam 1\\\");",
            "            telemetry.addData(\\\"Press RightBumper\\\", \\\"to switch to Webcam 2\\\");",
            "        } else {",
            "            telemetry.addData(\\\"activeCamera\\\", \\\"Webcam 2\\\");",
            "            telemetry.addData(\\\"Press LeftBumper\\\", \\\"to switch to Webcam 1\\\");",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptVuforiaNavigation": {
        "prefix": "conceptVuforiaNavigation",
        "description": "    A simple utility that extracts positioning information from a transformation matrix\n    and formats it in a form palatable to a human being.\n     ",
        "body": [
            "public class ConceptVuforiaNavigation extends LinearOpMode {",
            "",
            "    public static final String TAG = \"Vuforia Navigation Sample\\\";",
            "",
            "    OpenGLMatrix lastLocation = null;",
            "",
            "    /**",
            "     * {@link #vuforia} is the variable we will use to store our instance of the Vuforia",
            "     * localization engine.",
            "     */",
            "    VuforiaLocalizer vuforia;",
            "",
            "    @Override public void runOpMode() {",
            "        /*",
            "         * To start up Vuforia, tell it the view that we wish to use for camera monitor (on the RC phone);",
            "         * If no camera monitor is desired, use the parameterless constructor instead (commented out below).",
            "         */",
            "        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\\\"cameraMonitorViewId\\\", \\\"id\\\", hardwareMap.appContext.getPackageName());",
            "        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId);",
            "",
            "        // OR...  Do Not Activate the Camera Monitor View, to save power",
            "        // VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();",
            "",
            "        /*",
            "         * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which",
            "         * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.",
            "         * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer",
            "         * web site at https://developer.vuforia.com/license-manager.",
            "         *",
            "         * Vuforia license keys are always 380 characters long, and look as if they contain mostly",
            "         * random data. As an example, here is a example of a fragment of a valid key:",
            "         *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...",
            "         * Once you've obtained a license key, copy the string from the Vuforia web site",
            "         * and paste it in to your code on the next line, between the double quotes.",
            "         */",
            "        parameters.vuforiaLicenseKey = \\\" -- YOUR NEW VUFORIA KEY GOES HERE  --- \\\";",
            "",
            "        /*",
            "         * We also indicate which camera on the RC that we wish to use.",
            "         * Here we chose the back (HiRes) camera (for greater range), but",
            "         * for a competition robot, the front camera might be more convenient.",
            "         */",
            "        parameters.cameraDirection = VuforiaLocalizer.CameraDirection.BACK;",
            "",
            "        /**",
            "         * Instantiate the Vuforia engine",
            "         */",
            "        vuforia = ClassFactory.getInstance().createVuforia(parameters);",
            "",
            "        /**",
            "         * Load the data sets that for the trackable objects we wish to track. These particular data",
            "         * sets are stored in the 'assets' part of our application (you'll see them in the Android",
            "         * Studio 'Project' view over there on the left of the screen). You can make your own datasets",
            "         * with the Vuforia Target Manager: https://developer.vuforia.com/target-manager. PDFs for the",
            "         * example \\\"StonesAndChips\\\", datasets can be found in in this project in the",
            "         * documentation directory.",
            "         */",
            "        VuforiaTrackables stonesAndChips = this.vuforia.loadTrackablesFromAsset(\\\"StonesAndChips\\\");",
            "        VuforiaTrackable redTarget = stonesAndChips.get(0);",
            "        redTarget.setName(\\\"RedTarget\\\");  // Stones",
            "",
            "        VuforiaTrackable blueTarget  = stonesAndChips.get(1);",
            "        blueTarget.setName(\\\"BlueTarget\\\");  // Chips",
            "",
            "        /** For convenience, gather together all the trackable objects in one easily-iterable collection */",
            "        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();",
            "        allTrackables.addAll(stonesAndChips);",
            "",
            "        /**",
            "         * We use units of mm here because that's the recommended units of measurement for the",
            "         * size values specified in the XML for the ImageTarget trackables in data sets. E.g.:",
            "         *      <ImageTarget name=\\\"stones\\\" size=\\\"247 173\\\"/>",
            "         * You don't *have to* use mm here, but the units here and the units used in the XML",
            "         * target configuration files *must* correspond for the math to work out correctly.",
            "         */",
            "        float mmPerInch        = 25.4f;",
            "        float mmBotWidth       = 18 * mmPerInch;            // ... or whatever is right for your robot",
            "        float mmFTCFieldWidth  = (12*12 - 2) * mmPerInch;   // the FTC field is ~11'10\\\" center-to-center of the glass panels",
            "",
            "        /**",
            "         * In order for localization to work, we need to tell the system where each target we",
            "         * wish to use for navigation resides on the field, and we need to specify where on the robot",
            "         * the phone resides. These specifications are in the form of <em>transformation matrices.</em>",
            "         * Transformation matrices are a central, important concept in the math here involved in localization.",
            "         * See <a href=\\\"https://en.wikipedia.org/wiki/Transformation_matrix\\\">Transformation Matrix</a>",
            "         * for detailed information. Commonly, you'll encounter transformation matrices as instances",
            "         * of the {@link OpenGLMatrix} class.",
            "         *",
            "         * For the most part, you don't need to understand the details of the math of how transformation",
            "         * matrices work inside (as fascinating as that is, truly). Just remember these key points:",
            "         * <ol>",
            "         *",
            "         *     <li>You can put two transformations together to produce a third that combines the effect of",
            "         *     both of them. If, for example, you have a rotation transform R and a translation transform T,",
            "         *     then the combined transformation matrix RT which does the rotation first and then the translation",
            "         *     is given by {@code RT = T.multiplied(R)}. That is, the transforms are multiplied in the",
            "         *     <em>reverse</em> of the chronological order in which they applied.</li>",
            "         *",
            "         *     <li>A common way to create useful transforms is to use methods in the {@link OpenGLMatrix}",
            "         *     class and the Orientation class. See, for example, {@link OpenGLMatrix#translation(float,",
            "         *     float, float)}, {@link OpenGLMatrix#rotation(AngleUnit, float, float, float, float)}, and",
            "         *     {@link Orientation#getRotationMatrix(AxesReference, AxesOrder, AngleUnit, float, float, float)}.",
            "         *     Related methods in {@link OpenGLMatrix}, such as {@link OpenGLMatrix#rotated(AngleUnit,",
            "         *     float, float, float, float)}, are syntactic shorthands for creating a new transform and",
            "         *     then immediately multiplying the receiver by it, which can be convenient at times.</li>",
            "         *",
            "         *     <li>If you want to break open the black box of a transformation matrix to understand",
            "         *     what it's doing inside, use {@link MatrixF#getTranslation()} to fetch how much the",
            "         *     transform will move you in x, y, and z, and use {@link Orientation#getOrientation(MatrixF,",
            "         *     AxesReference, AxesOrder, AngleUnit)} to determine the rotational motion that the transform",
            "         *     will impart. See {@link #format(OpenGLMatrix)} below for an example.</li>",
            "         *",
            "         * </ol>",
            "         *",
            "         * This example places the \\\"stones\\\" image on the perimeter wall to the Left",
            "         *  of the Red Driver station wall.  Similar to the Red Beacon Location on the Res-Q",
            "         *",
            "         * This example places the \\\"chips\\\" image on the perimeter wall to the Right",
            "         *  of the Blue Driver station.  Similar to the Blue Beacon Location on the Res-Q",
            "         *",
            "         * See the doc folder of this project for a description of the field Axis conventions.",
            "         *",
            "         * Initially the target is conceptually lying at the origin of the field's coordinate system",
            "         * (the center of the field), facing up.",
            "         *",
            "         * In this configuration, the target's coordinate system aligns with that of the field.",
            "         *",
            "         * In a real situation we'd also account for the vertical (Z) offset of the target,",
            "         * but for simplicity, we ignore that here; for a real robot, you'll want to fix that.",
            "         *",
            "         * To place the Stones Target on the Red Audience wall:",
            "         * - First we rotate it 90 around the field's X axis to flip it upright",
            "         * - Then we rotate it  90 around the field's Z access to face it away from the audience.",
            "         * - Finally, we translate it back along the X axis towards the red audience wall.",
            "         */",
            "        OpenGLMatrix redTargetLocationOnField = OpenGLMatrix",
            "                /* Then we translate the target off to the RED WALL. Our translation here",
            "                is a negative translation in X.*/",
            "                .translation(-mmFTCFieldWidth/2, 0, 0)",
            "                .multiplied(Orientation.getRotationMatrix(",
            "                        /* First, in the fixed (field) coordinate system, we rotate 90deg in X, then 90 in Z */",
            "                        AxesReference.EXTRINSIC, AxesOrder.XZX,",
            "                        AngleUnit.DEGREES, 90, 90, 0));",
            "        redTarget.setLocation(redTargetLocationOnField);",
            "        RobotLog.ii(TAG, \\\"Red Target=%s\\\", format(redTargetLocationOnField));",
            "",
            "       /*",
            "        * To place the Stones Target on the Blue Audience wall:",
            "        * - First we rotate it 90 around the field's X axis to flip it upright",
            "        * - Finally, we translate it along the Y axis towards the blue audience wall.",
            "        */",
            "        OpenGLMatrix blueTargetLocationOnField = OpenGLMatrix",
            "                /* Then we translate the target off to the Blue Audience wall.",
            "                Our translation here is a positive translation in Y.*/",
            "                .translation(0, mmFTCFieldWidth/2, 0)",
            "                .multiplied(Orientation.getRotationMatrix(",
            "                        /* First, in the fixed (field) coordinate system, we rotate 90deg in X */",
            "                        AxesReference.EXTRINSIC, AxesOrder.XZX,",
            "                        AngleUnit.DEGREES, 90, 0, 0));",
            "        blueTarget.setLocation(blueTargetLocationOnField);",
            "        RobotLog.ii(TAG, \\\"Blue Target=%s\\\", format(blueTargetLocationOnField));",
            "",
            "        /**",
            "         * Create a transformation matrix describing where the phone is on the robot. Here, we",
            "         * put the phone on the right hand side of the robot with the screen facing in (see our",
            "         * choice of BACK camera above) and in landscape mode. Starting from alignment between the",
            "         * robot's and phone's axes, this is a rotation of -90deg along the Y axis.",
            "         *",
            "         * When determining whether a rotation is positive or negative, consider yourself as looking",
            "         * down the (positive) axis of rotation from the positive towards the origin. Positive rotations",
            "         * are then CCW, and negative rotations CW. An example: consider looking down the positive Z",
            "         * axis towards the origin. A positive rotation about Z (ie: a rotation parallel to the the X-Y",
            "         * plane) is then CCW, as one would normally expect from the usual classic 2D geometry.",
            "         */",
            "        OpenGLMatrix phoneLocationOnRobot = OpenGLMatrix",
            "                .translation(mmBotWidth/2,0,0)",
            "                .multiplied(Orientation.getRotationMatrix(",
            "                        AxesReference.EXTRINSIC, AxesOrder.YZY,",
            "                        AngleUnit.DEGREES, -90, 0, 0));",
            "        RobotLog.ii(TAG, \\\"phone=%s\\\", format(phoneLocationOnRobot));",
            "",
            "        /**",
            "         * Let the trackable listeners we care about know where the phone is. We know that each",
            "         * listener is a {@link VuforiaTrackableDefaultListener} and can so safely cast because",
            "         * we have not ourselves installed a listener of a different type.",
            "         */",
            "        ((VuforiaTrackableDefaultListener)redTarget.getListener()).setPhoneInformation(phoneLocationOnRobot, parameters.cameraDirection);",
            "        ((VuforiaTrackableDefaultListener)blueTarget.getListener()).setPhoneInformation(phoneLocationOnRobot, parameters.cameraDirection);",
            "",
            "        /**",
            "         * A brief tutorial: here's how all the math is going to work:",
            "         *",
            "         * C = phoneLocationOnRobot  maps   phone coords -> robot coords",
            "         * P = tracker.getPose()     maps   image target coords -> phone coords",
            "         * L = redTargetLocationOnField maps   image target coords -> field coords",
            "         *",
            "         * So",
            "         *",
            "         * C.inverted()              maps   robot coords -> phone coords",
            "         * P.inverted()              maps   phone coords -> imageTarget coords",
            "         *",
            "         * Putting that all together,",
            "         *",
            "         * L x P.inverted() x C.inverted() maps robot coords to field coords.",
            "         *",
            "         * @see VuforiaTrackableDefaultListener#getRobotLocation()",
            "         */",
            "",
            "        /** Wait for the game to begin */",
            "        telemetry.addData(\\\">\\\", \\\"Press Play to start tracking\\\");",
            "        telemetry.update();",
            "        waitForStart();",
            "",
            "        /** Start tracking the data sets we care about. */",
            "        stonesAndChips.activate();",
            "",
            "        while (opModeIsActive()) {",
            "",
            "            for (VuforiaTrackable trackable : allTrackables) {",
            "                /**",
            "                 * getUpdatedRobotLocation() will return null if no new information is available since",
            "                 * the last time that call was made, or if the trackable is not currently visible.",
            "                 * getRobotLocation() will return null if the trackable is not currently visible.",
            "                 */",
            "                telemetry.addData(trackable.getName(), ((VuforiaTrackableDefaultListener)trackable.getListener()).isVisible() ? \\\"Visible\\\" : \\\"Not Visible\\\");    //",
            "",
            "                OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener)trackable.getListener()).getUpdatedRobotLocation();",
            "                if (robotLocationTransform != null) {",
            "                    lastLocation = robotLocationTransform;",
            "                }",
            "            }",
            "            /**",
            "             * Provide feedback as to where the robot was last located (if we know).",
            "             */",
            "            if (lastLocation != null) {",
            "                //  RobotLog.vv(TAG, \\\"robot=%s\\\", format(lastLocation));",
            "                telemetry.addData(\\\"Pos\\\", format(lastLocation));",
            "            } else {",
            "                telemetry.addData(\\\"Pos\\\", \\\"Unknown\\\");",
            "            }",
            "            telemetry.update();",
            "        }",
            "    }",
            "",
            "    /**",
            "     * A simple utility that extracts positioning information from a transformation matrix",
            "     * and formats it in a form palatable to a human being.",
            "     */",
            "    String format(OpenGLMatrix transformationMatrix) {",
            "        return transformationMatrix.formatAsTransform();",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptScanServo": {
        "prefix": "conceptScanServo",
        "description": "This OpMode scans a single servo back and forward until Stop is pressed.\nThe code is structured as a LinearOpMode\nINCREMENT sets how much to increase/decrease the servo position each cycle\nCYCLE_MS sets the update period.\n\nThis code assumes a Servo configured with the name \"left_hand\" as is found on a Robot.\n\nNOTE: When any servo position is set, ALL attached servos are activated, so ensure that any other\nconnected servos are able to move freely before running this test.\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list\n ",
        "body": [
            "public class ConceptScanServo extends LinearOpMode {",
            "",
            "    static final double INCREMENT   = 0.01;     // amount to slew servo each CYCLE_MS cycle",
            "    static final int    CYCLE_MS    =   50;     // period of each cycle",
            "    static final double MAX_POS     =  1.0;     // Maximum rotational position",
            "    static final double MIN_POS     =  0.0;     // Minimum rotational position",
            "",
            "    // Define class members",
            "    Servo   servo;",
            "    double  position = (MAX_POS - MIN_POS) / 2; // Start at halfway position",
            "    boolean rampUp = true;",
            "",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        // Connect to servo (Assume Robot Left Hand)",
            "        // Change the text in quotes to match any servo name on your robot.",
            "        servo = hardwareMap.get(Servo.class, \"left_hand\\\");",
            "",
            "        // Wait for the start button",
            "        telemetry.addData(\\\">\\\", \\\"Press Start to scan Servo.\\\" );",
            "        telemetry.update();",
            "        waitForStart();",
            "",
            "",
            "        // Scan servo till stop pressed.",
            "        while(opModeIsActive()){",
            "",
            "            // slew the servo, according to the rampUp (direction) variable.",
            "            if (rampUp) {",
            "                // Keep stepping up until we hit the max value.",
            "                position += INCREMENT ;",
            "                if (position >= MAX_POS ) {",
            "                    position = MAX_POS;",
            "                    rampUp = !rampUp;   // Switch ramp direction",
            "                }",
            "            }",
            "            else {",
            "                // Keep stepping down until we hit the min value.",
            "                position -= INCREMENT ;",
            "                if (position <= MIN_POS ) {",
            "                    position = MIN_POS;",
            "                    rampUp = !rampUp;  // Switch ramp direction",
            "                }",
            "            }",
            "",
            "            // Display the current value",
            "            telemetry.addData(\\\"Servo Position\\\", \\\"%5.2f\\\", position);",
            "            telemetry.addData(\\\">\\\", \\\"Press Stop to end test.\\\" );",
            "            telemetry.update();",
            "",
            "            // Set the servo to the new position and pause;",
            "            servo.setPosition(position);",
            "            sleep(CYCLE_MS);",
            "            idle();",
            "        }",
            "",
            "        // Signal done;",
            "        telemetry.addData(\\\">\\\", \\\"Done\\\");",
            "        telemetry.update();",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptRevSPARKMini": {
        "prefix": "conceptRevSPARKMini",
        "description": "\nThis OpMode executes a basic Tank Drive Teleop for a two wheeled robot using two REV SPARKminis.\nTo use this example, connect two REV SPARKminis into servo ports on the Expansion Hub. On the\nrobot configuration, use the drop down list under 'Servos' to select 'REV SPARKmini Controller'\nand name them 'left_drive' and 'right_drive'.\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this OpMode to the Driver Station OpMode list\n ",
        "body": [
            "public class ConceptRevSPARKMini extends LinearOpMode {",
            "",
            "    // Declare OpMode members.",
            "    private ElapsedTime runtime = new ElapsedTime();",
            "    private DcMotorSimple leftDrive = null;",
            "    private DcMotorSimple rightDrive = null;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "        telemetry.addData(\"Status\\\", \\\"Initialized\\\");",
            "        telemetry.update();",
            "",
            "        // Initialize the hardware variables. Note that the strings used here as parameters",
            "        // to 'get' must correspond to the names assigned during the robot configuration",
            "        // step (using the FTC Robot Controller app on the phone).",
            "        leftDrive  = hardwareMap.get(DcMotorSimple.class, \\\"left_drive\\\");",
            "        rightDrive = hardwareMap.get(DcMotorSimple.class, \\\"right_drive\\\");",
            "",
            "        // Most robots need the motor on one side to be reversed to drive forward",
            "        // Reverse the motor that runs backward when connected directly to the battery",
            "        leftDrive.setDirection(DcMotorSimple.Direction.FORWARD);",
            "        rightDrive.setDirection(DcMotorSimple.Direction.REVERSE);",
            "",
            "        // Wait for the game to start (driver presses PLAY)",
            "        waitForStart();",
            "        runtime.reset();",
            "",
            "        // run until the end of the match (driver presses STOP)",
            "        while (opModeIsActive()) {",
            "",
            "            // Setup a variable for each drive wheel to save power level for telemetry",
            "            double leftPower;",
            "            double rightPower;",
            "",
            "            // Choose to drive using either Tank Mode, or POV Mode",
            "            // Comment out the method that's not used.  The default below is POV.",
            "",
            "            // POV Mode uses left stick to go forward, and right stick to turn.",
            "            // - This uses basic math to combine motions and is easier to drive straight.",
            "            double drive = -gamepad1.left_stick_y;",
            "            double turn  =  gamepad1.right_stick_x;",
            "            leftPower    = Range.clip(drive + turn, -1.0, 1.0) ;",
            "            rightPower   = Range.clip(drive - turn, -1.0, 1.0) ;",
            "",
            "            // Tank Mode uses one stick to control each wheel.",
            "            // - This requires no math, but it is hard to drive forward slowly and keep straight.",
            "            // leftPower  = -gamepad1.left_stick_y ;",
            "            // rightPower = -gamepad1.right_stick_y ;",
            "",
            "            // Send calculated power to wheels",
            "            leftDrive.setPower(leftPower);",
            "            rightDrive.setPower(rightPower);",
            "",
            "            // Show the elapsed game time and wheel power.",
            "            telemetry.addData(\\\"Status\\\", \\\"Run Time: \\\" + runtime.toString());",
            "            telemetry.addData(\\\"Motors\\\", \\\"left (%.2f), right (%.2f)\\\", leftPower, rightPower);",
            "            telemetry.update();",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptSoundsSKYSTONE": {
        "prefix": "conceptSoundsSKYSTONE",
        "description": "This file demonstrates how to play one of the several SKYSTONE/Star Wars sounds loaded into the SDK.\nIt does this by creating a simple \"chooser\" controlled by the gamepad Up Down buttons.\nThis code also prevents sounds from stacking up by setting a \"playing\" flag, which is cleared when the sound finishes playing.\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this OpMode to the Driver Station OpMode list\n\nOperation:\n     Use the DPAD to change the selected sound, and the Right Bumper to play it.\n ",
        "body": [
            "public class ConceptSoundsSKYSTONE extends LinearOpMode {",
            "",
            "    // List of available sound resources",
            "    String  sounds[] =  {\"ss_alarm\\\", \\\"ss_bb8_down\\\", \\\"ss_bb8_up\\\", \\\"ss_darth_vader\\\", \\\"ss_fly_by\\\",",
            "            \\\"ss_mf_fail\\\", \\\"ss_laser\\\", \\\"ss_laser_burst\\\", \\\"ss_light_saber\\\", \\\"ss_light_saber_long\\\", \\\"ss_light_saber_short\\\",",
            "            \\\"ss_light_speed\\\", \\\"ss_mine\\\", \\\"ss_power_up\\\", \\\"ss_r2d2_up\\\", \\\"ss_roger_roger\\\", \\\"ss_siren\\\", \\\"ss_wookie\\\" };",
            "    boolean soundPlaying = false;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        // Variables for choosing from the available sounds",
            "        int     soundIndex      = 0;",
            "        int     soundID         = -1;",
            "        boolean was_dpad_up     = false;",
            "        boolean was_dpad_down   = false;",
            "",
            "        Context myApp = hardwareMap.appContext;",
            "",
            "        // create a sound parameter that holds the desired player parameters.",
            "        SoundPlayer.PlaySoundParams params = new SoundPlayer.PlaySoundParams();",
            "        params.loopControl = 0;",
            "        params.waitForNonLoopingSoundsToFinish = true;",
            "",
            "        // In this sample, we will skip waiting for the user to press play, and start displaying sound choices right away",
            "        while (!isStopRequested()) {",
            "",
            "            // Look for DPAD presses to change the selection",
            "            if (gamepad1.dpad_down && !was_dpad_down) {",
            "                // Go to next sound (with list wrap) and display it",
            "                soundIndex = (soundIndex + 1) % sounds.length;",
            "            }",
            "",
            "            if (gamepad1.dpad_up && !was_dpad_up) {",
            "                // Go to previous sound (with list wrap) and display it",
            "                soundIndex = (soundIndex + sounds.length - 1) % sounds.length;",
            "            }",
            "",
            "            // Look for trigger to see if we should play sound",
            "            // Only start a new sound if we are currently not playing one.",
            "            if (gamepad1.right_bumper && !soundPlaying) {",
            "",
            "                // Determine Resource IDs for the sounds you want to play, and make sure it's valid.",
            "                if ((soundID = myApp.getResources().getIdentifier(sounds[soundIndex], \\\"raw\\\", myApp.getPackageName())) != 0){",
            "",
            "                    // Signal that the sound is now playing.",
            "                    soundPlaying = true;",
            "",
            "                    // Start playing, and also Create a callback that will clear the playing flag when the sound is complete.",
            "                    SoundPlayer.getInstance().startPlaying(myApp, soundID, params, null,",
            "                            new Runnable() {",
            "                                public void run() {",
            "                                    soundPlaying = false;",
            "                                }} );",
            "                }",
            "            }",
            "",
            "            // Remember the last state of the dpad to detect changes.",
            "            was_dpad_up     = gamepad1.dpad_up;",
            "            was_dpad_down   = gamepad1.dpad_down;",
            "",
            "            // Display the current sound choice, and the playing status.",
            "            telemetry.addData(\\\"\\\", \\\"Use DPAD up/down to choose sound.\\\");",
            "            telemetry.addData(\\\"\\\", \\\"Press Right Bumper to play sound.\\\");",
            "            telemetry.addData(\\\"\\\", \\\"\\\");",
            "            telemetry.addData(\\\"Sound >\\\", sounds[soundIndex]);",
            "            telemetry.addData(\\\"Status >\\\", soundPlaying ? \\\"Playing\\\" : \\\"Stopped\\\");",
            "            telemetry.update();",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptVuMarkIdentificationWebcam": {
        "prefix": "conceptVuMarkIdentificationWebcam",
        "description": "            See if any of the instances of {@link relicTemplate} are currently visible.\n            {@link RelicRecoveryVuMark} is an enum which can have the following values:\n            UNKNOWN, LEFT, CENTER, and RIGHT. When a VuMark is visible, something other than\n            UNKNOWN will be returned by {@link RelicRecoveryVuMark#from(VuforiaTrackable)}.\n             ",
        "body": [
            "public class ConceptVuMarkIdentificationWebcam extends LinearOpMode {",
            "",
            "    public static final String TAG = \"Vuforia VuMark Sample\\\";",
            "",
            "    OpenGLMatrix lastLocation = null;",
            "",
            "    /**",
            "     * {@link #vuforia} is the variable we will use to store our instance of the Vuforia",
            "     * localization engine.",
            "     */",
            "    VuforiaLocalizer vuforia;",
            "",
            "    /**",
            "     * This is the webcam we are to use. As with other hardware devices such as motors and",
            "     * servos, this device is identified using the robot configuration tool in the FTC application.",
            "     */",
            "    WebcamName webcamName;",
            "",
            "    @Override public void runOpMode() {",
            "",
            "        /*",
            "         * Retrieve the camera we are to use.",
            "         */",
            "        webcamName = hardwareMap.get(WebcamName.class, \\\"Webcam 1\\\");",
            "",
            "        /*",
            "         * To start up Vuforia, tell it the view that we wish to use for camera monitor (on the RC phone);",
            "         * If no camera monitor is desired, use the parameterless constructor instead (commented out below).",
            "         */",
            "        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\\\"cameraMonitorViewId\\\", \\\"id\\\", hardwareMap.appContext.getPackageName());",
            "        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId);",
            "",
            "        // OR...  Do Not Activate the Camera Monitor View, to save power",
            "        // VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();",
            "",
            "        /*",
            "         * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which",
            "         * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.",
            "         * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer",
            "         * web site at https://developer.vuforia.com/license-manager.",
            "         *",
            "         * Vuforia license keys are always 380 characters long, and look as if they contain mostly",
            "         * random data. As an example, here is a example of a fragment of a valid key:",
            "         *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...",
            "         * Once you've obtained a license key, copy the string from the Vuforia web site",
            "         * and paste it in to your code on the next line, between the double quotes.",
            "         */",
            "        parameters.vuforiaLicenseKey = \\\" -- YOUR NEW VUFORIA KEY GOES HERE  --- \\\";",
            "",
            "",
            "        /**",
            "         * We also indicate which camera on the RC we wish to use. For pedagogical purposes,",
            "         * we use the same logic as in {@link ConceptVuforiaNavigationWebcam}.",
            "         */",
            "        parameters.cameraName = webcamName;",
            "        this.vuforia = ClassFactory.getInstance().createVuforia(parameters);",
            "",
            "        /**",
            "         * Load the data set containing the VuMarks for Relic Recovery. There's only one trackable",
            "         * in this data set: all three of the VuMarks in the game were created from this one template,",
            "         * but differ in their instance id information.",
            "         * @see VuMarkInstanceId",
            "         */",
            "        VuforiaTrackables relicTrackables = this.vuforia.loadTrackablesFromAsset(\\\"RelicVuMark\\\");",
            "        VuforiaTrackable relicTemplate = relicTrackables.get(0);",
            "        relicTemplate.setName(\\\"relicVuMarkTemplate\\\"); // can help in debugging; otherwise not necessary",
            "",
            "        telemetry.addData(\\\">\\\", \\\"Press Play to start\\\");",
            "        telemetry.update();",
            "        waitForStart();",
            "",
            "        relicTrackables.activate();",
            "",
            "        while (opModeIsActive()) {",
            "",
            "            /**",
            "             * See if any of the instances of {@link relicTemplate} are currently visible.",
            "             * {@link RelicRecoveryVuMark} is an enum which can have the following values:",
            "             * UNKNOWN, LEFT, CENTER, and RIGHT. When a VuMark is visible, something other than",
            "             * UNKNOWN will be returned by {@link RelicRecoveryVuMark#from(VuforiaTrackable)}.",
            "             */",
            "            RelicRecoveryVuMark vuMark = RelicRecoveryVuMark.from(relicTemplate);",
            "            if (vuMark != RelicRecoveryVuMark.UNKNOWN) {",
            "",
            "                /* Found an instance of the template. In the actual game, you will probably",
            "                 * loop until this condition occurs, then move on to act accordingly depending",
            "                 * on which VuMark was visible. */",
            "                telemetry.addData(\\\"VuMark\\\", \\\"%s visible\\\", vuMark);",
            "",
            "                /* For fun, we also exhibit the navigational pose. In the Relic Recovery game,",
            "                 * it is perhaps unlikely that you will actually need to act on this pose information, but",
            "                 * we illustrate it nevertheless, for completeness. */",
            "                OpenGLMatrix pose = ((VuforiaTrackableDefaultListener)relicTemplate.getListener()).getFtcCameraFromTarget();",
            "                telemetry.addData(\\\"Pose\\\", format(pose));",
            "",
            "                /* We further illustrate how to decompose the pose into useful rotational and",
            "                 * translational components */",
            "                if (pose != null) {",
            "                    VectorF trans = pose.getTranslation();",
            "                    Orientation rot = Orientation.getOrientation(pose, AxesReference.EXTRINSIC, AxesOrder.XYZ, AngleUnit.DEGREES);",
            "",
            "                    // Extract the X, Y, and Z components of the offset of the target relative to the robot",
            "                    double tX = trans.get(0);",
            "                    double tY = trans.get(1);",
            "                    double tZ = trans.get(2);",
            "",
            "                    // Extract the rotational components of the target relative to the robot",
            "                    double rX = rot.firstAngle;",
            "                    double rY = rot.secondAngle;",
            "                    double rZ = rot.thirdAngle;",
            "                }",
            "            }",
            "            else {",
            "                telemetry.addData(\\\"VuMark\\\", \\\"not visible\\\");",
            "            }",
            "",
            "            telemetry.update();",
            "        }",
            "    }",
            "",
            "    String format(OpenGLMatrix transformationMatrix) {",
            "        return (transformationMatrix != null) ? transformationMatrix.formatAsTransform() : \\\"null\\\";",
            "    }",
            "}",
            ""
        ]
    },
    "PushbotTeleopTank Iterative": {
        "prefix": "pushbotTeleopTankIterative",
        "description": "This file provides basic Telop driving for a Pushbot robot.\nThe code is structured as an Iterative OpMode\n\nThis OpMode uses the common Pushbot hardware class to define the devices on the robot.\nAll device access is managed through the HardwarePushbot class.\n\nThis particular OpMode executes a basic Tank Drive Teleop for a PushBot\nIt raises and lowers the claw using the Gampad Y and A buttons respectively.\nIt also opens and closes the claws slowly using the left and right Bumper buttons.\n\n\n ",
        "body": [
            "public class PushbotTeleopTank_Iterative extends OpMode{",
            "",
            "    /* Declare OpMode members. */",
            "    HardwarePushbot robot       = new HardwarePushbot(); // use the class created to define a Pushbot's hardware",
            "    double          clawOffset  = 0.0 ;                  // Servo mid position",
            "    final double    CLAW_SPEED  = 0.02 ;                 // sets rate to move servo",
            "",
            "    /*",
            "     * Code to run ONCE when the driver hits INIT",
            "     */",
            "    @Override",
            "    public void init() {",
            "        /* Initialize the hardware variables.",
            "         * The init() method of the hardware class does all the work here",
            "         */",
            "        robot.init(hardwareMap);",
            "",
            "        // Send telemetry message to signify robot waiting;",
            "        telemetry.addData(\"Say\\\", \\\"Hello Driver\\\");    //",
            "    }",
            "",
            "    /*",
            "     * Code to run REPEATEDLY after the driver hits INIT, but before they hit PLAY",
            "     */",
            "    @Override",
            "    public void init_loop() {",
            "    }",
            "",
            "    /*",
            "     * Code to run ONCE when the driver hits PLAY",
            "     */",
            "    @Override",
            "    public void start() {",
            "    }",
            "",
            "    /*",
            "     * Code to run REPEATEDLY after the driver hits PLAY but before they hit STOP",
            "     */",
            "    @Override",
            "    public void loop() {",
            "        double left;",
            "        double right;",
            "",
            "        // Run wheels in tank mode (note: The joystick goes negative when pushed forwards, so negate it)",
            "        left = -gamepad1.left_stick_y;",
            "        right = -gamepad1.right_stick_y;",
            "",
            "        robot.leftDrive.setPower(left);",
            "        robot.rightDrive.setPower(right);",
            "",
            "        // Use gamepad left & right Bumpers to open and close the claw",
            "        if (gamepad1.right_bumper)",
            "            clawOffset += CLAW_SPEED;",
            "        else if (gamepad1.left_bumper)",
            "            clawOffset -= CLAW_SPEED;",
            "",
            "        // Move both servos to new position.  Assume servos are mirror image of each other.",
            "        clawOffset = Range.clip(clawOffset, -0.5, 0.5);",
            "        robot.leftClaw.setPosition(robot.MID_SERVO + clawOffset);",
            "        robot.rightClaw.setPosition(robot.MID_SERVO - clawOffset);",
            "",
            "        // Use gamepad buttons to move the arm up (Y) and down (A)",
            "        if (gamepad1.y)",
            "            robot.leftArm.setPower(robot.ARM_UP_POWER);",
            "        else if (gamepad1.a)",
            "            robot.leftArm.setPower(robot.ARM_DOWN_POWER);",
            "        else",
            "            robot.leftArm.setPower(0.0);",
            "",
            "        // Send telemetry message to signify robot running;",
            "        telemetry.addData(\\\"claw\\\",  \\\"Offset = %.2f\\\", clawOffset);",
            "        telemetry.addData(\\\"left\\\",  \\\"%.2f\\\", left);",
            "        telemetry.addData(\\\"right\\\", \\\"%.2f\\\", right);",
            "    }",
            "",
            "    /*",
            "     * Code to run ONCE after the driver hits STOP",
            "     */",
            "    @Override",
            "    public void stop() {",
            "    }",
            "}",
            ""
        ]
    },
    "SampleRevBlinkinLedDriver": {
        "prefix": "sampleRevBlinkinLedDriver",
        "description": "No Description Given",
        "body": [
            "public class SampleRevBlinkinLedDriver extends OpMode {",
            "",
            "    /*",
            "     * Change the pattern every 10 seconds in AUTO mode.",
            "     */",
            "    private final static int LED_PERIOD = 10;",
            "",
            "    /*",
            "     * Rate limit gamepad button presses to every 500ms.",
            "     */",
            "    private final static int GAMEPAD_LOCKOUT = 500;",
            "",
            "    RevBlinkinLedDriver blinkinLedDriver;",
            "    RevBlinkinLedDriver.BlinkinPattern pattern;",
            "",
            "    Telemetry.Item patternName;",
            "    Telemetry.Item display;",
            "    DisplayKind displayKind;",
            "    Deadline ledCycleDeadline;",
            "    Deadline gamepadRateLimit;",
            "",
            "    protected enum DisplayKind {",
            "        MANUAL,",
            "        AUTO",
            "    }",
            "",
            "    @Override",
            "    public void init()",
            "    {",
            "        displayKind = DisplayKind.AUTO;",
            "",
            "        blinkinLedDriver = hardwareMap.get(RevBlinkinLedDriver.class, \"blinkin\\\");",
            "        pattern = RevBlinkinLedDriver.BlinkinPattern.RAINBOW_RAINBOW_PALETTE;",
            "        blinkinLedDriver.setPattern(pattern);",
            "",
            "        display = telemetry.addData(\\\"Display Kind: \\\", displayKind.toString());",
            "        patternName = telemetry.addData(\\\"Pattern: \\\", pattern.toString());",
            "",
            "        ledCycleDeadline = new Deadline(LED_PERIOD, TimeUnit.SECONDS);",
            "        gamepadRateLimit = new Deadline(GAMEPAD_LOCKOUT, TimeUnit.MILLISECONDS);",
            "    }",
            "",
            "    @Override",
            "    public void loop()",
            "    {",
            "        handleGamepad();",
            "",
            "        if (displayKind == DisplayKind.AUTO) {",
            "            doAutoDisplay();",
            "        } else {",
            "            /*",
            "             * MANUAL mode: Nothing to do, setting the pattern as a result of a gamepad event.",
            "             */",
            "        }",
            "    }",
            "",
            "    /*",
            "     * handleGamepad",
            "     *",
            "     * Responds to a gamepad button press.  Demonstrates rate limiting for",
            "     * button presses.  If loop() is called every 10ms and and you don't rate",
            "     * limit, then any given button press may register as multiple button presses,",
            "     * which in this application is problematic.",
            "     *",
            "     * A: Manual mode, Right bumper displays the next pattern, left bumper displays the previous pattern.",
            "     * B: Auto mode, pattern cycles, changing every LED_PERIOD seconds.",
            "     */",
            "    protected void handleGamepad()",
            "    {",
            "        if (!gamepadRateLimit.hasExpired()) {",
            "            return;",
            "        }",
            "",
            "        if (gamepad1.a) {",
            "            setDisplayKind(DisplayKind.MANUAL);",
            "            gamepadRateLimit.reset();",
            "        } else if (gamepad1.b) {",
            "            setDisplayKind(DisplayKind.AUTO);",
            "            gamepadRateLimit.reset();",
            "        } else if ((displayKind == DisplayKind.MANUAL) && (gamepad1.left_bumper)) {",
            "            pattern = pattern.previous();",
            "            displayPattern();",
            "            gamepadRateLimit.reset();",
            "        } else if ((displayKind == DisplayKind.MANUAL) && (gamepad1.right_bumper)) {",
            "            pattern = pattern.next();",
            "            displayPattern();",
            "            gamepadRateLimit.reset();",
            "        }",
            "    }",
            "",
            "    protected void setDisplayKind(DisplayKind displayKind)",
            "    {",
            "        this.displayKind = displayKind;",
            "        display.setValue(displayKind.toString());",
            "    }",
            "",
            "    protected void doAutoDisplay()",
            "    {",
            "        if (ledCycleDeadline.hasExpired()) {",
            "            pattern = pattern.next();",
            "            displayPattern();",
            "            ledCycleDeadline.reset();",
            "        }",
            "    }",
            "",
            "    protected void displayPattern()",
            "    {",
            "        blinkinLedDriver.setPattern(pattern);",
            "        patternName.setValue(pattern.toString());",
            "    }",
            "}",
            ""
        ]
    },
    "PushbotAutoDriveToLine Linear": {
        "prefix": "pushbotAutoDriveToLineLinear",
        "description": "This file illustrates the concept of driving up to a line and then stopping.\nIt uses the common Pushbot hardware class to define the drive on the robot.\nThe code is structured as a LinearOpMode\n\nThe code shows using two different light sensors:\n  The Primary sensor shown in this code is a legacy NXT Light sensor (called \"sensor_light\")\n  Alternative \"commented out\" code uses a MR Optical Distance Sensor (called \"sensor_ods\")\n  instead of the LEGO sensor.  Chose to use one sensor or the other.\n\n  Setting the correct WHITE_THRESHOLD value is key to stopping correctly.\n  This should be set half way between the light and dark values.\n  These values can be read on the screen once the OpMode has been INIT, but before it is STARTED.\n  Move the senso on asnd off the white line and not the min and max readings.\n  Edit this code to make WHITE_THRESHOLD half way between the min and max.\n\n\n ",
        "body": [
            "public class PushbotAutoDriveToLine_Linear extends LinearOpMode {",
            "",
            "    /* Declare OpMode members. */",
            "    HardwarePushbot         robot   = new HardwarePushbot();   // Use a Pushbot's hardware",
            "    LightSensor             lightSensor;      // Primary LEGO Light sensor,",
            "    // OpticalDistanceSensor   lightSensor;   // Alternative MR ODS sensor",
            "",
            "    static final double     WHITE_THRESHOLD = 0.2;  // spans between 0.1 - 0.5 from dark to light",
            "    static final double     APPROACH_SPEED  = 0.5;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        /* Initialize the drive system variables.",
            "         * The init() method of the hardware class does all the work here",
            "         */",
            "        robot.init(hardwareMap);",
            "",
            "        // If there are encoders connected, switch to RUN_USING_ENCODER mode for greater accuracy",
            "        // robot.leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "        // robot.rightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "",
            "        // get a reference to our Light Sensor object.",
            "        lightSensor = hardwareMap.lightSensor.get(\"sensor_light\\\");                // Primary LEGO Light Sensor",
            "        //  lightSensor = hardwareMap.opticalDistanceSensor.get(\\\"sensor_ods\\\");  // Alternative MR ODS sensor.",
            "",
            "        // turn on LED of light sensor.",
            "        lightSensor.enableLed(true);",
            "",
            "        // Send telemetry message to signify robot waiting;",
            "        telemetry.addData(\\\"Status\\\", \\\"Ready to run\\\");    //",
            "        telemetry.update();",
            "",
            "        // Wait for the game to start (driver presses PLAY)",
            "        // Abort this loop is started or stopped.",
            "        while (!(isStarted() || isStopRequested())) {",
            "",
            "            // Display the light level while we are waiting to start",
            "            telemetry.addData(\\\"Light Level\\\", lightSensor.getLightDetected());",
            "            telemetry.update();",
            "            idle();",
            "        }",
            "",
            "        // Start the robot moving forward, and then begin looking for a white line.",
            "        robot.leftDrive.setPower(APPROACH_SPEED);",
            "        robot.rightDrive.setPower(APPROACH_SPEED);",
            "",
            "        // run until the white line is seen OR the driver presses STOP;",
            "        while (opModeIsActive() && (lightSensor.getLightDetected() < WHITE_THRESHOLD)) {",
            "",
            "            // Display the light level while we are looking for the line",
            "            telemetry.addData(\\\"Light Level\\\",  lightSensor.getLightDetected());",
            "            telemetry.update();",
            "        }",
            "",
            "        // Stop all motors",
            "        robot.leftDrive.setPower(0);",
            "        robot.rightDrive.setPower(0);",
            "    }",
            "}",
            ""
        ]
    },
    "SensorMRIrSeeker": {
        "prefix": "sensorMRIrSeeker",
        "description": "No Description Given",
        "body": [
            "public class SensorMRIrSeeker extends LinearOpMode {",
            "",
            "  @Override",
            "  public void runOpMode() {",
            "",
            "    IrSeekerSensor irSeeker;    // Hardware Device Object",
            "",
            "    // get a reference to our GyroSensor object.",
            "    irSeeker = hardwareMap.get(IrSeekerSensor.class, \"sensor_ir\\\");",
            "",
            "    // wait for the start button to be pressed.",
            "    waitForStart();",
            "",
            "    while (opModeIsActive())  {",
            "",
            "      // Ensure we have a IR signal",
            "      if (irSeeker.signalDetected())",
            "      {",
            "        // Display angle and strength",
            "        telemetry.addData(\\\"Angle\\\",    irSeeker.getAngle());",
            "        telemetry.addData(\\\"Strength\\\", irSeeker.getStrength());",
            "      }",
            "      else",
            "      {",
            "        // Display loss of signal",
            "        telemetry.addData(\\\"Seeker\\\", \\\"Signal Lost\\\");",
            "      }",
            "",
            "      telemetry.update();",
            "    }",
            "  }",
            "}",
            ""
        ]
    },
    "SensorColor": {
        "prefix": "sensorColor",
        "description": "  The runOpMode() method is the root of this Op Mode, as it is in all LinearOpModes.\n  Our implementation here, though is a bit unusual: we've decided to put all the actual work\n  in the runSample() method rather than directly in runOpMode() itself. The reason we do that is\n  that in this sample we're changing the background color of the robot controller screen as the\n  Op Mode runs, and we want to be able toguarantee* that we restore it to something reasonable\n  and palatable when the Op Mode ends. The simplest way to do that is to use a try...finally\n  block around the main, core logic, and an easy way to make that all clear was to separate\n  the former from the latter in separate methods.\n   ",
        "body": [
            "public class SensorColor extends LinearOpMode {",
            "",
            "  /** The colorSensor field will contain a reference to our color sensor hardware object */",
            "  NormalizedColorSensor colorSensor;",
            "",
            "  /** The relativeLayout field is used to aid in providing interesting visual feedback",
            "   * in this sample application; you probably *don't* need this when you use a color sensor on your",
            "   * robot. Note that you won't see anything change on the Driver Station, only on the Robot Controller. */",
            "  View relativeLayout;",
            "",
            "  /**",
            "   * The runOpMode() method is the root of this Op Mode, as it is in all LinearOpModes.",
            "   * Our implementation here, though is a bit unusual: we've decided to put all the actual work",
            "   * in the runSample() method rather than directly in runOpMode() itself. The reason we do that is",
            "   * that in this sample we're changing the background color of the robot controller screen as the",
            "   * Op Mode runs, and we want to be able to *guarantee* that we restore it to something reasonable",
            "   * and palatable when the Op Mode ends. The simplest way to do that is to use a try...finally",
            "   * block around the main, core logic, and an easy way to make that all clear was to separate",
            "   * the former from the latter in separate methods.",
            "   */",
            "  @Override public void runOpMode() {",
            "",
            "    // Get a reference to the RelativeLayout so we can later change the background",
            "    // color of the Robot Controller app to match the hue detected by the RGB sensor.",
            "    int relativeLayoutId = hardwareMap.appContext.getResources().getIdentifier(\"RelativeLayout\\\", \\\"id\\\", hardwareMap.appContext.getPackageName());",
            "    relativeLayout = ((Activity) hardwareMap.appContext).findViewById(relativeLayoutId);",
            "",
            "    try {",
            "      runSample(); // actually execute the sample",
            "    } finally {",
            "      // On the way out, *guarantee* that the background is reasonable. It doesn't actually start off",
            "      // as pure white, but it's too much work to dig out what actually was used, and this is good",
            "      // enough to at least make the screen reasonable again.",
            "      // Set the panel back to the default color",
            "      relativeLayout.post(new Runnable() {",
            "        public void run() {",
            "          relativeLayout.setBackgroundColor(Color.WHITE);",
            "        }",
            "      });",
            "      }",
            "  }",
            "",
            "  protected void runSample() {",
            "    // You can give the sensor a gain value, will be multiplied by the sensor's raw value before the",
            "    // normalized color values are calculated. Color sensors (especially the REV Color Sensor V3)",
            "    // can give very low values (depending on the lighting conditions), which only use a small part",
            "    // of the 0-1 range that is available for the red, green, and blue values. In brighter conditions,",
            "    // you should use a smaller gain than in dark conditions. If your gain is too high, all of the",
            "    // colors will report at or near 1, and you won't be able to determine what color you are",
            "    // actually looking at. For this reason, it's better to err on the side of a lower gain",
            "    // (but always greater than  or equal to 1).",
            "    float gain = 2;",
            "",
            "    // Once per loop, we will update this hsvValues array. The first element (0) will contain the",
            "    // hue, the second element (1) will contain the saturation, and the third element (2) will",
            "    // contain the value. See http://web.archive.org/web/20190311170843/https://infohost.nmt.edu/tcc/help/pubs/colortheory/web/hsv.html",
            "    // for an explanation of HSV color.",
            "    final float[] hsvValues = new float[3];",
            "",
            "    // xButtonPreviouslyPressed and xButtonCurrentlyPressed keep track of the previous and current",
            "    // state of the X button on the gamepad",
            "    boolean xButtonPreviouslyPressed = false;",
            "    boolean xButtonCurrentlyPressed = false;",
            "",
            "    // Get a reference to our sensor object. It's recommended to use NormalizedColorSensor over",
            "    // ColorSensor, because NormalizedColorSensor consistently gives values between 0 and 1, while",
            "    // the values you get from ColorSensor are dependent on the specific sensor you're using.",
            "    colorSensor = hardwareMap.get(NormalizedColorSensor.class, \\\"sensor_color\\\");",
            "",
            "    // If possible, turn the light on in the beginning (it might already be on anyway,",
            "    // we just make sure it is if we can).",
            "    if (colorSensor instanceof SwitchableLight) {",
            "      ((SwitchableLight)colorSensor).enableLight(true);",
            "    }",
            "",
            "    // Wait for the start button to be pressed.",
            "    waitForStart();",
            "",
            "    // Loop until we are asked to stop",
            "    while (opModeIsActive()) {",
            "      // Explain basic gain information via telemetry",
            "      telemetry.addLine(\\\"Hold the A button on gamepad 1 to increase gain, or B to decrease it.\\n\\\");",
            "      telemetry.addLine(\\\"Higher gain values mean that the sensor will report larger numbers for Red, Green, and Blue, and Value\\n\\\");",
            "",
            "      // Update the gain value if either of the A or B gamepad buttons is being held",
            "      if (gamepad1.a) {",
            "        // Only increase the gain by a small amount, since this loop will occur multiple times per second.",
            "        gain += 0.005;",
            "      } else if (gamepad1.b && gain > 1) { // A gain of less than 1 will make the values smaller, which is not helpful.",
            "        gain -= 0.005;",
            "      }",
            "",
            "      // Show the gain value via telemetry",
            "      telemetry.addData(\\\"Gain\\\", gain);",
            "",
            "      // Tell the sensor our desired gain value (normally you would do this during initialization,",
            "      // not during the loop)",
            "      colorSensor.setGain(gain);",
            "",
            "      // Check the status of the X button on the gamepad",
            "      xButtonCurrentlyPressed = gamepad1.x;",
            "",
            "      // If the button state is different than what it was, then act",
            "      if (xButtonCurrentlyPressed != xButtonPreviouslyPressed) {",
            "        // If the button is (now) down, then toggle the light",
            "        if (xButtonCurrentlyPressed) {",
            "          if (colorSensor instanceof SwitchableLight) {",
            "            SwitchableLight light = (SwitchableLight)colorSensor;",
            "            light.enableLight(!light.isLightOn());",
            "          }",
            "        }",
            "      }",
            "      xButtonPreviouslyPressed = xButtonCurrentlyPressed;",
            "",
            "      // Get the normalized colors from the sensor",
            "      NormalizedRGBA colors = colorSensor.getNormalizedColors();",
            "",
            "      /* Use telemetry to display feedback on the driver station. We show the red, green, and blue",
            "       * normalized values from the sensor (in the range of 0 to 1), as well as the equivalent",
            "       * HSV (hue, saturation and value) values. See http://web.archive.org/web/20190311170843/https://infohost.nmt.edu/tcc/help/pubs/colortheory/web/hsv.html",
            "       * for an explanation of HSV color. */",
            "",
            "      // Update the hsvValues array by passing it to Color.colorToHSV()",
            "      Color.colorToHSV(colors.toColor(), hsvValues);",
            "",
            "      telemetry.addLine()",
            "              .addData(\\\"Red\\\", \\\"%.3f\\\", colors.red)",
            "              .addData(\\\"Green\\\", \\\"%.3f\\\", colors.green)",
            "              .addData(\\\"Blue\\\", \\\"%.3f\\\", colors.blue);",
            "      telemetry.addLine()",
            "              .addData(\\\"Hue\\\", \\\"%.3f\\\", hsvValues[0])",
            "              .addData(\\\"Saturation\\\", \\\"%.3f\\\", hsvValues[1])",
            "              .addData(\\\"Value\\\", \\\"%.3f\\\", hsvValues[2]);",
            "      telemetry.addData(\\\"Alpha\\\", \\\"%.3f\\\", colors.alpha);",
            "",
            "      /* If this color sensor also has a distance sensor, display the measured distance.",
            "       * Note that the reported distance is only useful at very close range, and is impacted by",
            "       * ambient light and surface reflectivity. */",
            "      if (colorSensor instanceof DistanceSensor) {",
            "        telemetry.addData(\\\"Distance (cm)\\\", \\\"%.3f\\\", ((DistanceSensor) colorSensor).getDistance(DistanceUnit.CM));",
            "      }",
            "",
            "      telemetry.update();",
            "",
            "      // Change the Robot Controller's background color to match the color detected by the color sensor.",
            "      relativeLayout.post(new Runnable() {",
            "        public void run() {",
            "          relativeLayout.setBackgroundColor(Color.HSVToColor(hsvValues));",
            "        }",
            "      });",
            "    }",
            "  }",
            "}",
            ""
        ]
    },
    "SensorREV2mDistance": {
        "prefix": "sensorREV2mDistance",
        "description": "{@link SensorREV2mDistance} illustrates how to use the REV Robotics\nTime-of-Flight Range Sensor.\n\nThe op mode assumes that the range sensor is configured with a name of \"sensor_range\".\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list\n\n@see <a href=\"http://revrobotics.com\">REV Robotics Web Page</a>\n ",
        "body": [
            "public class SensorREV2mDistance extends LinearOpMode {",
            "",
            "    private DistanceSensor sensorRange;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "        // you can use this as a regular DistanceSensor.",
            "        sensorRange = hardwareMap.get(DistanceSensor.class, \"sensor_range\\\");",
            "",
            "        // you can also cast this to a Rev2mDistanceSensor if you want to use added",
            "        // methods associated with the Rev2mDistanceSensor class.",
            "        Rev2mDistanceSensor sensorTimeOfFlight = (Rev2mDistanceSensor)sensorRange;",
            "",
            "        telemetry.addData(\\\">>\\\", \\\"Press start to continue\\\");",
            "        telemetry.update();",
            "",
            "        waitForStart();",
            "        while(opModeIsActive()) {",
            "            // generic DistanceSensor methods.",
            "            telemetry.addData(\\\"deviceName\\\",sensorRange.getDeviceName() );",
            "            telemetry.addData(\\\"range\\\", String.format(\\\"%.01f mm\\\", sensorRange.getDistance(DistanceUnit.MM)));",
            "            telemetry.addData(\\\"range\\\", String.format(\\\"%.01f cm\\\", sensorRange.getDistance(DistanceUnit.CM)));",
            "            telemetry.addData(\\\"range\\\", String.format(\\\"%.01f m\\\", sensorRange.getDistance(DistanceUnit.METER)));",
            "            telemetry.addData(\\\"range\\\", String.format(\\\"%.01f in\\\", sensorRange.getDistance(DistanceUnit.INCH)));",
            "",
            "            // Rev2mDistanceSensor specific methods.",
            "            telemetry.addData(\\\"ID\\\", String.format(\\\"%x\\\", sensorTimeOfFlight.getModelID()));",
            "            telemetry.addData(\\\"did time out\\\", Boolean.toString(sensorTimeOfFlight.didTimeoutOccur()));",
            "",
            "            telemetry.update();",
            "        }",
            "    }",
            "",
            "}"
        ]
    },
    "SensorMROpticalDistance": {
        "prefix": "sensorMROpticalDistance",
        "description": "No Description Given",
        "body": [
            "public class SensorMROpticalDistance extends LinearOpMode {",
            "",
            "  OpticalDistanceSensor odsSensor;  // Hardware Device Object",
            "",
            "  @Override",
            "  public void runOpMode() {",
            "",
            "    // get a reference to our Light Sensor object.",
            "    odsSensor = hardwareMap.get(OpticalDistanceSensor.class, \"sensor_ods\\\");",
            "",
            "    // wait for the start button to be pressed.",
            "    waitForStart();",
            "",
            "    // while the op mode is active, loop and read the light levels.",
            "    // Note we use opModeIsActive() as our loop condition because it is an interruptible method.",
            "    while (opModeIsActive()) {",
            "",
            "      // send the info back to driver station using telemetry function.",
            "      telemetry.addData(\\\"Raw\\\",    odsSensor.getRawLightDetected());",
            "      telemetry.addData(\\\"Normal\\\", odsSensor.getLightDetected());",
            "",
            "      telemetry.update();",
            "    }",
            "  }",
            "}",
            ""
        ]
    },
    "SensorDIO": {
        "prefix": "sensorDIO",
        "description": "No Description Given",
        "body": [
            "public class SensorDIO extends LinearOpMode {",
            "",
            "final int BLUE_LED_CHANNEL = 0;",
            "final int RED_LED_CHANNEL = 1;",
            "",
            "  @Override",
            "  public void runOpMode() {",
            "",
            "    boolean               inputPin;             // Input State",
            "    boolean               outputPin;            // Output State",
            "    DeviceInterfaceModule dim;                  // Device Object",
            "    DigitalChannel        digIn;                // Device Object",
            "    DigitalChannel        digOut;               // Device Object",
            "",
            "    // get a reference to a Modern Robotics DIM, and IO channels.",
            "    dim = hardwareMap.get(DeviceInterfaceModule.class, \"dim\\\");   //  Use generic form of device mapping",
            "    digIn  = hardwareMap.get(DigitalChannel.class, \\\"digin\\\");     //  Use generic form of device mapping",
            "    digOut = hardwareMap.get(DigitalChannel.class, \\\"digout\\\");    //  Use generic form of device mapping",
            "",
            "    digIn.setMode(DigitalChannel.Mode.INPUT);          // Set the direction of each channel",
            "    digOut.setMode(DigitalChannel.Mode.OUTPUT);",
            "",
            "    // wait for the start button to be pressed.",
            "    telemetry.addData(\\\">\\\", \\\"Press play, and then user X button to set DigOut\\\");",
            "    telemetry.update();",
            "    waitForStart();",
            "",
            "    while (opModeIsActive())  {",
            "",
            "        outputPin = gamepad1.x ;        //  Set the output pin based on x button",
            "        digOut.setState(outputPin);",
            "        inputPin = digIn.getState();    //  Read the input pin",
            "",
            "        // Display input pin state on LEDs",
            "        if (inputPin) {",
            "            dim.setLED(RED_LED_CHANNEL, true);",
            "            dim.setLED(BLUE_LED_CHANNEL, false);",
            "        }",
            "        else {",
            "            dim.setLED(RED_LED_CHANNEL, false);",
            "            dim.setLED(BLUE_LED_CHANNEL, true);",
            "        }",
            "",
            "        telemetry.addData(\\\"Output\\\", outputPin );",
            "        telemetry.addData(\\\"Input\\\", inputPin );",
            "        telemetry.addData(\\\"LED\\\",   inputPin ? \\\"Red\\\" : \\\"Blue\\\" );",
            "        telemetry.update();",
            "    }",
            "  }",
            "}",
            ""
        ]
    },
    "SensorBNO055IMUCalibration": {
        "prefix": "sensorBNO055IMUCalibration",
        "description": "{@link SensorBNO055IMUCalibration} calibrates the IMU accelerometer per\n\"Section 3.11 Calibration\" of the BNO055 specification.\n\n Note: this is a Legacy example that will not work with newer Control/Expansion Hubs that use a different IMU\n Please use the new SensorIMUOrthogonal or SensorIMUNonOrthogonal samples for a more universal IMU interface.\n\n<p>Manual calibration of the IMU is definitely NOT necessary: except for the magnetometer\n(which is not used by the default {@link BNO055IMU.SensorMode#IMU\nSensorMode#IMU}), the BNO055 is internally self-calibrating and thus can be very successfully\nused without manual intervention. That said, performing a one-time calibration, saving the\nresults persistently, then loading them again at each run can help reduce the time that automatic\ncalibration requires.</p>\n\n<p>This summary of the calibration process, from <a href=\"http://iotdk.intel.com/docs/master/upm/classupm_1_1_b_n_o055.html\">\nIntel</a>, is informative:</p>\n\n<p>\"This device requires calibration in order to operate accurately. [...] Calibration data is\nlost on a power cycle. See one of the examples for a description of how to calibrate the device,\nbut in essence:</p>\n\n<p>There is a calibration status register available [...] that returns the calibration status\nof the accelerometer (ACC), magnetometer (MAG), gyroscope (GYR), and overall system (SYS).\nEach of these values range from 0 (uncalibrated) to 3 (fully calibrated). Calibration [ideally]\ninvolves certain motions to get all 4 values at 3. The motions are as follows (though see the\ndatasheet for more information):</p>\n\n<li>\n    <ol>GYR: Simply let the sensor sit flat for a few seconds.</ol>\n    <ol>ACC: Move the sensor in various positions. Start flat, then rotate slowly by 45\n             degrees, hold for a few seconds, then continue rotating another 45 degrees and\n             hold, etc. 6 or more movements of this type may be required. You can move through\n             any axis you desire, but make sure that the device is lying at least once\n             perpendicular to the x, y, and z axis.</ol>\n    <ol>MAG: Move slowly in a figure 8 pattern in the air, until the calibration values reaches 3.</ol>\n    <ol>SYS: This will usually reach 3 when the other items have also reached 3. If not, continue\n             slowly moving the device though various axes until it does.\"</ol>\n</li>\n\n<p>To calibrate the IMU, run this sample opmode with a gamepad attached to the driver station.\nOnce the IMU has reached sufficient calibration as reported on telemetry, press the 'A'\nbutton on the gamepad to write the calibration to a file. That file can then be indicated\nlater when running an opmode which uses the IMU.</p>\n\n<p>Note: if your intended uses of the IMU do not include use of all its sensors (for exmaple,\nyou might not use the magnetometer), then it makes little sense for you to wait for full\ncalibration of the sensors you are not using before saving the calibration data. Indeed,\nit appears that in a SensorMode that doesn't use the magnetometer (for example), the\nmagnetometer cannot actually be calibrated.</p>\n\n@see AdafruitBNO055IMU\n@see BNO055IMU.Parameters#calibrationDataFile\n@see <a href=\"https://www.bosch-sensortec.com/bst/products/all_products/bno055\">BNO055 product page</a>\n@see <a href=\"https://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST_BNO055_DS000_14.pdf\">BNO055 specification</a>\n ",
        "body": [
            "public class SensorBNO055IMUCalibration extends LinearOpMode",
            "    {",
            "    //----------------------------------------------------------------------------------------------",
            "    // State",
            "    //----------------------------------------------------------------------------------------------",
            "",
            "    // Our sensors, motors, and other devices go here, along with other long term state",
            "    BNO055IMU imu;",
            "",
            "    // State used for updating telemetry",
            "    Orientation angles;",
            "",
            "    //----------------------------------------------------------------------------------------------",
            "    // Main logic",
            "    //----------------------------------------------------------------------------------------------",
            "",
            "    @Override public void runOpMode() {",
            "",
            "        telemetry.log().setCapacity(12);",
            "        telemetry.log().add(\"\\\");",
            "        telemetry.log().add(\\\"Please refer to the calibration instructions\\\");",
            "        telemetry.log().add(\\\"contained in the Adafruit IMU calibration\\\");",
            "        telemetry.log().add(\\\"sample opmode.\\\");",
            "        telemetry.log().add(\\\"\\\");",
            "        telemetry.log().add(\\\"When sufficient calibration has been reached,\\\");",
            "        telemetry.log().add(\\\"press the 'A' button to write the current\\\");",
            "        telemetry.log().add(\\\"calibration data to a file.\\\");",
            "        telemetry.log().add(\\\"\\\");",
            "",
            "        // We are expecting the IMU to be attached to an I2C port on a Core Device Interface Module and named \\\"imu\\\".",
            "        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();",
            "        parameters.loggingEnabled = true;",
            "        parameters.loggingTag     = \\\"IMU\\\";",
            "        imu = hardwareMap.get(BNO055IMU.class, \\\"imu\\\");",
            "        imu.initialize(parameters);",
            "",
            "        composeTelemetry();",
            "        telemetry.log().add(\\\"Waiting for start...\\\");",
            "",
            "        // Wait until we're told to go",
            "        while (!isStarted()) {",
            "            telemetry.update();",
            "            idle();",
            "        }",
            "",
            "        telemetry.log().add(\\\"...started...\\\");",
            "",
            "        while (opModeIsActive()) {",
            "",
            "            if (gamepad1.a) {",
            "",
            "                // Get the calibration data",
            "                BNO055IMU.CalibrationData calibrationData = imu.readCalibrationData();",
            "",
            "                // Save the calibration data to a file. You can choose whatever file",
            "                // name you wish here, but you'll want to indicate the same file name",
            "                // when you initialize the IMU in an opmode in which it is used. If you",
            "                // have more than one IMU on your robot, you'll of course want to use",
            "                // different configuration file names for each.",
            "                String filename = \\\"AdafruitIMUCalibration.json\\\";",
            "                File file = AppUtil.getInstance().getSettingsFile(filename);",
            "                ReadWriteFile.writeFile(file, calibrationData.serialize());",
            "                telemetry.log().add(\\\"saved to '%s'\\\", filename);",
            "",
            "                // Wait for the button to be released",
            "                while (gamepad1.a) {",
            "                    telemetry.update();",
            "                    idle();",
            "                }",
            "            }",
            "",
            "            telemetry.update();",
            "        }",
            "    }",
            "",
            "    void composeTelemetry() {",
            "",
            "        // At the beginning of each telemetry update, grab a bunch of data",
            "        // from the IMU that we will then display in separate lines.",
            "        telemetry.addAction(new Runnable() { @Override public void run()",
            "                {",
            "                // Acquiring the angles is relatively expensive; we don't want",
            "                // to do that in each of the three items that need that info, as that's",
            "                // three times the necessary expense.",
            "                angles   = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);",
            "                }",
            "            });",
            "",
            "        telemetry.addLine()",
            "            .addData(\\\"status\\\", new Func<String>() {",
            "                @Override public String value() {",
            "                    return imu.getSystemStatus().toShortString();",
            "                    }",
            "                })",
            "            .addData(\\\"calib\\\", new Func<String>() {",
            "                @Override public String value() {",
            "                    return imu.getCalibrationStatus().toString();",
            "                    }",
            "                });",
            "",
            "        telemetry.addLine()",
            "            .addData(\\\"heading\\\", new Func<String>() {",
            "                @Override public String value() {",
            "                    return formatAngle(angles.angleUnit, angles.firstAngle);",
            "                    }",
            "                })",
            "            .addData(\\\"roll\\\", new Func<String>() {",
            "                @Override public String value() {",
            "                    return formatAngle(angles.angleUnit, angles.secondAngle);",
            "                    }",
            "                })",
            "            .addData(\\\"pitch\\\", new Func<String>() {",
            "                @Override public String value() {",
            "                    return formatAngle(angles.angleUnit, angles.thirdAngle);",
            "                    }",
            "                });",
            "    }",
            "",
            "    //----------------------------------------------------------------------------------------------",
            "    // Formatting",
            "    //----------------------------------------------------------------------------------------------",
            "",
            "    String formatAngle(AngleUnit angleUnit, double angle) {",
            "        return formatDegrees(AngleUnit.DEGREES.fromUnit(angleUnit, angle));",
            "    }",
            "",
            "    String formatDegrees(double degrees){",
            "        return String.format(Locale.getDefault(), \\\"%.1f\\\", AngleUnit.DEGREES.normalize(degrees));",
            "    }",
            "}"
        ]
    },
    "SensorKLNavxMicro": {
        "prefix": "sensorKLNavxMicro",
        "description": " In this sample, for illustration purposes we use two interfaces on the one gyro object.\n    That's likely atypical: you'll probably use one or the other in any given situation,\n    depending on what you're trying to do. {@link IntegratingGyroscope} (and it's base interface,\n    {@link Gyroscope}) are common interfaces supported by possibly several different gyro\n    implementations. {@link NavxMicroNavigationSensor}, by contrast, provides functionality that\n    is unique to the navX Micro sensor.\n     ",
        "body": [
            "public class SensorKLNavxMicro extends LinearOpMode {",
            "",
            "    /** In this sample, for illustration purposes we use two interfaces on the one gyro object.",
            "     * That's likely atypical: you'll probably use one or the other in any given situation,",
            "     * depending on what you're trying to do. {@link IntegratingGyroscope} (and it's base interface,",
            "     * {@link Gyroscope}) are common interfaces supported by possibly several different gyro",
            "     * implementations. {@link NavxMicroNavigationSensor}, by contrast, provides functionality that",
            "     * is unique to the navX Micro sensor.",
            "     */",
            "    IntegratingGyroscope gyro;",
            "    NavxMicroNavigationSensor navxMicro;",
            "",
            "    // A timer helps provide feedback while calibration is taking place",
            "    ElapsedTime timer = new ElapsedTime();",
            "",
            "    @Override public void runOpMode() throws InterruptedException {",
            "        // Get a reference to a Modern Robotics GyroSensor object. We use several interfaces",
            "        // on this object to illustrate which interfaces support which functionality.",
            "        navxMicro = hardwareMap.get(NavxMicroNavigationSensor.class, \"navx\\\");",
            "        gyro = (IntegratingGyroscope)navxMicro;",
            "        // If you're only interested int the IntegratingGyroscope interface, the following will suffice.",
            "        // gyro = hardwareMap.get(IntegratingGyroscope.class, \\\"navx\\\");",
            "",
            "        // The gyro automatically starts calibrating. This takes a few seconds.",
            "        telemetry.log().add(\\\"Gyro Calibrating. Do Not Move!\\\");",
            "",
            "        // Wait until the gyro calibration is complete",
            "        timer.reset();",
            "        while (navxMicro.isCalibrating())  {",
            "            telemetry.addData(\\\"calibrating\\\", \\\"%s\\\", Math.round(timer.seconds())%2==0 ? \\\"|..\\\" : \\\"..|\\\");",
            "            telemetry.update();",
            "            Thread.sleep(50);",
            "        }",
            "        telemetry.log().clear(); telemetry.log().add(\\\"Gyro Calibrated. Press Start.\\\");",
            "        telemetry.clear(); telemetry.update();",
            "",
            "        // Wait for the start button to be pressed",
            "        waitForStart();",
            "        telemetry.log().clear();",
            "",
            "        while (opModeIsActive()) {",
            "",
            "            // Read dimensionalized data from the gyro. This gyro can report angular velocities",
            "            // about all three axes. Additionally, it internally integrates the Z axis to",
            "            // be able to report an absolute angular Z orientation.",
            "            AngularVelocity rates = gyro.getAngularVelocity(AngleUnit.DEGREES);",
            "            Orientation angles = gyro.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);",
            "",
            "            telemetry.addLine()",
            "                .addData(\\\"dx\\\", formatRate(rates.xRotationRate))",
            "                .addData(\\\"dy\\\", formatRate(rates.yRotationRate))",
            "                .addData(\\\"dz\\\", \\\"%s deg/s\\\", formatRate(rates.zRotationRate));",
            "",
            "            telemetry.addLine()",
            "                .addData(\\\"heading\\\", formatAngle(angles.angleUnit, angles.firstAngle))",
            "                .addData(\\\"roll\\\", formatAngle(angles.angleUnit, angles.secondAngle))",
            "                .addData(\\\"pitch\\\", \\\"%s deg\\\", formatAngle(angles.angleUnit, angles.thirdAngle));",
            "            telemetry.update();",
            "",
            "            idle(); // Always call idle() at the bottom of your while(opModeIsActive()) loop",
            "        }",
            "    }",
            "",
            "    String formatRate(float rate) {",
            "        return String.format(\\\"%.3f\\\", rate);",
            "    }",
            "",
            "    String formatAngle(AngleUnit angleUnit, double angle) {",
            "        return formatDegrees(AngleUnit.DEGREES.fromUnit(angleUnit, angle));",
            "    }",
            "",
            "    String formatDegrees(double degrees){",
            "        return String.format(\\\"%.1f\\\", AngleUnit.DEGREES.normalize(degrees));",
            "    }",
            "}",
            ""
        ]
    },
    "SensorMRGyro": {
        "prefix": "sensorMRGyro",
        "description": " In this sample, for illustration purposes we use two interfaces on the one gyro object.\n  That's likely atypical: you'll probably use one or the other in any given situation,\n  depending on what you're trying to do. {@link IntegratingGyroscope} (and it's base interface,\n  {@link Gyroscope}) are common interfaces supported by possibly several different gyro\n  implementations. {@link ModernRoboticsI2cGyro}, by contrast, provides functionality that\n  is unique to the Modern Robotics gyro sensor.\n   ",
        "body": [
            "public class SensorMRGyro extends LinearOpMode {",
            "",
            "  /** In this sample, for illustration purposes we use two interfaces on the one gyro object.",
            "   * That's likely atypical: you'll probably use one or the other in any given situation,",
            "   * depending on what you're trying to do. {@link IntegratingGyroscope} (and it's base interface,",
            "   * {@link Gyroscope}) are common interfaces supported by possibly several different gyro",
            "   * implementations. {@link ModernRoboticsI2cGyro}, by contrast, provides functionality that",
            "   * is unique to the Modern Robotics gyro sensor.",
            "   */",
            "  IntegratingGyroscope gyro;",
            "  ModernRoboticsI2cGyro modernRoboticsI2cGyro;",
            "",
            "  // A timer helps provide feedback while calibration is taking place",
            "  ElapsedTime timer = new ElapsedTime();",
            "",
            "  @Override",
            "  public void runOpMode() {",
            "",
            "    boolean lastResetState = false;",
            "    boolean curResetState  = false;",
            "",
            "    // Get a reference to a Modern Robotics gyro object. We use several interfaces",
            "    // on this object to illustrate which interfaces support which functionality.",
            "    modernRoboticsI2cGyro = hardwareMap.get(ModernRoboticsI2cGyro.class, \"gyro\\\");",
            "    gyro = (IntegratingGyroscope)modernRoboticsI2cGyro;",
            "    // If you're only interested int the IntegratingGyroscope interface, the following will suffice.",
            "    // gyro = hardwareMap.get(IntegratingGyroscope.class, \\\"gyro\\\");",
            "    // A similar approach will work for the Gyroscope interface, if that's all you need.",
            "",
            "    // Start calibrating the gyro. This takes a few seconds and is worth performing",
            "    // during the initialization phase at the start of each OpMode.",
            "    telemetry.log().add(\\\"Gyro Calibrating. Do Not Move!\\\");",
            "    modernRoboticsI2cGyro.calibrate();",
            "",
            "    // Wait until the gyro calibration is complete",
            "    timer.reset();",
            "    while (!isStopRequested() && modernRoboticsI2cGyro.isCalibrating())  {",
            "      telemetry.addData(\\\"calibrating\\\", \\\"%s\\\", Math.round(timer.seconds())%2==0 ? \\\"|..\\\" : \\\"..|\\\");",
            "      telemetry.update();",
            "      sleep(50);",
            "    }",
            "",
            "    telemetry.log().clear(); telemetry.log().add(\\\"Gyro Calibrated. Press Start.\\\");",
            "    telemetry.clear(); telemetry.update();",
            "",
            "    // Wait for the start button to be pressed",
            "    waitForStart();",
            "    telemetry.log().clear();",
            "    telemetry.log().add(\\\"Press A & B to reset heading\\\");",
            "",
            "    // Loop until we're asked to stop",
            "    while (opModeIsActive())  {",
            "",
            "      // If the A and B buttons are pressed just now, reset Z heading.",
            "      curResetState = (gamepad1.a && gamepad1.b);",
            "      if (curResetState && !lastResetState) {",
            "        modernRoboticsI2cGyro.resetZAxisIntegrator();",
            "      }",
            "      lastResetState = curResetState;",
            "",
            "      // The raw() methods report the angular rate of change about each of the",
            "      // three axes directly as reported by the underlying sensor IC.",
            "      int rawX = modernRoboticsI2cGyro.rawX();",
            "      int rawY = modernRoboticsI2cGyro.rawY();",
            "      int rawZ = modernRoboticsI2cGyro.rawZ();",
            "      int heading = modernRoboticsI2cGyro.getHeading();",
            "      int integratedZ = modernRoboticsI2cGyro.getIntegratedZValue();",
            "",
            "      // Read dimensionalized data from the gyro. This gyro can report angular velocities",
            "      // about all three axes. Additionally, it internally integrates the Z axis to",
            "      // be able to report an absolute angular Z orientation.",
            "      AngularVelocity rates = gyro.getAngularVelocity(AngleUnit.DEGREES);",
            "      float zAngle = gyro.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES).firstAngle;",
            "",
            "      // Read administrative information from the gyro",
            "      int zAxisOffset = modernRoboticsI2cGyro.getZAxisOffset();",
            "      int zAxisScalingCoefficient = modernRoboticsI2cGyro.getZAxisScalingCoefficient();",
            "",
            "      telemetry.addLine()",
            "        .addData(\\\"dx\\\", formatRate(rates.xRotationRate))",
            "        .addData(\\\"dy\\\", formatRate(rates.yRotationRate))",
            "        .addData(\\\"dz\\\", \\\"%s deg/s\\\", formatRate(rates.zRotationRate));",
            "      telemetry.addData(\\\"angle\\\", \\\"%s deg\\\", formatFloat(zAngle));",
            "      telemetry.addData(\\\"heading\\\", \\\"%3d deg\\\", heading);",
            "      telemetry.addData(\\\"integrated Z\\\", \\\"%3d\\\", integratedZ);",
            "      telemetry.addLine()",
            "        .addData(\\\"rawX\\\", formatRaw(rawX))",
            "        .addData(\\\"rawY\\\", formatRaw(rawY))",
            "        .addData(\\\"rawZ\\\", formatRaw(rawZ));",
            "      telemetry.addLine().addData(\\\"z offset\\\", zAxisOffset).addData(\\\"z coeff\\\", zAxisScalingCoefficient);",
            "      telemetry.update();",
            "    }",
            "  }",
            "",
            "  String formatRaw(int rawValue) {",
            "    return String.format(\\\"%d\\\", rawValue);",
            "  }",
            "",
            "  String formatRate(float rate) {",
            "    return String.format(\\\"%.3f\\\", rate);",
            "  }",
            "",
            "  String formatFloat(float rate) {",
            "    return String.format(\\\"%.3f\\\", rate);",
            "  }",
            "",
            "}",
            ""
        ]
    },
    "SensorBNO055IMU": {
        "prefix": "sensorBNO055IMU",
        "description": "{@link SensorBNO055IMU} gives a short demo on how to use the BNO055 Inertial Motion Unit (IMU) from AdaFruit.\n\nNote: this is a Legacy example that will not work with newer Control/Expansion Hubs that use a different IMU\nPlease use the new SensorIMUOrthogonal or SensorIMUNonOrthogonal samples for a more universal IMU interface.\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list\n\n@see <a href=\"http://www.adafruit.com/products/2472\">Adafruit IMU</a>\n ",
        "body": [
            "public class SensorBNO055IMU extends LinearOpMode",
            "    {",
            "    //----------------------------------------------------------------------------------------------",
            "    // State",
            "    //----------------------------------------------------------------------------------------------",
            "",
            "    // The IMU sensor object",
            "    BNO055IMU imu;",
            "",
            "    // State used for updating telemetry",
            "    Orientation angles;",
            "    Acceleration gravity;",
            "",
            "    //----------------------------------------------------------------------------------------------",
            "    // Main logic",
            "    //----------------------------------------------------------------------------------------------",
            "",
            "    @Override public void runOpMode() {",
            "",
            "        // Set up the parameters with which we will use our IMU. Note that integration",
            "        // algorithm here just reports accelerations to the logcat log; it doesn't actually",
            "        // provide positional information.",
            "        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();",
            "        parameters.angleUnit           = BNO055IMU.AngleUnit.DEGREES;",
            "        parameters.accelUnit           = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;",
            "        parameters.calibrationDataFile = \"BNO055IMUCalibration.json\\\"; // see the calibration sample opmode",
            "        parameters.loggingEnabled      = true;",
            "        parameters.loggingTag          = \\\"IMU\\\";",
            "        parameters.accelerationIntegrationAlgorithm = new JustLoggingAccelerationIntegrator();",
            "",
            "        // Retrieve and initialize the IMU. We expect the IMU to be attached to an I2C port",
            "        // on a Core Device Interface Module, configured to be a sensor of type \\\"AdaFruit IMU\\\",",
            "        // and named \\\"imu\\\".",
            "        imu = hardwareMap.get(BNO055IMU.class, \\\"imu\\\");",
            "        imu.initialize(parameters);",
            "",
            "        // Set up our telemetry dashboard",
            "        composeTelemetry();",
            "",
            "        // Wait until we're told to go",
            "        waitForStart();",
            "",
            "        // Start the logging of measured acceleration",
            "        imu.startAccelerationIntegration(new Position(), new Velocity(), 1000);",
            "",
            "        // Loop and update the dashboard",
            "        while (opModeIsActive()) {",
            "            telemetry.update();",
            "        }",
            "    }",
            "",
            "    //----------------------------------------------------------------------------------------------",
            "    // Telemetry Configuration",
            "    //----------------------------------------------------------------------------------------------",
            "",
            "    void composeTelemetry() {",
            "",
            "        // At the beginning of each telemetry update, grab a bunch of data",
            "        // from the IMU that we will then display in separate lines.",
            "        telemetry.addAction(new Runnable() { @Override public void run()",
            "                {",
            "                // Acquiring the angles is relatively expensive; we don't want",
            "                // to do that in each of the three items that need that info, as that's",
            "                // three times the necessary expense.",
            "                angles   = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);",
            "                gravity  = imu.getGravity();",
            "                }",
            "            });",
            "",
            "        telemetry.addLine()",
            "            .addData(\\\"status\\\", new Func<String>() {",
            "                @Override public String value() {",
            "                    return imu.getSystemStatus().toShortString();",
            "                    }",
            "                })",
            "            .addData(\\\"calib\\\", new Func<String>() {",
            "                @Override public String value() {",
            "                    return imu.getCalibrationStatus().toString();",
            "                    }",
            "                });",
            "",
            "        telemetry.addLine()",
            "            .addData(\\\"heading\\\", new Func<String>() {",
            "                @Override public String value() {",
            "                    return formatAngle(angles.angleUnit, angles.firstAngle);",
            "                    }",
            "                })",
            "            .addData(\\\"roll\\\", new Func<String>() {",
            "                @Override public String value() {",
            "                    return formatAngle(angles.angleUnit, angles.secondAngle);",
            "                    }",
            "                })",
            "            .addData(\\\"pitch\\\", new Func<String>() {",
            "                @Override public String value() {",
            "                    return formatAngle(angles.angleUnit, angles.thirdAngle);",
            "                    }",
            "                });",
            "",
            "        telemetry.addLine()",
            "            .addData(\\\"grvty\\\", new Func<String>() {",
            "                @Override public String value() {",
            "                    return gravity.toString();",
            "                    }",
            "                })",
            "            .addData(\\\"mag\\\", new Func<String>() {",
            "                @Override public String value() {",
            "                    return String.format(Locale.getDefault(), \\\"%.3f\\\",",
            "                            Math.sqrt(gravity.xAccel*gravity.xAccel",
            "                                    + gravity.yAccel*gravity.yAccel",
            "                                    + gravity.zAccel*gravity.zAccel));",
            "                    }",
            "                });",
            "    }",
            "",
            "    //----------------------------------------------------------------------------------------------",
            "    // Formatting",
            "    //----------------------------------------------------------------------------------------------",
            "",
            "    String formatAngle(AngleUnit angleUnit, double angle) {",
            "        return formatDegrees(AngleUnit.DEGREES.fromUnit(angleUnit, angle));",
            "    }",
            "",
            "    String formatDegrees(double degrees){",
            "        return String.format(Locale.getDefault(), \\\"%.1f\\\", AngleUnit.DEGREES.normalize(degrees));",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptGamepadRumble": {
        "prefix": "conceptGamepadRumble",
        "description": "This sample illustrates using the rumble feature of many gamepads.\n\nNote: Some gamepads \"rumble\" better than others.\n  The Xbox & PS4 have a left (rumble1) and right (rumble2) rumble motor.\n  These two gamepads have two distinct rumble modes: Large on the left, and small on the right\n  The ETpark gamepad may only respond to rumble1, and may only run at full power.\n  The Logitech F310 gamepad does not haveany* rumble ability.\n\n  Moral:  You should use this sample to experiment with your specific gamepads to explore their rumble features.\n\nThe rumble motors are accessed through the standard gamepad1 and gamepad2 objects.\n  Several new methods were added to the Gamepad class in FTC SDK Rev 7\n  The key methods are as follows:\n\n  .rumble(double rumble1, double rumble2, int durationMs)\n    This method sets the rumble power of both motors for a specific time duration.\n    Both rumble arguments are motor-power levels in the 0.0 to 1.0 range.\n    durationMs is the desired length of the rumble action in milliseconds.\n    This method returns immediately.\n    Note:\n      Use a durationMs of Gamepad.RUMBLE_DURATION_CONTINUOUS to provide a continuous rumble\n      Use a power of 0, or duration of 0 to stop a rumble.\n\n  .rumbleBlips(int count) allows an easy way to signal the driver with a series of rumble blips.\n    Just specify how many blips you want.\n    This method returns immediately.\n\n  .runRumbleEffect(customRumbleEffect) allows you to run a custom rumble sequence that you have\n    built using the Gamepad.RumbleEffect.Builder()\n    A \"custom effect\" is a sequence of steps, where each step can rumble any of the\n    rumble motors for a specific period at a specific power level.\n    The Custom Effect will play as the (un-blocked) OpMode continues to run\n\n  .isRumbling() returns true if there is a rumble effect in progress.\n    Use this call to prevent stepping on a current rumble.\n\n  .stopRumble()              Stop any ongoing rumble or custom rumble effect.\n\n  .rumble(int durationMs)    Full power rumble for fixed duration.\n\n  Note: Whenever a new Rumble command is issued, any currently executing rumble action will\n  be truncated, and the new action started immediately.  Take these precautions:\n     1) Do Not SPAM the rumble motors by issuing rapid fire commands\n     2) Multiple sources for rumble commands must coordinate to avoid tromping on each other.\n\n  This can be achieved several possible ways:\n  1) Only having one source for rumble actions\n  2) Issuing rumble commands on transitions, rather than states.\n     e.g. The moment a touch sensor is pressed, rather than the entire time it is being pressed.\n  3) Scheduling rumble commands based on timed events. e.g. 10 seconds prior to endgame\n  4) Rumble on non-overlapping mechanical actions. e.g. arm fully-extended or fully-retracted.\n  5) Use isRumbling() to hold off on a new rumble if one is already in progress.\n\nThe examples shown here are representstive of how to invoke a gamepad rumble.\nIt is assumed that these will be modified to suit the specific robot and team strategy needs.\n\n########   Read the telemetry display on the Driver Station Screen for instructions.   ######\n\nEx 1)    This example shows a) how to create a custom rumble effect, and then b) how to trigger it based\n         on game time.  One use for this might be to alert the driver that half-time or End-game is approaching.\n\nEx 2)    This example shows tying the rumble power to a changing sensor value.\n         In this case it is the Gamepad trigger, but it could be any sensor output scaled to the 0-1 range.\n         Since it takes over the rumble motors, it is only performed when the Left Bumper is pressed.\n         Note that this approach MUST include a way to turn OFF the rumble when the button is released.\n\nEx 3)    This example shows a simple way to trigger a 3-blip sequence.  In this case it is\n         triggered by the gamepad A (Cross) button, but it could be any sensor, like a touch or light sensor.\n         Note that this code ensures that it only rumbles once when the input goes true.\n\nEx 4)    This example shows how to trigger a single rumble when an input value gets over a certain value.\n         In this case it is reading the Right Trigger, but it could be any variable sensor, like a\n         range sensor, or position sensor.  The code needs to ensure that it is only triggered once, so\n         it waits till the sensor drops back below the threshold before it can trigger again.\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this OpMode to the Driver Station OpMode list.\n ",
        "body": [
            "public class ConceptGamepadRumble extends LinearOpMode",
            "{",
            "    boolean lastA = false;                      // Use to track the prior button state.",
            "    boolean lastLB = false;                     // Use to track the prior button state.",
            "    boolean highLevel = false;                  // used to prevent multiple level-based rumbles.",
            "    boolean secondHalf = false;                 // Use to prevent multiple half-time warning rumbles.",
            "",
            "    Gamepad.RumbleEffect customRumbleEffect;    // Use to build a custom rumble sequence.",
            "    ElapsedTime runtime = new ElapsedTime();    // Use to determine when end game is starting.",
            "",
            "    final double HALF_TIME = 60.0;              // Wait this many seconds before rumble-alert for half-time.",
            "    final double TRIGGER_THRESHOLD  = 0.75;     // Squeeze more than 3/4 to get rumble.",
            "",
            "    @Override",
            "    public void runOpMode()",
            "    {",
            "        // Example 1. a)   start by creating a three-pulse rumble sequence: right, LEFT, LEFT",
            "        customRumbleEffect = new Gamepad.RumbleEffect.Builder()",
            "                .addStep(0.0, 1.0, 500)  //  Rumble right motor 100% for 500 mSec",
            "                .addStep(0.0, 0.0, 300)  //  Pause for 300 mSec",
            "                .addStep(1.0, 0.0, 250)  //  Rumble left motor 100% for 250 mSec",
            "                .addStep(0.0, 0.0, 250)  //  Pause for 250 mSec",
            "                .addStep(1.0, 0.0, 250)  //  Rumble left motor 100% for 250 mSec",
            "                .build();",
            "",
            "        telemetry.addData(\">\\\", \\\"Press Start\\\");",
            "        telemetry.update();",
            "",
            "        waitForStart();",
            "        runtime.reset();    // Start game timer.",
            "",
            "        // Loop while monitoring buttons for rumble triggers",
            "        while (opModeIsActive())",
            "        {",
            "            // Read and save the current gamepad button states.",
            "            boolean currentA = gamepad1.a ;",
            "            boolean currentLB = gamepad1.left_bumper ;",
            "",
            "            // Display the current Rumble status.  Just for interest.",
            "            telemetry.addData(\\\">\\\", \\\"Are we RUMBLING? %s\\n\\\", gamepad1.isRumbling() ? \\\"YES\\\" : \\\"no\\\" );",
            "",
            "            // ----------------------------------------------------------------------------------------",
            "            // Example 1. b) Watch the runtime timer, and run the custom rumble when we hit half-time.",
            "            //               Make sure we only signal once by setting \\\"secondHalf\\\" flag to prevent further rumbles.",
            "            // ----------------------------------------------------------------------------------------",
            "            if ((runtime.seconds() > HALF_TIME) && !secondHalf)  {",
            "                gamepad1.runRumbleEffect(customRumbleEffect);",
            "                secondHalf =true;",
            "            }",
            "",
            "            // Display the time remaining while we are still counting down.",
            "            if (!secondHalf) {",
            "                telemetry.addData(\\\">\\\", \\\"Halftime Alert Countdown: %3.0f Sec \\n\\\", (HALF_TIME - runtime.seconds()) );",
            "            }",
            "",
            "",
            "            // ----------------------------------------------------------------------------------------",
            "            // Example 2. If Left Bumper is being pressed, power the rumble motors based on the two trigger depressions.",
            "            // This is useful to see how the rumble feels at various power levels.",
            "            // ----------------------------------------------------------------------------------------",
            "            if (currentLB) {",
            "                // Left Bumper is being pressed, so send left and right \\\"trigger\\\" values to left and right rumble motors.",
            "                gamepad1.rumble(gamepad1.left_trigger, gamepad1.right_trigger, Gamepad.RUMBLE_DURATION_CONTINUOUS);",
            "",
            "                // Show what is being sent to rumbles",
            "                telemetry.addData(\\\">\\\", \\\"Squeeze triggers to control rumbles\\\");",
            "                telemetry.addData(\\\"> : Rumble\\\", \\\"Left: %.0f%%   Right: %.0f%%\\\", gamepad1.left_trigger * 100, gamepad1.right_trigger * 100);",
            "            } else {",
            "                // Make sure rumble is turned off when Left Bumper is released (only one time each press)",
            "                if (lastLB) {",
            "                    gamepad1.stopRumble();",
            "                }",
            "",
            "                //  Prompt for manual rumble action",
            "                telemetry.addData(\\\">\\\", \\\"Hold Left-Bumper to test Manual Rumble\\\");",
            "                telemetry.addData(\\\">\\\", \\\"Press A (Cross) for three blips\\\");",
            "                telemetry.addData(\\\">\\\", \\\"Squeeze right trigger slowly for 1 blip\\\");",
            "            }",
            "            lastLB = currentLB; // remember the current button state for next time around the loop",
            "",
            "",
            "            // ----------------------------------------------------------------------------------------",
            "            // Example 3. Blip 3 times at the moment that A (Cross) is pressed. (look for pressed transition)",
            "            // BUT !!!  Skip it altogether if the Gamepad is already rumbling.",
            "            // ----------------------------------------------------------------------------------------",
            "            if (currentA && !lastA) {",
            "                if (!gamepad1.isRumbling())  // Check for possible overlap of rumbles.",
            "                    gamepad1.rumbleBlips(3);",
            "            }",
            "            lastA = currentA; // remember the current button state for next time around the loop",
            "",
            "",
            "            // ----------------------------------------------------------------------------------------",
            "            // Example 4. Rumble once when gamepad right trigger goes above the THRESHOLD.",
            "            // ----------------------------------------------------------------------------------------",
            "            if (gamepad1.right_trigger > TRIGGER_THRESHOLD) {",
            "                if (!highLevel) {",
            "                    gamepad1.rumble(0.9, 0, 200);  // 200 mSec burst on left motor.",
            "                    highLevel = true;  // Hold off any more triggers",
            "                }",
            "            } else {",
            "                highLevel = false;  // We can trigger again now.",
            "            }",
            "",
            "            // Send the telemetry data to the Driver Station, and then pause to pace the program.",
            "            telemetry.update();",
            "            sleep(10);",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptGamepadTouchpad": {
        "prefix": "conceptGamepadTouchpad",
        "description": "This sample illustrates using the touchpad feature found on some gamepads.\n\nThe Sony PS4 gamepad can detect two distinct touches on the central touchpad.\nOther gamepads with different touchpads may provide mixed results.\n\nThe touchpads are accessed through the standard gamepad1 and gamepad2 objects.\n  Several new members were added to the Gamepad class in FTC SDK Rev 7\n\n  .touchpad_finger_1     returns true if at least one finger is detected.\n  .touchpad_finger_1_x   finger 1 X coordinate.  Valid if touchpad_finger_1 is true\n  .touchpad_finger_1_y   finger 1 Y coordinate.  Valid if touchpad_finger_1 is true\n\n  .touchpad_finger_2     returns true if a second finger is detected\n  .touchpad_finger_2_x   finger 2 X coordinate.  Valid if touchpad_finger_2 is true\n  .touchpad_finger_2_y   finger 2 Y coordinate.  Valid if touchpad_finger_2 is true\n\nFinger touches are reported with an X and Y coordinate in following coordinate system.\n\n  1) X is the Horizontal axis, and Y is the vertical axis\n  2) The 0,0 origin is at the center of the touchpad.\n  3)  1.0, 1.0 is at the top right corner of the touchpad.\n  4) -1.0,-1.0 is at the bottom left corner of the touchpad.\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this OpMode to the Driver Station OpMode list.\n ",
        "body": [
            "public class ConceptGamepadTouchpad extends LinearOpMode",
            "{",
            "    @Override",
            "    public void runOpMode()",
            "    {",
            "        telemetry.setDisplayFormat(Telemetry.DisplayFormat.MONOSPACE);",
            "",
            "        telemetry.addData(\">\\\", \\\"Press Start\\\");",
            "        telemetry.update();",
            "",
            "        waitForStart();",
            "",
            "        while (opModeIsActive())",
            "        {",
            "            boolean finger = false;",
            "",
            "            // Display finger 1 x & y position if finger detected",
            "            if(gamepad1.touchpad_finger_1)",
            "            {",
            "                finger = true;",
            "                telemetry.addLine(String.format(\\\"Finger 1: x=%5.2f y=%5.2f\\n\\\", gamepad1.touchpad_finger_1_x, gamepad1.touchpad_finger_1_y));",
            "            }",
            "",
            "            // Display finger 2 x & y position if finger detected",
            "            if(gamepad1.touchpad_finger_2)",
            "            {",
            "                finger = true;",
            "                telemetry.addLine(String.format(\\\"Finger 2: x=%5.2f y=%5.2f\\n\\\", gamepad1.touchpad_finger_2_x, gamepad1.touchpad_finger_2_y));",
            "            }",
            "",
            "            if(!finger)",
            "            {",
            "                telemetry.addLine(\\\"No fingers\\\");",
            "            }",
            "",
            "            telemetry.update();",
            "            sleep(10);",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptVuforiaFieldNavigation": {
        "prefix": "conceptVuforiaFieldNavigation",
        "description": "        In order for localization to work, we need to tell the system where each target is on the field, and\n        where the phone resides on the robot.  These specifications are in the form of <em>transformation matrices.</em>\n        Transformation matrices are a central, important concept in the math here involved in localization.\n        See <a href=\"https://en.wikipedia.org/wiki/Transformation_matrix\">Transformation Matrix</a>\n        for detailed information. Commonly, you'll encounter transformation matrices as instances\n        of the {@link OpenGLMatrix} class.\n        \n        If you are standing in the Red Alliance Station looking towards the center of the field,\n            - The X axis runs from your left to the right. (positive from the center to the right)\n            - The Y axis runs from the Red Alliance Station towards the other side of the field\n              where the Blue Alliance Station is. (Positive is from the center, towards the BlueAlliance station)\n            - The Z axis runs from the floor, upwards towards the ceiling.  (Positive is above the floor)\n        \n        Before being transformed, each target image is conceptually located at the origin of the field's\n         coordinate system (the center of the field), facing up.\n         ",
        "body": [
            "public class ConceptVuforiaFieldNavigation extends LinearOpMode {",
            "",
            "    // IMPORTANT:  For Phone Camera, set 1) the camera source and 2) the orientation, based on how your phone is mounted:",
            "    // 1) Camera Source.  Valid choices are:  BACK (behind screen) or FRONT (selfie side)",
            "    // 2) Phone Orientation. Choices are: PHONE_IS_PORTRAIT = true (portrait) or PHONE_IS_PORTRAIT = false (landscape)",
            "",
            "    private static final VuforiaLocalizer.CameraDirection CAMERA_CHOICE = BACK;",
            "    private static final boolean PHONE_IS_PORTRAIT = false  ;",
            "",
            "    /*",
            "     * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which",
            "     * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.",
            "     * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer",
            "     * web site at https://developer.vuforia.com/license-manager.",
            "     *",
            "     * Vuforia license keys are always 380 characters long, and look as if they contain mostly",
            "     * random data. As an example, here is a example of a fragment of a valid key:",
            "     *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...",
            "     * Once you've obtained a license key, copy the string from the Vuforia web site",
            "     * and paste it in to your code on the next line, between the double quotes.",
            "     */",
            "    private static final String VUFORIA_KEY =",
            "            \" -- YOUR NEW VUFORIA KEY GOES HERE  --- \\\";",
            "",
            "    // Since ImageTarget trackables use mm to specifiy their dimensions, we must use mm for all the physical dimension.",
            "    // We will define some constants and conversions here.  These are useful for the FTC competition field.",
            "    private static final float mmPerInch        = 25.4f;",
            "    private static final float mmTargetHeight   = 6 * mmPerInch;          // the height of the center of the target image above the floor",
            "    private static final float halfField        = 72 * mmPerInch;",
            "    private static final float halfTile         = 12 * mmPerInch;",
            "    private static final float oneAndHalfTile   = 36 * mmPerInch;",
            "",
            "    // Class Members",
            "    private OpenGLMatrix lastLocation = null;",
            "    private VuforiaLocalizer vuforia  = null;",
            "    private VuforiaTrackables targets = null ;",
            "",
            "    private boolean targetVisible = false;",
            "    private float phoneXRotate    = 0;",
            "    private float phoneYRotate    = 0;",
            "    private float phoneZRotate    = 0;",
            "",
            "    @Override public void runOpMode() {",
            "        /*",
            "         * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine.",
            "         * To get an on-phone camera preview, use the code below.",
            "         * If no camera preview is desired, use the parameter-less constructor instead (commented out below).",
            "         */",
            "        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\\\"cameraMonitorViewId\\\", \\\"id\\\", hardwareMap.appContext.getPackageName());",
            "        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId);",
            "        // VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();",
            "",
            "        parameters.vuforiaLicenseKey = VUFORIA_KEY;",
            "        parameters.cameraDirection   = CAMERA_CHOICE;",
            "",
            "        // Turn off Extended tracking.  Set this true if you want Vuforia to track beyond the target.",
            "        parameters.useExtendedTracking = false;",
            "",
            "        //  Instantiate the Vuforia engine",
            "        vuforia = ClassFactory.getInstance().createVuforia(parameters);",
            "",
            "        // Load the trackable assets.",
            "        targets = this.vuforia.loadTrackablesFromAsset(\\\"PowerPlay\\\");",
            "",
            "        // For convenience, gather together all the trackable objects in one easily-iterable collection */",
            "        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();",
            "        allTrackables.addAll(targets);",
            "",
            "        /**",
            "         * In order for localization to work, we need to tell the system where each target is on the field, and",
            "         * where the phone resides on the robot.  These specifications are in the form of <em>transformation matrices.</em>",
            "         * Transformation matrices are a central, important concept in the math here involved in localization.",
            "         * See <a href=\\\"https://en.wikipedia.org/wiki/Transformation_matrix\\\">Transformation Matrix</a>",
            "         * for detailed information. Commonly, you'll encounter transformation matrices as instances",
            "         * of the {@link OpenGLMatrix} class.",
            "         *",
            "         * If you are standing in the Red Alliance Station looking towards the center of the field,",
            "         *     - The X axis runs from your left to the right. (positive from the center to the right)",
            "         *     - The Y axis runs from the Red Alliance Station towards the other side of the field",
            "         *       where the Blue Alliance Station is. (Positive is from the center, towards the BlueAlliance station)",
            "         *     - The Z axis runs from the floor, upwards towards the ceiling.  (Positive is above the floor)",
            "         *",
            "         * Before being transformed, each target image is conceptually located at the origin of the field's",
            "         *  coordinate system (the center of the field), facing up.",
            "         */",
            "",
            "        // Name and locate each trackable object",
            "        identifyTarget(0, \\\"Red Audience Wall\\\",   -halfField,  -oneAndHalfTile, mmTargetHeight, 90, 0,  90);",
            "        identifyTarget(1, \\\"Red Rear Wall\\\",        halfField,  -oneAndHalfTile, mmTargetHeight, 90, 0, -90);",
            "        identifyTarget(2, \\\"Blue Audience Wall\\\",  -halfField,   oneAndHalfTile, mmTargetHeight, 90, 0,  90);",
            "        identifyTarget(3, \\\"Blue Rear Wall\\\",       halfField,   oneAndHalfTile, mmTargetHeight, 90, 0, -90);",
            "",
            "        /*",
            "         * Create a transformation matrix describing where the phone is on the robot.",
            "         *",
            "         * NOTE !!!!  It's very important that you turn OFF your phone's Auto-Screen-Rotation option.",
            "         * Lock it into Portrait for these numbers to work.",
            "         *",
            "         * Info:  The coordinate frame for the robot looks the same as the field.",
            "         * The robot's \\\"forward\\\" direction is facing out along X axis, with the LEFT side facing out along the Y axis.",
            "         * Z is UP on the robot.  This equates to a heading angle of Zero degrees.",
            "         *",
            "         * The phone starts out lying flat, with the screen facing Up and with the physical top of the phone",
            "         * pointing to the LEFT side of the Robot.",
            "         * The two examples below assume that the camera is facing forward out the front of the robot.",
            "         */",
            "",
            "        // We need to rotate the camera around its long axis to bring the correct camera forward.",
            "        if (CAMERA_CHOICE == BACK) {",
            "            phoneYRotate = -90;",
            "        } else {",
            "            phoneYRotate = 90;",
            "        }",
            "",
            "        // Rotate the phone vertical about the X axis if it's in portrait mode",
            "        if (PHONE_IS_PORTRAIT) {",
            "            phoneXRotate = 90 ;",
            "        }",
            "",
            "        // Next, translate the camera lens to where it is on the robot.",
            "        // In this example, it is centered on the robot (left-to-right and front-to-back), and 6 inches above ground level.",
            "        final float CAMERA_FORWARD_DISPLACEMENT  = 0.0f * mmPerInch;   // eg: Enter the forward distance from the center of the robot to the camera lens",
            "        final float CAMERA_VERTICAL_DISPLACEMENT = 6.0f * mmPerInch;   // eg: Camera is 6 Inches above ground",
            "        final float CAMERA_LEFT_DISPLACEMENT     = 0.0f * mmPerInch;   // eg: Enter the left distance from the center of the robot to the camera lens",
            "",
            "        OpenGLMatrix robotFromCamera = OpenGLMatrix",
            "                    .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)",
            "                    .multiplied(Orientation.getRotationMatrix(EXTRINSIC, YZX, DEGREES, phoneYRotate, phoneZRotate, phoneXRotate));",
            "",
            "        /**  Let all the trackable listeners know where the phone is.  */",
            "        for (VuforiaTrackable trackable : allTrackables) {",
            "            ((VuforiaTrackableDefaultListener) trackable.getListener()).setPhoneInformation(robotFromCamera, parameters.cameraDirection);",
            "        }",
            "",
            "        /*",
            "         * WARNING:",
            "         * In this sample, we do not wait for PLAY to be pressed.  Target Tracking is started immediately when INIT is pressed.",
            "         * This sequence is used to enable the new remote DS Camera Stream feature to be used with this sample.",
            "         * CONSEQUENTLY do not put any driving commands in this loop.",
            "         * To restore the normal opmode structure, just un-comment the following line:",
            "         */",
            "",
            "        // waitForStart();",
            "",
            "        /* Note: To use the remote camera preview:",
            "         * AFTER you hit Init on the Driver Station, use the \\\"options menu\\\" to select \\\"Camera Stream\\\"",
            "         * Tap the preview window to receive a fresh image.",
            "         * It is not permitted to transition to RUN while the camera preview window is active.",
            "         * Either press STOP to exit the OpMode, or use the \\\"options menu\\\" again, and select \\\"Camera Stream\\\" to close the preview window.",
            "         */",
            "",
            "        targets.activate();",
            "        while (!isStopRequested()) {",
            "",
            "            // check all the trackable targets to see which one (if any) is visible.",
            "            targetVisible = false;",
            "            for (VuforiaTrackable trackable : allTrackables) {",
            "                if (((VuforiaTrackableDefaultListener)trackable.getListener()).isVisible()) {",
            "                    telemetry.addData(\\\"Visible Target\\\", trackable.getName());",
            "                    targetVisible = true;",
            "",
            "                    // getUpdatedRobotLocation() will return null if no new information is available since",
            "                    // the last time that call was made, or if the trackable is not currently visible.",
            "                    OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener)trackable.getListener()).getUpdatedRobotLocation();",
            "                    if (robotLocationTransform != null) {",
            "                        lastLocation = robotLocationTransform;",
            "                    }",
            "                    break;",
            "                }",
            "            }",
            "",
            "            // Provide feedback as to where the robot is located (if we know).",
            "            if (targetVisible) {",
            "                // express position (translation) of robot in inches.",
            "                VectorF translation = lastLocation.getTranslation();",
            "                telemetry.addData(\\\"Pos (inches)\\\", \\\"{X, Y, Z} = %.1f, %.1f, %.1f\\\",",
            "                        translation.get(0) / mmPerInch, translation.get(1) / mmPerInch, translation.get(2) / mmPerInch);",
            "",
            "                // express the rotation of the robot in degrees.",
            "                Orientation rotation = Orientation.getOrientation(lastLocation, EXTRINSIC, XYZ, DEGREES);",
            "                telemetry.addData(\\\"Rot (deg)\\\", \\\"{Roll, Pitch, Heading} = %.0f, %.0f, %.0f\\\", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);",
            "            }",
            "            else {",
            "                telemetry.addData(\\\"Visible Target\\\", \\\"none\\\");",
            "            }",
            "            telemetry.update();",
            "        }",
            "",
            "        // Disable Tracking when we are done;",
            "        targets.deactivate();",
            "    }",
            "",
            "    /***",
            "     * Identify a target by naming it, and setting its position and orientation on the field",
            "     * @param targetIndex",
            "     * @param targetName",
            "     * @param dx, dy, dz  Target offsets in x,y,z axes",
            "     * @param rx, ry, rz  Target rotations in x,y,z axes",
            "     */",
            "    void    identifyTarget(int targetIndex, String targetName, float dx, float dy, float dz, float rx, float ry, float rz) {",
            "        VuforiaTrackable aTarget = targets.get(targetIndex);",
            "        aTarget.setName(targetName);",
            "        aTarget.setLocation(OpenGLMatrix.translation(dx, dy, dz)",
            "                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, rx, ry, rz)));",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptVuforiaFieldNavigationWebcam": {
        "prefix": "conceptVuforiaFieldNavigationWebcam",
        "description": "        In order for localization to work, we need to tell the system where each target is on the field, and\n        where the phone resides on the robot.  These specifications are in the form of <em>transformation matrices.</em>\n        Transformation matrices are a central, important concept in the math here involved in localization.\n        See <a href=\"https://en.wikipedia.org/wiki/Transformation_matrix\">Transformation Matrix</a>\n        for detailed information. Commonly, you'll encounter transformation matrices as instances\n        of the {@link OpenGLMatrix} class.\n        \n        If you are standing in the Red Alliance Station looking towards the center of the field,\n            - The X axis runs from your left to the right. (positive from the center to the right)\n            - The Y axis runs from the Red Alliance Station towards the other side of the field\n              where the Blue Alliance Station is. (Positive is from the center, towards the BlueAlliance station)\n            - The Z axis runs from the floor, upwards towards the ceiling.  (Positive is above the floor)\n        \n        Before being transformed, each target image is conceptually located at the origin of the field's\n         coordinate system (the center of the field), facing up.\n         ",
        "body": [
            "public class ConceptVuforiaFieldNavigationWebcam extends LinearOpMode {",
            "",
            "    /*",
            "     * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which",
            "     * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.",
            "     * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer",
            "     * web site at https://developer.vuforia.com/license-manager.",
            "     *",
            "     * Vuforia license keys are always 380 characters long, and look as if they contain mostly",
            "     * random data. As an example, here is a example of a fragment of a valid key:",
            "     *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...",
            "     * Once you've obtained a license key, copy the string from the Vuforia web site",
            "     * and paste it in to your code on the next line, between the double quotes.",
            "     */",
            "    private static final String VUFORIA_KEY =",
            "            \" --- YOUR NEW VUFORIA KEY GOES HERE  --- \\\";",
            "",
            "    // Since ImageTarget trackables use mm to specifiy their dimensions, we must use mm for all the physical dimension.",
            "    // We will define some constants and conversions here",
            "    private static final float mmPerInch        = 25.4f;",
            "    private static final float mmTargetHeight   = 6 * mmPerInch;          // the height of the center of the target image above the floor",
            "    private static final float halfField        = 72 * mmPerInch;",
            "    private static final float halfTile         = 12 * mmPerInch;",
            "    private static final float oneAndHalfTile   = 36 * mmPerInch;",
            "",
            "    // Class Members",
            "    private OpenGLMatrix lastLocation   = null;",
            "    private VuforiaLocalizer vuforia    = null;",
            "    private VuforiaTrackables targets   = null ;",
            "    private WebcamName webcamName       = null;",
            "",
            "    private boolean targetVisible       = false;",
            "",
            "    @Override public void runOpMode() {",
            "        // Connect to the camera we are to use.  This name must match what is set up in Robot Configuration",
            "        webcamName = hardwareMap.get(WebcamName.class, \\\"Webcam 1\\\");",
            "",
            "        /*",
            "         * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine.",
            "         * We can pass Vuforia the handle to a camera preview resource (on the RC screen);",
            "         * If no camera-preview is desired, use the parameter-less constructor instead (commented out below).",
            "         * Note: A preview window is required if you want to view the camera stream on the Driver Station Phone.",
            "         */",
            "        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\\\"cameraMonitorViewId\\\", \\\"id\\\", hardwareMap.appContext.getPackageName());",
            "        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId);",
            "        // VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();",
            "",
            "        parameters.vuforiaLicenseKey = VUFORIA_KEY;",
            "",
            "        // We also indicate which camera we wish to use.",
            "        parameters.cameraName = webcamName;",
            "",
            "        // Turn off Extended tracking.  Set this true if you want Vuforia to track beyond the target.",
            "        parameters.useExtendedTracking = false;",
            "",
            "        //  Instantiate the Vuforia engine",
            "        vuforia = ClassFactory.getInstance().createVuforia(parameters);",
            "",
            "        // Load the data sets for the trackable objects. These particular data",
            "        // sets are stored in the 'assets' part of our application.",
            "        targets = this.vuforia.loadTrackablesFromAsset(\\\"PowerPlay\\\");",
            "",
            "        // For convenience, gather together all the trackable objects in one easily-iterable collection */",
            "        List<VuforiaTrackable> allTrackables = new ArrayList<VuforiaTrackable>();",
            "        allTrackables.addAll(targets);",
            "",
            "        /**",
            "         * In order for localization to work, we need to tell the system where each target is on the field, and",
            "         * where the phone resides on the robot.  These specifications are in the form of <em>transformation matrices.</em>",
            "         * Transformation matrices are a central, important concept in the math here involved in localization.",
            "         * See <a href=\\\"https://en.wikipedia.org/wiki/Transformation_matrix\\\">Transformation Matrix</a>",
            "         * for detailed information. Commonly, you'll encounter transformation matrices as instances",
            "         * of the {@link OpenGLMatrix} class.",
            "         *",
            "         * If you are standing in the Red Alliance Station looking towards the center of the field,",
            "         *     - The X axis runs from your left to the right. (positive from the center to the right)",
            "         *     - The Y axis runs from the Red Alliance Station towards the other side of the field",
            "         *       where the Blue Alliance Station is. (Positive is from the center, towards the BlueAlliance station)",
            "         *     - The Z axis runs from the floor, upwards towards the ceiling.  (Positive is above the floor)",
            "         *",
            "         * Before being transformed, each target image is conceptually located at the origin of the field's",
            "         *  coordinate system (the center of the field), facing up.",
            "         */",
            "",
            "        // Name and locate each trackable object",
            "        identifyTarget(0, \\\"Red Audience Wall\\\",   -halfField,  -oneAndHalfTile, mmTargetHeight, 90, 0,  90);",
            "        identifyTarget(1, \\\"Red Rear Wall\\\",        halfField,  -oneAndHalfTile, mmTargetHeight, 90, 0, -90);",
            "        identifyTarget(2, \\\"Blue Audience Wall\\\",  -halfField,   oneAndHalfTile, mmTargetHeight, 90, 0,  90);",
            "        identifyTarget(3, \\\"Blue Rear Wall\\\",       halfField,   oneAndHalfTile, mmTargetHeight, 90, 0, -90);",
            "",
            "        /*",
            "         * Create a transformation matrix describing where the camera is on the robot.",
            "         *",
            "         * Info:  The coordinate frame for the robot looks the same as the field.",
            "         * The robot's \\\"forward\\\" direction is facing out along X axis, with the LEFT side facing out along the Y axis.",
            "         * Z is UP on the robot.  This equates to a bearing angle of Zero degrees.",
            "         *",
            "         * For a WebCam, the default starting orientation of the camera is looking UP (pointing in the Z direction),",
            "         * with the wide (horizontal) axis of the camera aligned with the X axis, and",
            "         * the Narrow (vertical) axis of the camera aligned with the Y axis",
            "         *",
            "         * But, this example assumes that the camera is actually facing forward out the front of the robot.",
            "         * So, the \\\"default\\\" camera position requires two rotations to get it oriented correctly.",
            "         * 1) First it must be rotated +90 degrees around the X axis to get it horizontal (its now facing out the right side of the robot)",
            "         * 2) Next it must be be rotated +90 degrees (counter-clockwise) around the Z axis to face forward.",
            "         *",
            "         * Finally the camera can be translated to its actual mounting position on the robot.",
            "         *      In this example, it is centered on the robot (left-to-right and front-to-back), and 6 inches above ground level.",
            "         */",
            "",
            "        final float CAMERA_FORWARD_DISPLACEMENT  = 0.0f * mmPerInch;   // eg: Enter the forward distance from the center of the robot to the camera lens",
            "        final float CAMERA_VERTICAL_DISPLACEMENT = 6.0f * mmPerInch;   // eg: Camera is 6 Inches above ground",
            "        final float CAMERA_LEFT_DISPLACEMENT     = 0.0f * mmPerInch;   // eg: Enter the left distance from the center of the robot to the camera lens",
            "",
            "        OpenGLMatrix cameraLocationOnRobot = OpenGLMatrix",
            "                    .translation(CAMERA_FORWARD_DISPLACEMENT, CAMERA_LEFT_DISPLACEMENT, CAMERA_VERTICAL_DISPLACEMENT)",
            "                    .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XZY, DEGREES, 90, 90, 0));",
            "",
            "        /**  Let all the trackable listeners know where the camera is.  */",
            "        for (VuforiaTrackable trackable : allTrackables) {",
            "            ((VuforiaTrackableDefaultListener) trackable.getListener()).setCameraLocationOnRobot(parameters.cameraName, cameraLocationOnRobot);",
            "        }",
            "",
            "        /*",
            "         * WARNING:",
            "         * In this sample, we do not wait for PLAY to be pressed.  Target Tracking is started immediately when INIT is pressed.",
            "         * This sequence is used to enable the new remote DS Camera Preview feature to be used with this sample.",
            "         * CONSEQUENTLY do not put any driving commands in this loop.",
            "         * To restore the normal opmode structure, just un-comment the following line:",
            "         */",
            "",
            "        // waitForStart();",
            "",
            "        /* Note: To use the remote camera preview:",
            "         * AFTER you hit Init on the Driver Station, use the \\\"options menu\\\" to select \\\"Camera Stream\\\"",
            "         * Tap the preview window to receive a fresh image.",
            "         * It is not permitted to transition to RUN while the camera preview window is active.",
            "         * Either press STOP to exit the OpMode, or use the \\\"options menu\\\" again, and select \\\"Camera Stream\\\" to close the preview window.",
            "         */",
            "",
            "        targets.activate();",
            "        while (!isStopRequested()) {",
            "",
            "            // check all the trackable targets to see which one (if any) is visible.",
            "            targetVisible = false;",
            "            for (VuforiaTrackable trackable : allTrackables) {",
            "                if (((VuforiaTrackableDefaultListener)trackable.getListener()).isVisible()) {",
            "                    telemetry.addData(\\\"Visible Target\\\", trackable.getName());",
            "                    targetVisible = true;",
            "",
            "                    // getUpdatedRobotLocation() will return null if no new information is available since",
            "                    // the last time that call was made, or if the trackable is not currently visible.",
            "                    OpenGLMatrix robotLocationTransform = ((VuforiaTrackableDefaultListener)trackable.getListener()).getUpdatedRobotLocation();",
            "                    if (robotLocationTransform != null) {",
            "                        lastLocation = robotLocationTransform;",
            "                    }",
            "                    break;",
            "                }",
            "            }",
            "",
            "            // Provide feedback as to where the robot is located (if we know).",
            "            if (targetVisible) {",
            "                // express position (translation) of robot in inches.",
            "                VectorF translation = lastLocation.getTranslation();",
            "                telemetry.addData(\\\"Pos (inches)\\\", \\\"{X, Y, Z} = %.1f, %.1f, %.1f\\\",",
            "                        translation.get(0) / mmPerInch, translation.get(1) / mmPerInch, translation.get(2) / mmPerInch);",
            "",
            "                // express the rotation of the robot in degrees.",
            "                Orientation rotation = Orientation.getOrientation(lastLocation, EXTRINSIC, XYZ, DEGREES);",
            "                telemetry.addData(\\\"Rot (deg)\\\", \\\"{Roll, Pitch, Heading} = %.0f, %.0f, %.0f\\\", rotation.firstAngle, rotation.secondAngle, rotation.thirdAngle);",
            "            }",
            "            else {",
            "                telemetry.addData(\\\"Visible Target\\\", \\\"none\\\");",
            "            }",
            "            telemetry.update();",
            "        }",
            "",
            "        // Disable Tracking when we are done;",
            "        targets.deactivate();",
            "    }",
            "",
            "    /***",
            "     * Identify a target by naming it, and setting its position and orientation on the field",
            "     * @param targetIndex",
            "     * @param targetName",
            "     * @param dx, dy, dz  Target offsets in x,y,z axes",
            "     * @param rx, ry, rz  Target rotations in x,y,z axes",
            "     */",
            "    void    identifyTarget(int targetIndex, String targetName, float dx, float dy, float dz, float rx, float ry, float rz) {",
            "        VuforiaTrackable aTarget = targets.get(targetIndex);",
            "        aTarget.setName(targetName);",
            "        aTarget.setLocation(OpenGLMatrix.translation(dx, dy, dz)",
            "                .multiplied(Orientation.getRotationMatrix(EXTRINSIC, XYZ, DEGREES, rx, ry, rz)));",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptVuforiaDriveToTargetWebcam": {
        "prefix": "conceptVuforiaDriveToTargetWebcam",
        "description": "This OpMode illustrates using a webcam to locate and drive towards ANY Vuforia target.\nThe code assumes a basic two-wheel Robot Configuration with motors named left_drive and right_drive.\nThe motor directions must be set so a positive drive goes forward and a positive turn rotates to the right.\n\nUnder manual control, the left stick will move forward/back, and the right stick will turn left/right.\nThis is called POV Joystick mode, different than Tank Drive (where each joystick controls a wheel).\nManually drive the robot until it displays Target data on the Driver Station.\nPress and hold theLeft Bumper* to enable the automatic \"Drive to target\" mode.\nRelease the Left Bumper to return to manual driving mode.\n\nUse DESIRED_DISTANCE to set how close you want the robot to get to the target.\nSpeed and Turn sensitivity can be adjusted using the SPEED_GAIN and TURN_GAIN constants.\n\nFor more Vuforia details, or to adapt this OpMode for a phone camera, view the\n ConceptVuforiaFieldNavigation and ConceptVuforiaFieldNavigationWebcam samples.\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list.\n\nIMPORTANT: In order to use this OpMode, you need to obtain your own Vuforia license key as\nis explained below.\n ",
        "body": [
            "public class ConceptVuforiaDriveToTargetWebcam extends LinearOpMode",
            "{",
            "    // Adjust these numbers to suit your robot.",
            "    final double DESIRED_DISTANCE = 8.0; //  this is how close the camera should get to the target (inches)",
            "                                         //  The GAIN constants set the relationship between the measured position error,",
            "                                         //  and how much power is applied to the drive motors.  Drive = Error * Gain",
            "                                         //  Make these values smaller for smoother control.",
            "    final double SPEED_GAIN =   0.02 ;   //  Speed Control \"Gain\\\". eg: Ramp up to 50% power at a 25 inch error.   (0.50 / 25.0)",
            "    final double TURN_GAIN  =   0.01 ;   //  Turn Control \\\"Gain\\\".  eg: Ramp up to 25% power at a 25 degree error. (0.25 / 25.0)",
            "",
            "    final double MM_PER_INCH = 25.40 ;   //  Metric conversion",
            "",
            "    /*",
            "     * IMPORTANT: You need to obtain your own license key to use Vuforia. The string below with which",
            "     * 'parameters.vuforiaLicenseKey' is initialized is for illustration only, and will not function.",
            "     * A Vuforia 'Development' license key, can be obtained free of charge from the Vuforia developer",
            "     * web site at https://developer.vuforia.com/license-manager.",
            "     *",
            "     * Vuforia license keys are always 380 characters long, and look as if they contain mostly",
            "     * random data. As an example, here is a example of a fragment of a valid key:",
            "     *      ... yIgIzTqZ4mWjk9wd3cZO9T1axEqzuhxoGlfOOI2dRzKS4T0hQ8kT ...",
            "     * Once you've obtained a license key, copy the string from the Vuforia web site",
            "     * and paste it in to your code on the next line, between the double quotes.",
            "     */",
            "    private static final String VUFORIA_KEY =",
            "            \\\" --- YOUR NEW VUFORIA KEY GOES HERE  --- \\\";",
            "",
            "    VuforiaLocalizer vuforia    = null;",
            "    OpenGLMatrix targetPose     = null;",
            "    String targetName           = \\\"\\\";",
            "",
            "    private DcMotor leftDrive   = null;",
            "    private DcMotor rightDrive  = null;",
            "",
            "    @Override public void runOpMode()",
            "    {",
            "        /*",
            "         * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine.",
            "         * To get an on-phone camera preview, use the code below.",
            "         * If no camera preview is desired, use the parameter-less constructor instead (commented out below).",
            "         */",
            "        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\\\"cameraMonitorViewId\\\", \\\"id\\\", hardwareMap.appContext.getPackageName());",
            "        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId);",
            "        // VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters();",
            "",
            "        parameters.vuforiaLicenseKey = VUFORIA_KEY;",
            "",
            "        // Turn off Extended tracking.  Set this true if you want Vuforia to track beyond the target.",
            "        parameters.useExtendedTracking = false;",
            "",
            "        // Connect to the camera we are to use.  This name must match what is set up in Robot Configuration",
            "        parameters.cameraName = hardwareMap.get(WebcamName.class, \\\"Webcam 1\\\");",
            "        this.vuforia = ClassFactory.getInstance().createVuforia(parameters);",
            "",
            "        // Load the trackable objects from the Assets file, and give them meaningful names",
            "        VuforiaTrackables targetsPowerPlay = this.vuforia.loadTrackablesFromAsset(\\\"PowerPlay\\\");",
            "        targetsPowerPlay.get(0).setName(\\\"Red Audience Wall\\\");",
            "        targetsPowerPlay.get(1).setName(\\\"Red Rear Wall\\\");",
            "        targetsPowerPlay.get(2).setName(\\\"Blue Audience Wall\\\");",
            "        targetsPowerPlay.get(3).setName(\\\"Blue Rear Wall\\\");",
            "",
            "        // Start tracking targets in the background",
            "        targetsPowerPlay.activate();",
            "",
            "        // Initialize the hardware variables. Note that the strings used here as parameters",
            "        // to 'get' must correspond to the names assigned during the robot configuration",
            "        // step (using the FTC Robot Controller app on the phone).",
            "        leftDrive  = hardwareMap.get(DcMotor.class, \\\"left_drive\\\");",
            "        rightDrive = hardwareMap.get(DcMotor.class, \\\"right_drive\\\");",
            "",
            "        // To drive forward, most robots need the motor on one side to be reversed, because the axles point in opposite directions.",
            "        // When run, this OpMode should start both motors driving forward. So adjust these two lines based on your first test drive.",
            "        // Note: The settings here assume direct drive on left and right wheels.  Gear Reduction or 90 Deg drives may require direction flips",
            "        leftDrive.setDirection(DcMotor.Direction.REVERSE);",
            "        rightDrive.setDirection(DcMotor.Direction.FORWARD);",
            "",
            "        telemetry.addData(\\\">\\\", \\\"Press Play to start\\\");",
            "        telemetry.update();",
            "",
            "        waitForStart();",
            "",
            "        boolean targetFound     = false;    // Set to true when a target is detected by Vuforia",
            "        double  targetRange     = 0;        // Distance from camera to target in Inches",
            "        double  targetBearing   = 0;        // Robot Heading, relative to target.  Positive degrees means target is to the right.",
            "        double  drive           = 0;        // Desired forward power (-1 to +1)",
            "        double  turn            = 0;        // Desired turning power (-1 to +1)",
            "",
            "        while (opModeIsActive())",
            "        {",
            "            // Look for first visible target, and save its pose.",
            "            targetFound = false;",
            "            for (VuforiaTrackable trackable : targetsPowerPlay)",
            "            {",
            "                if (((VuforiaTrackableDefaultListener) trackable.getListener()).isVisible())",
            "                {",
            "                    targetPose = ((VuforiaTrackableDefaultListener)trackable.getListener()).getVuforiaCameraFromTarget();",
            "",
            "                    // if we have a target, process the \\\"pose\\\" to determine the position of the target relative to the robot.",
            "                    if (targetPose != null)",
            "                    {",
            "                        targetFound = true;",
            "                        targetName  = trackable.getName();",
            "                        VectorF trans = targetPose.getTranslation();",
            "",
            "                        // Extract the X & Y components of the offset of the target relative to the robot",
            "                        double targetX = trans.get(0) / MM_PER_INCH; // Image X axis",
            "                        double targetY = trans.get(2) / MM_PER_INCH; // Image Z axis",
            "",
            "                        // target range is based on distance from robot position to origin (right triangle).",
            "                        targetRange = Math.hypot(targetX, targetY);",
            "",
            "                        // target bearing is based on angle formed between the X axis and the target range line",
            "                        targetBearing = Math.toDegrees(Math.asin(targetX / targetRange));",
            "",
            "                        break;  // jump out of target tracking loop if we find a target.",
            "                    }",
            "                }",
            "            }",
            "",
            "            // Tell the driver what we see, and what to do.",
            "            if (targetFound) {",
            "                telemetry.addData(\\\">\\\",\\\"HOLD Left-Bumper to Drive to Target\\n\\\");",
            "                telemetry.addData(\\\"Target\\\", \\\" %s\\\", targetName);",
            "                telemetry.addData(\\\"Range\\\",  \\\"%5.1f inches\\\", targetRange);",
            "                telemetry.addData(\\\"Bearing\\\",\\\"%3.0f degrees\\\", targetBearing);",
            "            } else {",
            "                telemetry.addData(\\\">\\\",\\\"Drive using joystick to find target\\n\\\");",
            "            }",
            "",
            "            // Drive to target Automatically if Left Bumper is being pressed, AND we have found a target.",
            "            if (gamepad1.left_bumper && targetFound) {",
            "",
            "                // Determine heading and range error so we can use them to control the robot automatically.",
            "                double  rangeError   = (targetRange - DESIRED_DISTANCE);",
            "                double  headingError = targetBearing;",
            "",
            "                // Use the speed and turn \\\"gains\\\" to calculate how we want the robot to move.",
            "                drive = rangeError * SPEED_GAIN;",
            "                turn  = headingError * TURN_GAIN ;",
            "",
            "                telemetry.addData(\\\"Auto\\\",\\\"Drive %5.2f, Turn %5.2f\\\", drive, turn);",
            "            } else {",
            "",
            "                // drive using manual POV Joystick mode.",
            "                drive = -gamepad1.left_stick_y  / 2.0;  // Reduce drive rate to 50%.",
            "                turn  =  gamepad1.right_stick_x / 4.0;  // Reduce turn rate to 25%.",
            "                telemetry.addData(\\\"Manual\\\",\\\"Drive %5.2f, Turn %5.2f\\\", drive, turn);",
            "            }",
            "            telemetry.update();",
            "",
            "            // Calculate left and right wheel powers and send to them to the motors.",
            "            double leftPower    = Range.clip(drive + turn, -1.0, 1.0) ;",
            "            double rightPower   = Range.clip(drive - turn, -1.0, 1.0) ;",
            "            leftDrive.setPower(leftPower);",
            "            rightDrive.setPower(rightPower);",
            "",
            "            sleep(10);",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptExternalHardwareClass": {
        "prefix": "conceptExternalHardwareClass",
        "description": "This OpMode Sample illustrates how to use an external \"hardware\" class to modularize all the robot's sensors and actuators.\nThis approach is very efficient because the same hardware class can be used by all of your teleop and autonomous OpModes\nwithout requiring many copy & paste operations.  Once you have defined and tested the hardware class with one OpMode,\nit is instantly available to other OpModes.\n\nThe real benefit of this approach is that as you tweak your robot hardware, you only need to make changes in ONE place (the Hardware Class).\nSo, to be effective you should put as much or your hardware setup and access code as possible in the hardware class.\nEssentially anything you do with hardware in BOTH Teleop and Auto should likely go in the hardware class.\n\nThe Hardware Class is created in a separate file, and then an \"instance\" of this class is created in each OpMode.\nIn order for the class to do typical OpMode things (like send telemetry data) it must be passed a reference to the\nOpMode object when it's created, so it can access all core OpMode functions.  This is illustrated below.\n\nIn this concept sample, the hardware class file is called RobotHardware.java and it must accompany this sample OpMode.\nSo, if you copy ConceptExternalHardwareClass.java into TeamCode (using Android Studio or OnBotJava) then RobotHardware.java\nmust also be copied to the same location (maintaining its name).\n\nFor comparison purposes, this sample and its accompanying hardware class duplicates the functionality of the\nRobotTelopPOV_Linear opmode.  It assumes three motors (left_drive, right_drive and arm) and two servos (left_hand and right_hand)\n\nView the RobotHardware.java class file for more details\n\n Use Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\n Remove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list\n\n In OnBot Java, add a new OpMode, drawing from this Sample; select TeleOp.\n Also add another new file named RobotHardware.java, drawing from the Sample with that name; select Not an OpMode.\n ",
        "body": [
            "public class ConceptExternalHardwareClass extends LinearOpMode {",
            "",
            "    // Create a RobotHardware object to be used to access robot hardware.",
            "    // Prefix any hardware functions with \"robot.\\\" to access this class.",
            "    RobotHardware   robot       = new RobotHardware(this);",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "        double drive        = 0;",
            "        double turn         = 0;",
            "        double arm          = 0;",
            "        double handOffset   = 0;",
            "",
            "        // initialize all the hardware, using the hardware class. See how clean and simple this is?",
            "        robot.init();",
            "",
            "        // Send telemetry message to signify robot waiting;",
            "        // Wait for the game to start (driver presses PLAY)",
            "        waitForStart();",
            "",
            "        // run until the end of the match (driver presses STOP)",
            "        while (opModeIsActive()) {",
            "",
            "            // Run wheels in POV mode (note: The joystick goes negative when pushed forward, so negate it)",
            "            // In this mode the Left stick moves the robot fwd and back, the Right stick turns left and right.",
            "            // This way it's also easy to just drive straight, or just turn.",
            "            drive = -gamepad1.left_stick_y;",
            "            turn  =  gamepad1.right_stick_x;",
            "",
            "            // Combine drive and turn for blended motion. Use RobotHardware class",
            "            robot.driveRobot(drive, turn);",
            "",
            "            // Use gamepad left & right Bumpers to open and close the claw",
            "            // Use the SERVO constants defined in RobotHardware class.",
            "            // Each time around the loop, the servos will move by a small amount.",
            "            // Limit the total offset to half of the full travel range",
            "            if (gamepad1.right_bumper)",
            "                handOffset += robot.HAND_SPEED;",
            "            else if (gamepad1.left_bumper)",
            "                handOffset -= robot.HAND_SPEED;",
            "            handOffset = Range.clip(handOffset, -0.5, 0.5);",
            "",
            "            // Move both servos to new position.  Use RobotHardware class",
            "            robot.setHandPositions(handOffset);",
            "",
            "            // Use gamepad buttons to move arm up (Y) and down (A)",
            "            // Use the MOTOR constants defined in RobotHardware class.",
            "            if (gamepad1.y)",
            "                arm = robot.ARM_UP_POWER;",
            "            else if (gamepad1.a)",
            "                arm = robot.ARM_DOWN_POWER;",
            "            else",
            "                arm = 0;",
            "",
            "            robot.setArmPower(arm);",
            "",
            "            // Send telemetry messages to explain controls and show robot status",
            "            telemetry.addData(\\\"Drive\\\", \\\"Left Stick\\\");",
            "            telemetry.addData(\\\"Turn\\\", \\\"Right Stick\\\");",
            "            telemetry.addData(\\\"Arm Up/Down\\\", \\\"Y & A Buttons\\\");",
            "            telemetry.addData(\\\"Hand Open/Closed\\\", \\\"Left and Right Bumpers\\\");",
            "            telemetry.addData(\\\"-\\\", \\\"-------\\\");",
            "",
            "            telemetry.addData(\\\"Drive Power\\\", \\\"%.2f\\\", drive);",
            "            telemetry.addData(\\\"Turn Power\\\",  \\\"%.2f\\\", turn);",
            "            telemetry.addData(\\\"Arm Power\\\",  \\\"%.2f\\\", arm);",
            "            telemetry.addData(\\\"Hand Position\\\",  \\\"Offset = %.2f\\\", handOffset);",
            "            telemetry.update();",
            "",
            "            // Pace this loop so hands move at a reasonable speed.",
            "            sleep(50);",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "ConceptExploringIMUOrientation": {
        "prefix": "conceptExploringIMUOrientation",
        "description": "This file demonstrates the impact of setting the IMU orientation correctly or incorrectly. This\ncode assumes there is an IMU configured with the name \"imu\".\n<p>\nNote: This OpMode is more of a tool than a code sample. The User Interface portion of this code\n      goes beyond simply showing how to interface to the IMU.<br>\n      For a minimal example of interfacing to an IMU, please see the SensorIMUOrthogonal or SensorIMUNonOrthogonal sample OpModes.\n<p>\nThis sample enables you to re-specify the Hub Mounting orientation dynamically by using gamepad controls.\nWhile doing so, the sample will display how Pitch, Roll and Yaw angles change as the hub is moved.\n<p>\nThe gamepad controls let you change the two parameters that specify how the Control/Expansion Hub is mounted. <br>\nThe first parameter specifies which direction the printed logo on the Hub is pointing. <br>\nThe second parameter specifies which direction the USB connector on the Hub is pointing. <br>\nAll directions are relative to the robot, and left/right is as viewed from behind the robot.\n<p>\nHow will you know if you have chosen the correct Orientation? With the correct orientation\nparameters selected, pitch/roll/yaw should act as follows:\n<p>\n  Pitch value should INCREASE as the robot is tipped UP at the front. (Rotation about X) <br>\n  Roll value should INCREASE as the robot is tipped UP at the left side. (Rotation about Y) <br>\n  Yaw value should INCREASE as the robot is rotated Counter Clockwise. (Rotation about Z) <br>\n<p>\nThe Yaw can be reset (to zero) by pressing the Y button on the gamepad (Triangle on a PS4 controller)\n<p>\nThe rotational velocities should follow the change in corresponding axes.\n ",
        "body": [
            "public class ConceptExploringIMUOrientation extends LinearOpMode {",
            "    static RevHubOrientationOnRobot.LogoFacingDirection[] logoFacingDirections",
            "            = RevHubOrientationOnRobot.LogoFacingDirection.values();",
            "    static RevHubOrientationOnRobot.UsbFacingDirection[] usbFacingDirections",
            "            = RevHubOrientationOnRobot.UsbFacingDirection.values();",
            "    static int LAST_DIRECTION = logoFacingDirections.length - 1;",
            "    static float TRIGGER_THRESHOLD = 0.2f;",
            "            ",
            "    IMU imu;",
            "    int logoFacingDirectionPosition;",
            "    int usbFacingDirectionPosition;",
            "    boolean orientationIsValid = true;",
            "",
            "    @Override public void runOpMode() throws InterruptedException {",
            "        imu = hardwareMap.get(IMU.class, \"imu\\\");",
            "        logoFacingDirectionPosition = 0; // Up",
            "        usbFacingDirectionPosition = 2; // Forward",
            "",
            "        updateOrientation();",
            "",
            "        boolean justChangedLogoDirection = false;",
            "        boolean justChangedUsbDirection = false;",
            "",
            "        // Loop until stop requested",
            "        while (!isStopRequested()) {",
            "",
            "            // Check to see if Yaw reset is requested (Y button)",
            "            if (gamepad1.y) {",
            "                telemetry.addData(\\\"Yaw\\\", \\\"Resetting\\n\\\");",
            "                imu.resetYaw();",
            "            } else {",
            "                telemetry.addData(\\\"Yaw\\\", \\\"Press Y (triangle) on Gamepad to reset.\\n\\\");",
            "            }",
            "",
            "            // Check to see if new Logo Direction is requested",
            "            if (gamepad1.left_bumper || gamepad1.right_bumper) {",
            "                if (!justChangedLogoDirection) {",
            "                    justChangedLogoDirection = true;",
            "                    if (gamepad1.left_bumper) {",
            "                        logoFacingDirectionPosition--;",
            "                        if (logoFacingDirectionPosition < 0) {",
            "                            logoFacingDirectionPosition = LAST_DIRECTION;",
            "                        }",
            "                    } else {",
            "                        logoFacingDirectionPosition++;",
            "                        if (logoFacingDirectionPosition > LAST_DIRECTION) {",
            "                            logoFacingDirectionPosition = 0;",
            "                        }",
            "                    }",
            "                    updateOrientation();",
            "                }",
            "            } else {",
            "                justChangedLogoDirection = false;",
            "            }",
            "",
            "            // Check to see if new USB Direction is requested",
            "            if (gamepad1.left_trigger > TRIGGER_THRESHOLD || gamepad1.right_trigger > TRIGGER_THRESHOLD) {",
            "                if (!justChangedUsbDirection) {",
            "                    justChangedUsbDirection = true;",
            "                    if (gamepad1.left_trigger > TRIGGER_THRESHOLD) {",
            "                        usbFacingDirectionPosition--;",
            "                        if (usbFacingDirectionPosition < 0) {",
            "                            usbFacingDirectionPosition = LAST_DIRECTION;",
            "                        }",
            "                    } else {",
            "                        usbFacingDirectionPosition++;",
            "                        if (usbFacingDirectionPosition > LAST_DIRECTION) {",
            "                            usbFacingDirectionPosition = 0;",
            "                        }",
            "                    }",
            "                    updateOrientation();",
            "                }",
            "            } else {",
            "                justChangedUsbDirection = false;",
            "            }",
            "",
            "            // Display User instructions and IMU data",
            "            telemetry.addData(\\\"logo Direction (set with bumpers)\\\", logoFacingDirections[logoFacingDirectionPosition]);",
            "            telemetry.addData(\\\"usb Direction (set with triggers)\\\", usbFacingDirections[usbFacingDirectionPosition] + \\\"\\n\\\");",
            "",
            "            if (orientationIsValid) {",
            "                YawPitchRollAngles orientation = imu.getRobotYawPitchRollAngles();",
            "                AngularVelocity angularVelocity = imu.getRobotAngularVelocity(AngleUnit.DEGREES);",
            "",
            "                telemetry.addData(\\\"Yaw (Z)\\\", \\\"%.2f Deg. (Heading)\\\", orientation.getYaw(AngleUnit.DEGREES));",
            "                telemetry.addData(\\\"Pitch (X)\\\", \\\"%.2f Deg.\\\", orientation.getPitch(AngleUnit.DEGREES));",
            "                telemetry.addData(\\\"Roll (Y)\\\", \\\"%.2f Deg.\\n\\\", orientation.getRoll(AngleUnit.DEGREES));",
            "                telemetry.addData(\\\"Yaw (Z) velocity\\\", \\\"%.2f Deg/Sec\\\", angularVelocity.zRotationRate);",
            "                telemetry.addData(\\\"Pitch (X) velocity\\\", \\\"%.2f Deg/Sec\\\", angularVelocity.xRotationRate);",
            "                telemetry.addData(\\\"Roll (Y) velocity\\\", \\\"%.2f Deg/Sec\\\", angularVelocity.yRotationRate);",
            "            } else {",
            "                telemetry.addData(\\\"Error\\\", \\\"Selected orientation on robot is invalid\\\");",
            "            }",
            "",
            "            telemetry.update();",
            "        }",
            "    }",
            "",
            "    // apply any requested orientation changes.",
            "    void updateOrientation() {",
            "        RevHubOrientationOnRobot.LogoFacingDirection logo = logoFacingDirections[logoFacingDirectionPosition];",
            "        RevHubOrientationOnRobot.UsbFacingDirection usb = usbFacingDirections[usbFacingDirectionPosition];",
            "        try {",
            "            RevHubOrientationOnRobot orientationOnRobot = new RevHubOrientationOnRobot(logo, usb);",
            "            imu.initialize(new IMU.Parameters(orientationOnRobot));",
            "            orientationIsValid = true;",
            "        } catch (IllegalArgumentException e) {",
            "            orientationIsValid = false;",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "BasicOmniOpMode Linear": {
        "prefix": "basicOmniOpModeLinear",
        "description": "This file contains an example of a Linear \"OpMode\".\nAn OpMode is a 'program' that runs in either the autonomous or the teleop period of an FTC match.\nThe names of OpModes appear on the menu of the FTC Driver Station.\nWhen a selection is made from the menu, the corresponding OpMode is executed.\n\nThis particular OpMode illustrates driving a 4-motor Omni-Directional (or Holonomic) robot.\nThis code will work with either a Mecanum-Drive or an X-Drive train.\nBoth of these drives are illustrated at https://gm0.org/en/latest/docs/robot-design/drivetrains/holonomic.html\nNote that a Mecanum drive must display an X roller-pattern when viewed from above.\n\nAlso note that it is critical to set the correct rotation direction for each motor.  See details below.\n\nHolonomic drives provide the ability for the robot to move in three axes (directions) simultaneously.\nEach motion axis is controlled by one Joystick axis.\n\n1) Axial:    Driving forward and backward               Left-joystick Forward/Backward\n2) Lateral:  Strafing right and left                     Left-joystick Right and Left\n3) Yaw:      Rotating Clockwise and counter clockwise    Right-joystick Right and Left\n\nThis code is written assuming that the right-side motors need to be reversed for the robot to drive forward.\nWhen you first test your robot, if it moves backward when you push the left stick forward, then you must flip\nthe direction of all 4 motors (see code below).\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list\n ",
        "body": [
            "public class BasicOmniOpMode_Linear extends LinearOpMode {",
            "",
            "    // Declare OpMode members for each of the 4 motors.",
            "    private ElapsedTime runtime = new ElapsedTime();",
            "    private DcMotor leftFrontDrive = null;",
            "    private DcMotor leftBackDrive = null;",
            "    private DcMotor rightFrontDrive = null;",
            "    private DcMotor rightBackDrive = null;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        // Initialize the hardware variables. Note that the strings used here must correspond",
            "        // to the names assigned during the robot configuration step on the DS or RC devices.",
            "        leftFrontDrive  = hardwareMap.get(DcMotor.class, \"left_front_drive\\\");",
            "        leftBackDrive  = hardwareMap.get(DcMotor.class, \\\"left_back_drive\\\");",
            "        rightFrontDrive = hardwareMap.get(DcMotor.class, \\\"right_front_drive\\\");",
            "        rightBackDrive = hardwareMap.get(DcMotor.class, \\\"right_back_drive\\\");",
            "",
            "        // ########################################################################################",
            "        // !!!            IMPORTANT Drive Information. Test your motor directions.            !!!!!",
            "        // ########################################################################################",
            "        // Most robots need the motors on one side to be reversed to drive forward.",
            "        // The motor reversals shown here are for a \\\"direct drive\\\" robot (the wheels turn the same direction as the motor shaft)",
            "        // If your robot has additional gear reductions or uses a right-angled drive, it's important to ensure",
            "        // that your motors are turning in the correct direction.  So, start out with the reversals here, BUT",
            "        // when you first test your robot, push the left joystick forward and observe the direction the wheels turn.",
            "        // Reverse the direction (flip FORWARD <-> REVERSE ) of any wheel that runs backward",
            "        // Keep testing until ALL the wheels move the robot forward when you push the left joystick forward.",
            "        leftFrontDrive.setDirection(DcMotor.Direction.REVERSE);",
            "        leftBackDrive.setDirection(DcMotor.Direction.REVERSE);",
            "        rightFrontDrive.setDirection(DcMotor.Direction.FORWARD);",
            "        rightBackDrive.setDirection(DcMotor.Direction.FORWARD);",
            "",
            "        // Wait for the game to start (driver presses PLAY)",
            "        telemetry.addData(\\\"Status\\\", \\\"Initialized\\\");",
            "        telemetry.update();",
            "",
            "        waitForStart();",
            "        runtime.reset();",
            "",
            "        // run until the end of the match (driver presses STOP)",
            "        while (opModeIsActive()) {",
            "            double max;",
            "",
            "            // POV Mode uses left joystick to go forward & strafe, and right joystick to rotate.",
            "            double axial   = -gamepad1.left_stick_y;  // Note: pushing stick forward gives negative value",
            "            double lateral =  gamepad1.left_stick_x;",
            "            double yaw     =  gamepad1.right_stick_x;",
            "",
            "            // Combine the joystick requests for each axis-motion to determine each wheel's power.",
            "            // Set up a variable for each drive wheel to save the power level for telemetry.",
            "            double leftFrontPower  = axial + lateral + yaw;",
            "            double rightFrontPower = axial - lateral - yaw;",
            "            double leftBackPower   = axial - lateral + yaw;",
            "            double rightBackPower  = axial + lateral - yaw;",
            "",
            "            // Normalize the values so no wheel power exceeds 100%",
            "            // This ensures that the robot maintains the desired motion.",
            "            max = Math.max(Math.abs(leftFrontPower), Math.abs(rightFrontPower));",
            "            max = Math.max(max, Math.abs(leftBackPower));",
            "            max = Math.max(max, Math.abs(rightBackPower));",
            "",
            "            if (max > 1.0) {",
            "                leftFrontPower  /= max;",
            "                rightFrontPower /= max;",
            "                leftBackPower   /= max;",
            "                rightBackPower  /= max;",
            "            }",
            "",
            "            // This is test code:",
            "            //",
            "            // Uncomment the following code to test your motor directions.",
            "            // Each button should make the corresponding motor run FORWARD.",
            "            //   1) First get all the motors to take to correct positions on the robot",
            "            //      by adjusting your Robot Configuration if necessary.",
            "            //   2) Then make sure they run in the correct direction by modifying the",
            "            //      the setDirection() calls above.",
            "            // Once the correct motors move in the correct direction re-comment this code.",
            "",
            "            /*",
            "            leftFrontPower  = gamepad1.x ? 1.0 : 0.0;  // X gamepad",
            "            leftBackPower   = gamepad1.a ? 1.0 : 0.0;  // A gamepad",
            "            rightFrontPower = gamepad1.y ? 1.0 : 0.0;  // Y gamepad",
            "            rightBackPower  = gamepad1.b ? 1.0 : 0.0;  // B gamepad",
            "            */",
            "",
            "            // Send calculated power to wheels",
            "            leftFrontDrive.setPower(leftFrontPower);",
            "            rightFrontDrive.setPower(rightFrontPower);",
            "            leftBackDrive.setPower(leftBackPower);",
            "            rightBackDrive.setPower(rightBackPower);",
            "",
            "            // Show the elapsed game time and wheel power.",
            "            telemetry.addData(\\\"Status\\\", \\\"Run Time: \\\" + runtime.toString());",
            "            telemetry.addData(\\\"Front left/Right\\\", \\\"%4.2f, %4.2f\\\", leftFrontPower, rightFrontPower);",
            "            telemetry.addData(\\\"Back  left/Right\\\", \\\"%4.2f, %4.2f\\\", leftBackPower, rightBackPower);",
            "            telemetry.update();",
            "        }",
            "    }}",
            ""
        ]
    },
    "SensorIMUOrthogonal": {
        "prefix": "sensorIMUOrthogonal",
        "description": "{@link SensorIMUOrthogonal} shows how to use the new universal {@link IMU} interface. This\ninterface may be used with the BNO055 IMU or the BHI260 IMU. It assumes that an IMU is configured\non the robot with the name \"imu\".\n<p>\nThe sample will display the current Yaw, Pitch and Roll of the robot.<br>\nWith the correct orientation parameters selected, pitch/roll/yaw should act as follows:\n<p>\n  Pitch value should INCREASE as the robot is tipped UP at the front. (Rotation about X) <br>\n  Roll value should INCREASE as the robot is tipped UP at the left side. (Rotation about Y) <br>\n  Yaw value should INCREASE as the robot is rotated Counter Clockwise. (Rotation about Z) <br>\n<p>\nThe yaw can be reset (to zero) by pressing the Y button on the gamepad (Triangle on a PS4 controller)\n<p>\nThis specific sample assumes that the Hub is mounted on one of the three orthogonal planes\n(X/Y, X/Z or Y/Z) and that the Hub has only been rotated in a range of 90 degree increments.\n<p>\nNote: if your Hub is mounted on a surface angled at some non-90 Degree multiple (like 30) look at\n      the alternative SensorImuNonOrthogonal sample in this folder.\n<p>\nThis \"Orthogonal\" requirement means that:\n<p>\n1) The Logo printed on the top of the Hub can ONLY be pointing in one of six directions:\n   FORWARD, BACKWARD, UP, DOWN, LEFT and RIGHT.\n<p>\n2) The USB ports can only be pointing in one of the same six directions:<br>\n   FORWARD, BACKWARD, UP, DOWN, LEFT and RIGHT.\n<p>\nSo, To fully define how your Hub is mounted to the robot, you must simply specify:<br>\n   logoFacingDirection<br>\n   usbFacingDirection\n<p>\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this OpMode to the Driver Station OpMode list.\n<p>\nFinally, choose the two correct parameters to define how your Hub is mounted and edit this OpMode\nto use those parameters.\n ",
        "body": [
            "public class SensorIMUOrthogonal extends LinearOpMode",
            "{",
            "    // The IMU sensor object",
            "    IMU imu;",
            "",
            "    //----------------------------------------------------------------------------------------------",
            "    // Main logic",
            "    //----------------------------------------------------------------------------------------------",
            "",
            "    @Override public void runOpMode() throws InterruptedException {",
            "",
            "        // Retrieve and initialize the IMU.",
            "        // This sample expects the IMU to be in a REV Hub and named \"imu\\\".",
            "        imu = hardwareMap.get(IMU.class, \\\"imu\\\");",
            "",
            "        /* Define how the hub is mounted on the robot to get the correct Yaw, Pitch and Roll values.",
            "         *",
            "         * Two input parameters are required to fully specify the Orientation.",
            "         * The first parameter specifies the direction the printed logo on the Hub is pointing.",
            "         * The second parameter specifies the direction the USB connector on the Hub is pointing.",
            "         * All directions are relative to the robot, and left/right is as-viewed from behind the robot.",
            "         */",
            "",
            "        /* The next two lines define Hub orientation.",
            "         * The Default Orientation (shown) is when a hub is mounted horizontally with the printed logo pointing UP and the USB port pointing FORWARD.",
            "         *",
            "         * To Do:  EDIT these two lines to match YOUR mounting configuration.",
            "         */",
            "        RevHubOrientationOnRobot.LogoFacingDirection logoDirection = RevHubOrientationOnRobot.LogoFacingDirection.UP;",
            "        RevHubOrientationOnRobot.UsbFacingDirection  usbDirection  = RevHubOrientationOnRobot.UsbFacingDirection.FORWARD;",
            "",
            "        RevHubOrientationOnRobot orientationOnRobot = new RevHubOrientationOnRobot(logoDirection, usbDirection);",
            "",
            "        // Now initialize the IMU with this mounting orientation",
            "        // Note: if you choose two conflicting directions, this initialization will cause a code exception.",
            "        imu.initialize(new IMU.Parameters(orientationOnRobot));",
            "",
            "        // Loop and update the dashboard",
            "        while (!isStopRequested()) {",
            "",
            "            telemetry.addData(\\\"Hub orientation\\\", \\\"Logo=%s   USB=%s\\n \\\", logoDirection, usbDirection);",
            "",
            "            // Check to see if heading reset is requested",
            "            if (gamepad1.y) {",
            "                telemetry.addData(\\\"Yaw\\\", \\\"Resetting\\n\\\");",
            "                imu.resetYaw();",
            "            } else {",
            "                telemetry.addData(\\\"Yaw\\\", \\\"Press Y (triangle) on Gamepad to reset\\n\\\");",
            "            }",
            "",
            "            // Retrieve Rotational Angles and Velocities",
            "            YawPitchRollAngles orientation = imu.getRobotYawPitchRollAngles();",
            "            AngularVelocity angularVelocity = imu.getRobotAngularVelocity(AngleUnit.DEGREES);",
            "",
            "            telemetry.addData(\\\"Yaw (Z)\\\", \\\"%.2f Deg. (Heading)\\\", orientation.getYaw(AngleUnit.DEGREES));",
            "            telemetry.addData(\\\"Pitch (X)\\\", \\\"%.2f Deg.\\\", orientation.getPitch(AngleUnit.DEGREES));",
            "            telemetry.addData(\\\"Roll (Y)\\\", \\\"%.2f Deg.\\n\\\", orientation.getRoll(AngleUnit.DEGREES));",
            "            telemetry.addData(\\\"Yaw (Z) velocity\\\", \\\"%.2f Deg/Sec\\\", angularVelocity.zRotationRate);",
            "            telemetry.addData(\\\"Pitch (X) velocity\\\", \\\"%.2f Deg/Sec\\\", angularVelocity.xRotationRate);",
            "            telemetry.addData(\\\"Roll (Y) velocity\\\", \\\"%.2f Deg/Sec\\\", angularVelocity.yRotationRate);",
            "            telemetry.update();",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "RobotAutoDriveByEncoder Linear": {
        "prefix": "robotAutoDriveByEncoderLinear",
        "description": "This file illustrates the concept of driving a path based on encoder counts.\nThe code is structured as a LinearOpMode\n\nThe code REQUIRES that you DO have encoders on the wheels,\n  otherwise you would use: RobotAutoDriveByTime;\n\n This code ALSO requires that the drive Motors have been configured such that a positive\n power command moves them forward, and causes the encoders to count UP.\n\n  The desired path in this example is:\n  - Drive forward for 48 inches\n  - Spin right for 12 Inches\n  - Drive Backward for 24 inches\n  - Stop and close the claw.\n\n The code is written using a method called: encoderDrive(speed, leftInches, rightInches, timeoutS)\n that performs the actual movement.\n This method assumes that each movement is relative to the last stopping place.\n There are other ways to perform encoder based moves, but this method is probably the simplest.\n This code uses the RUN_TO_POSITION mode to enable the Motor controllers to generate the run profile\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list\n ",
        "body": [
            "public class RobotAutoDriveByEncoder_Linear extends LinearOpMode {",
            "",
            "    /* Declare OpMode members. */",
            "    private DcMotor         leftDrive   = null;",
            "    private DcMotor         rightDrive  = null;",
            "",
            "    private ElapsedTime     runtime = new ElapsedTime();",
            "",
            "    // Calculate the COUNTS_PER_INCH for your specific drive train.",
            "    // Go to your motor vendor website to determine your motor's COUNTS_PER_MOTOR_REV",
            "    // For external drive gearing, set DRIVE_GEAR_REDUCTION as needed.",
            "    // For example, use a value of 2.0 for a 12-tooth spur gear driving a 24-tooth spur gear.",
            "    // This is gearing DOWN for less speed and more torque.",
            "    // For gearing UP, use a gear ratio less than 1.0. Note this will affect the direction of wheel rotation.",
            "    static final double     COUNTS_PER_MOTOR_REV    = 1440 ;    // eg: TETRIX Motor Encoder",
            "    static final double     DRIVE_GEAR_REDUCTION    = 1.0 ;     // No External Gearing.",
            "    static final double     WHEEL_DIAMETER_INCHES   = 4.0 ;     // For figuring circumference",
            "    static final double     COUNTS_PER_INCH         = (COUNTS_PER_MOTOR_REV * DRIVE_GEAR_REDUCTION) /",
            "                                                      (WHEEL_DIAMETER_INCHES * 3.1415);",
            "    static final double     DRIVE_SPEED             = 0.6;",
            "    static final double     TURN_SPEED              = 0.5;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        // Initialize the drive system variables.",
            "        leftDrive  = hardwareMap.get(DcMotor.class, \"left_drive\\\");",
            "        rightDrive = hardwareMap.get(DcMotor.class, \\\"right_drive\\\");",
            "",
            "        // To drive forward, most robots need the motor on one side to be reversed, because the axles point in opposite directions.",
            "        // When run, this OpMode should start both motors driving forward. So adjust these two lines based on your first test drive.",
            "        // Note: The settings here assume direct drive on left and right wheels.  Gear Reduction or 90 Deg drives may require direction flips",
            "        leftDrive.setDirection(DcMotor.Direction.REVERSE);",
            "        rightDrive.setDirection(DcMotor.Direction.FORWARD);",
            "",
            "        leftDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);",
            "        rightDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);",
            "",
            "        leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "        rightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "",
            "        // Send telemetry message to indicate successful Encoder reset",
            "        telemetry.addData(\\\"Starting at\\\",  \\\"%7d :%7d\\\",",
            "                          leftDrive.getCurrentPosition(),",
            "                          rightDrive.getCurrentPosition());",
            "        telemetry.update();",
            "",
            "        // Wait for the game to start (driver presses PLAY)",
            "        waitForStart();",
            "",
            "        // Step through each leg of the path,",
            "        // Note: Reverse movement is obtained by setting a negative distance (not speed)",
            "        encoderDrive(DRIVE_SPEED,  48,  48, 5.0);  // S1: Forward 47 Inches with 5 Sec timeout",
            "        encoderDrive(TURN_SPEED,   12, -12, 4.0);  // S2: Turn Right 12 Inches with 4 Sec timeout",
            "        encoderDrive(DRIVE_SPEED, -24, -24, 4.0);  // S3: Reverse 24 Inches with 4 Sec timeout",
            "",
            "        telemetry.addData(\\\"Path\\\", \\\"Complete\\\");",
            "        telemetry.update();",
            "        sleep(1000);  // pause to display final telemetry message.",
            "    }",
            "",
            "    /*",
            "     *  Method to perform a relative move, based on encoder counts.",
            "     *  Encoders are not reset as the move is based on the current position.",
            "     *  Move will stop if any of three conditions occur:",
            "     *  1) Move gets to the desired position",
            "     *  2) Move runs out of time",
            "     *  3) Driver stops the opmode running.",
            "     */",
            "    public void encoderDrive(double speed,",
            "                             double leftInches, double rightInches,",
            "                             double timeoutS) {",
            "        int newLeftTarget;",
            "        int newRightTarget;",
            "",
            "        // Ensure that the opmode is still active",
            "        if (opModeIsActive()) {",
            "",
            "            // Determine new target position, and pass to motor controller",
            "            newLeftTarget = leftDrive.getCurrentPosition() + (int)(leftInches * COUNTS_PER_INCH);",
            "            newRightTarget = rightDrive.getCurrentPosition() + (int)(rightInches * COUNTS_PER_INCH);",
            "            leftDrive.setTargetPosition(newLeftTarget);",
            "            rightDrive.setTargetPosition(newRightTarget);",
            "",
            "            // Turn On RUN_TO_POSITION",
            "            leftDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);",
            "            rightDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);",
            "",
            "            // reset the timeout time and start motion.",
            "            runtime.reset();",
            "            leftDrive.setPower(Math.abs(speed));",
            "            rightDrive.setPower(Math.abs(speed));",
            "",
            "            // keep looping while we are still active, and there is time left, and both motors are running.",
            "            // Note: We use (isBusy() && isBusy()) in the loop test, which means that when EITHER motor hits",
            "            // its target position, the motion will stop.  This is \\\"safer\\\" in the event that the robot will",
            "            // always end the motion as soon as possible.",
            "            // However, if you require that BOTH motors have finished their moves before the robot continues",
            "            // onto the next step, use (isBusy() || isBusy()) in the loop test.",
            "            while (opModeIsActive() &&",
            "                   (runtime.seconds() < timeoutS) &&",
            "                   (leftDrive.isBusy() && rightDrive.isBusy())) {",
            "",
            "                // Display it for the driver.",
            "                telemetry.addData(\\\"Running to\\\",  \\\" %7d :%7d\\\", newLeftTarget,  newRightTarget);",
            "                telemetry.addData(\\\"Currently at\\\",  \\\" at %7d :%7d\\\",",
            "                                            leftDrive.getCurrentPosition(), rightDrive.getCurrentPosition());",
            "                telemetry.update();",
            "            }",
            "",
            "            // Stop all motion;",
            "            leftDrive.setPower(0);",
            "            rightDrive.setPower(0);",
            "",
            "            // Turn off RUN_TO_POSITION",
            "            leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "            rightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "",
            "            sleep(250);   // optional pause after each move.",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "SensorIMUNonOrthogonal": {
        "prefix": "sensorIMUNonOrthogonal",
        "description": "{@link SensorIMUNonOrthogonal} shows how to use the new universal {@link IMU} interface. This\ninterface may be used with the BNO055 IMU or the BHI260 IMU. It assumes that an IMU is configured\non the robot with the name \"imu\".\n<p>\nThe sample will display the current Yaw, Pitch and Roll of the robot.<br>\nWith the correct orientation parameters selected, pitch/roll/yaw should act as follows:\n<p>\n  Pitch value should INCREASE as the robot is tipped UP at the front. (Rotation about X) <br>\n  Roll value should INCREASE as the robot is tipped UP at the left side. (Rotation about Y) <br>\n  Yaw value should INCREASE as the robot is rotated Counter Clockwise. (Rotation about Z) <br>\n<p>\nThe yaw can be reset (to zero) by pressing the Y button on the gamepad (Triangle on a PS4 controller)\n<p>\nThis specific sample DOES NOT assume that the Hub is mounted on one of the three orthogonal\nplanes (X/Y, X/Z or Y/Z) OR that the Hub has only been rotated in a range of 90 degree increments.\n<p>\nNote: if your Hub is mounted Orthogonally (on a orthogonal surface, angled at some multiple of\n90 Degrees) then you should use the simpler SensorImuOrthogonal sample in this folder.\n<p>\nBut... If your Hub is mounted Non-Orthogonally, you must specify one or more rotational angles\nthat transform a \"Default\" Hub orientation into your desired orientation.  That is what is\nillustrated here.\n<p>\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this OpMode to the Driver Station OpMode list.\n<p>\nFinally, edit this OpMode to use at least one angle around an axis to orient your Hub.\n ",
        "body": [
            "public class SensorIMUNonOrthogonal extends LinearOpMode",
            "{",
            "    // The IMU sensor object",
            "    IMU imu;",
            "",
            "    //----------------------------------------------------------------------------------------------",
            "    // Main logic",
            "    //----------------------------------------------------------------------------------------------",
            "",
            "    @Override public void runOpMode() throws InterruptedException {",
            "",
            "        // Retrieve and initialize the IMU.",
            "        // This sample expects the IMU to be in a REV Hub and named \"imu\\\".",
            "        imu = hardwareMap.get(IMU.class, \\\"imu\\\");",
            "",
            "        /* Define how the hub is mounted to the robot to get the correct Yaw, Pitch and Roll values.",
            "         *",
            "         * You can apply up to three axis rotations to orient your Hub according to how it's mounted on the robot.",
            "         *",
            "         * The starting point for these rotations is the \\\"Default\\\" Hub orientation, which is:",
            "         * 1) Hub laying flat on a horizontal surface, with the Printed Logo facing UP",
            "         * 2) Rotated such that the USB ports are facing forward on the robot.",
            "         *",
            "         * The order that the rotations are performed matters, so this sample shows doing them in the order X, Y, then Z.",
            "         * For specifying non-orthogonal hub mounting orientations, we must temporarily use axes",
            "         * defined relative to the Hub itself, instead of the usual Robot Coordinate System axes",
            "         * used for the results the IMU gives us. In the starting orientation, the Hub axes are",
            "         * aligned with the Robot Coordinate System:",
            "         *",
            "         * X Axis:  Starting at Center of Hub, pointing out towards I2C connectors",
            "         * Y Axis:  Starting at Center of Hub, pointing out towards USB connectors",
            "         * Z Axis:  Starting at Center of Hub, pointing Up through LOGO",
            "         *",
            "         * Positive rotation is defined by right-hand rule with thumb pointing in +ve direction on axis.",
            "         *",
            "         * Some examples.",
            "         *",
            "         * ----------------------------------------------------------------------------------------------------------------------------------",
            "         * Example A) Assume that the hub is mounted on a sloped plate at the back of the robot, with the USB ports coming out the top of the hub.",
            "         *  The plate is tilted UP 60 degrees from horizontal.",
            "         *",
            "         *  To get the \\\"Default\\\" hub into this configuration you would just need a single rotation.",
            "         *  1) Rotate the Hub +60 degrees around the X axis to tilt up the front edge.",
            "         *  2) No rotation around the Y or Z axes.",
            "         *",
            "         *  So the X,Y,Z rotations would be 60,0,0",
            "         *",
            "         * ----------------------------------------------------------------------------------------------------------------------------------",
            "         * Example B) Assume that the hub is laying flat on the chassis, but it has been twisted 30 degrees towards the right front wheel to make",
            "         *  the USB cable accessible.",
            "         *",
            "         *  To get the \\\"Default\\\" hub into this configuration you would just need a single rotation, but around a different axis.",
            "         *  1) No rotation around the X or Y axes.",
            "         *  1) Rotate the Hub -30 degrees (Clockwise) around the Z axis, since a positive angle would be Counter Clockwise.",
            "         *",
            "         *  So the X,Y,Z rotations would be 0,0,-30",
            "         *",
            "         * ----------------------------------------------------------------------------------------------------------------------------------",
            "         *  Example C) Assume that the hub is mounted on a vertical plate on the right side of the robot, with the Logo facing out, and the",
            "         *  Hub rotated so that the USB ports are facing down 30 degrees towards the back wheels of the robot.",
            "         *",
            "         *  To get the \\\"Default\\\" hub into this configuration will require several rotations.",
            "         *  1) Rotate the hub +90 degrees around the X axis to get it standing upright with the logo pointing backwards on the robot",
            "         *  2) Next, rotate the hub +90 around the Y axis to get it facing to the right.",
            "         *  3) Finally rotate the hub +120 degrees around the Z axis to take the USB ports from vertical to sloping down 30 degrees and",
            "         *     facing towards the back of the robot.",
            "         *",
            "         *  So the X,Y,Z rotations would be 90,90,120",
            "         */",
            "",
            "        // The next three lines define the desired axis rotations.",
            "        // To Do: EDIT these values to match YOUR mounting configuration.",
            "        double xRotation = 0;  // enter the desired X rotation angle here.",
            "        double yRotation = 0;  // enter the desired Y rotation angle here.",
            "        double zRotation = 0;  // enter the desired Z rotation angle here.",
            "",
            "        Orientation hubRotation = xyzOrientation(xRotation, yRotation, zRotation);",
            "",
            "        // Now initialize the IMU with this mounting orientation",
            "        RevHubOrientationOnRobot orientationOnRobot = new RevHubOrientationOnRobot(hubRotation);",
            "        imu.initialize(new IMU.Parameters(orientationOnRobot));",
            "",
            "        // Loop and update the dashboard",
            "        while (!isStopRequested()) {",
            "            telemetry.addData(\\\"Hub orientation\\\", \\\"X=%.1f,  Y=%.1f,  Z=%.1f \\n\\\", xRotation, yRotation, zRotation);",
            "",
            "            // Check to see if heading reset is requested",
            "            if (gamepad1.y) {",
            "                telemetry.addData(\\\"Yaw\\\", \\\"Resetting\\n\\\");",
            "                imu.resetYaw();",
            "            } else {",
            "                telemetry.addData(\\\"Yaw\\\", \\\"Press Y (triangle) on Gamepad to reset\\n\\\");",
            "            }",
            "",
            "            // Retrieve Rotational Angles and Velocities",
            "            YawPitchRollAngles orientation = imu.getRobotYawPitchRollAngles();",
            "            AngularVelocity angularVelocity = imu.getRobotAngularVelocity(AngleUnit.DEGREES);",
            "",
            "            telemetry.addData(\\\"Yaw (Z)\\\", \\\"%.2f Deg. (Heading)\\\", orientation.getYaw(AngleUnit.DEGREES));",
            "            telemetry.addData(\\\"Pitch (X)\\\", \\\"%.2f Deg.\\\", orientation.getPitch(AngleUnit.DEGREES));",
            "            telemetry.addData(\\\"Roll (Y)\\\", \\\"%.2f Deg.\\n\\\", orientation.getRoll(AngleUnit.DEGREES));",
            "            telemetry.addData(\\\"Yaw (Z) velocity\\\", \\\"%.2f Deg/Sec\\\", angularVelocity.zRotationRate);",
            "            telemetry.addData(\\\"Pitch (X) velocity\\\", \\\"%.2f Deg/Sec\\\", angularVelocity.xRotationRate);",
            "            telemetry.addData(\\\"Roll (Y) velocity\\\", \\\"%.2f Deg/Sec\\\", angularVelocity.yRotationRate);",
            "            telemetry.update();",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "RobotTeleopPOV Linear": {
        "prefix": "robotTeleopPOVLinear",
        "description": "This particular OpMode executes a POV Game style Teleop for a direct drive robot\nThe code is structured as a LinearOpMode\n\nIn this mode the left stick moves the robot FWD and back, the Right stick turns left and right.\nIt raises and lowers the arm using the Gamepad Y and A buttons respectively.\nIt also opens and closes the claws slowly using the left and right Bumper buttons.\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list\n ",
        "body": [
            "public class RobotTeleopPOV_Linear extends LinearOpMode {",
            "",
            "    /* Declare OpMode members. */",
            "    public DcMotor  leftDrive   = null;",
            "    public DcMotor  rightDrive  = null;",
            "    public DcMotor  leftArm     = null;",
            "    public Servo    leftClaw    = null;",
            "    public Servo    rightClaw   = null;",
            "",
            "    double clawOffset = 0;",
            "",
            "    public static final double MID_SERVO   =  0.5 ;",
            "    public static final double CLAW_SPEED  = 0.02 ;                 // sets rate to move servo",
            "    public static final double ARM_UP_POWER    =  0.45 ;",
            "    public static final double ARM_DOWN_POWER  = -0.45 ;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "        double left;",
            "        double right;",
            "        double drive;",
            "        double turn;",
            "        double max;",
            "",
            "        // Define and Initialize Motors",
            "        leftDrive  = hardwareMap.get(DcMotor.class, \"left_drive\\\");",
            "        rightDrive = hardwareMap.get(DcMotor.class, \\\"right_drive\\\");",
            "        leftArm    = hardwareMap.get(DcMotor.class, \\\"left_arm\\\");",
            "",
            "        // To drive forward, most robots need the motor on one side to be reversed, because the axles point in opposite directions.",
            "        // Pushing the left stick forward MUST make robot go forward. So adjust these two lines based on your first test drive.",
            "        // Note: The settings here assume direct drive on left and right wheels.  Gear Reduction or 90 Deg drives may require direction flips",
            "        leftDrive.setDirection(DcMotor.Direction.REVERSE);",
            "        rightDrive.setDirection(DcMotor.Direction.FORWARD);",
            "",
            "        // If there are encoders connected, switch to RUN_USING_ENCODER mode for greater accuracy",
            "        // leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "        // rightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "",
            "        // Define and initialize ALL installed servos.",
            "        leftClaw  = hardwareMap.get(Servo.class, \\\"left_hand\\\");",
            "        rightClaw = hardwareMap.get(Servo.class, \\\"right_hand\\\");",
            "        leftClaw.setPosition(MID_SERVO);",
            "        rightClaw.setPosition(MID_SERVO);",
            "",
            "        // Send telemetry message to signify robot waiting;",
            "        telemetry.addData(\\\">\\\", \\\"Robot Ready.  Press Play.\\\");    //",
            "        telemetry.update();",
            "",
            "        // Wait for the game to start (driver presses PLAY)",
            "        waitForStart();",
            "",
            "        // run until the end of the match (driver presses STOP)",
            "        while (opModeIsActive()) {",
            "",
            "            // Run wheels in POV mode (note: The joystick goes negative when pushed forward, so negate it)",
            "            // In this mode the Left stick moves the robot fwd and back, the Right stick turns left and right.",
            "            // This way it's also easy to just drive straight, or just turn.",
            "            drive = -gamepad1.left_stick_y;",
            "            turn  =  gamepad1.right_stick_x;",
            "",
            "            // Combine drive and turn for blended motion.",
            "            left  = drive + turn;",
            "            right = drive - turn;",
            "",
            "            // Normalize the values so neither exceed +/- 1.0",
            "            max = Math.max(Math.abs(left), Math.abs(right));",
            "            if (max > 1.0)",
            "            {",
            "                left /= max;",
            "                right /= max;",
            "            }",
            "",
            "            // Output the safe vales to the motor drives.",
            "            leftDrive.setPower(left);",
            "            rightDrive.setPower(right);",
            "",
            "            // Use gamepad left & right Bumpers to open and close the claw",
            "            if (gamepad1.right_bumper)",
            "                clawOffset += CLAW_SPEED;",
            "            else if (gamepad1.left_bumper)",
            "                clawOffset -= CLAW_SPEED;",
            "",
            "            // Move both servos to new position.  Assume servos are mirror image of each other.",
            "            clawOffset = Range.clip(clawOffset, -0.5, 0.5);",
            "            leftClaw.setPosition(MID_SERVO + clawOffset);",
            "            rightClaw.setPosition(MID_SERVO - clawOffset);",
            "",
            "            // Use gamepad buttons to move arm up (Y) and down (A)",
            "            if (gamepad1.y)",
            "                leftArm.setPower(ARM_UP_POWER);",
            "            else if (gamepad1.a)",
            "                leftArm.setPower(ARM_DOWN_POWER);",
            "            else",
            "                leftArm.setPower(0.0);",
            "",
            "            // Send telemetry message to signify robot running;",
            "            telemetry.addData(\\\"claw\\\",  \\\"Offset = %.2f\\\", clawOffset);",
            "            telemetry.addData(\\\"left\\\",  \\\"%.2f\\\", left);",
            "            telemetry.addData(\\\"right\\\", \\\"%.2f\\\", right);",
            "            telemetry.update();",
            "",
            "            // Pace this loop so jaw action is reasonable speed.",
            "            sleep(50);",
            "        }",
            "    }",
            "}",
            ""
        ]
    },
    "RobotAutoDriveToLine Linear": {
        "prefix": "robotAutoDriveToLineLinear",
        "description": "This file illustrates the concept of driving up to a line and then stopping.\nThe code is structured as a LinearOpMode\n\nThe Sensor used here can be a REV Color Sensor V2 or V3.  Make sure the white LED is turned on.\nThe sensor can be plugged into any I2C port, and must be named \"sensor_color\" in the active configuration.\n\n  Depending on the height of your color sensor, you may want to set the sensor \"gain\".\n  The higher the gain, the greater the reflected light reading will be.\n  Use the SensorColor sample in this folder to determine the minimum gain value that provides an\n  \"Alpha\" reading of 1.0 when you are on top of the white line.  In this sample, we use a gain of 15\n  which works well with a Rev V2 color sensor\n\n  Setting the correct WHITE_THRESHOLD value is key to stopping correctly.\n  This should be set halfway between the bare-tile, and white-line \"Alpha\" values.\n  The reflected light value can be read on the screen once the OpMode has been INIT, but before it is STARTED.\n  Move the sensor on and off the white line and note the min and max readings.\n  Edit this code to make WHITE_THRESHOLD halfway between the min and max.\n\n  Use Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\n  Remove or comment out the @Disabled line to add this OpMode to the Driver Station OpMode list\n ",
        "body": [
            "public class RobotAutoDriveToLine_Linear extends LinearOpMode {",
            "",
            "    /* Declare OpMode members. */",
            "    private DcMotor         leftDrive   = null;",
            "    private DcMotor         rightDrive  = null;",
            "",
            "    /** The colorSensor field will contain a reference to our color sensor hardware object */",
            "    NormalizedColorSensor colorSensor;",
            "",
            "    static final double     WHITE_THRESHOLD = 0.5;  // spans between 0.0 - 1.0 from dark to light",
            "    static final double     APPROACH_SPEED  = 0.25;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        // Initialize the drive system variables.",
            "        leftDrive  = hardwareMap.get(DcMotor.class, \"left_drive\\\");",
            "        rightDrive = hardwareMap.get(DcMotor.class, \\\"right_drive\\\");",
            "",
            "        // To drive forward, most robots need the motor on one side to be reversed, because the axles point in opposite directions.",
            "        // When run, this OpMode should start both motors driving forward. So adjust these two lines based on your first test drive.",
            "        // Note: The settings here assume direct drive on left and right wheels.  Gear Reduction or 90 Deg drives may require direction flips",
            "        leftDrive.setDirection(DcMotor.Direction.REVERSE);",
            "        rightDrive.setDirection(DcMotor.Direction.FORWARD);",
            "",
            "        // If there are encoders connected, switch to RUN_USING_ENCODER mode for greater accuracy",
            "        // leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "        // rightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "",
            "        // Get a reference to our sensor object. It's recommended to use NormalizedColorSensor over",
            "        // ColorSensor, because NormalizedColorSensor consistently gives values between 0 and 1, while",
            "        // the values you get from ColorSensor are dependent on the specific sensor you're using.",
            "        colorSensor = hardwareMap.get(NormalizedColorSensor.class, \\\"sensor_color\\\");",
            "",
            "        // If necessary, turn ON the white LED (if there is no LED switch on the sensor)",
            "        if (colorSensor instanceof SwitchableLight) {",
            "            ((SwitchableLight)colorSensor).enableLight(true);",
            "        }",
            "",
            "        // Some sensors allow you to set your light sensor gain for optimal sensitivity...",
            "        // See the SensorColor sample in this folder for how to determine the optimal gain.",
            "        // A gain of 15 causes a Rev Color Sensor V2 to produce an Alpha value of 1.0 at about 1.5\\\" above the floor.",
            "        colorSensor.setGain(15);",
            "",
            "        // Wait for driver to press PLAY)",
            "        // Abort this loop is started or stopped.",
            "        while (opModeInInit()) {",
            "",
            "            // Send telemetry message to signify robot waiting;",
            "            telemetry.addData(\\\"Status\\\", \\\"Ready to drive to white line.\\\");    //",
            "",
            "            // Display the light level while we are waiting to start",
            "            getBrightness();",
            "        }",
            "",
            "        // Start the robot moving forward, and then begin looking for a white line.",
            "        leftDrive.setPower(APPROACH_SPEED);",
            "        rightDrive.setPower(APPROACH_SPEED);",
            "",
            "        // run until the white line is seen OR the driver presses STOP;",
            "        while (opModeIsActive() && (getBrightness() < WHITE_THRESHOLD)) {",
            "            sleep(5);",
            "        }",
            "",
            "        // Stop all motors",
            "        leftDrive.setPower(0);",
            "        rightDrive.setPower(0);",
            "    }",
            "",
            "    // to obtain reflected light, read the normalized values from the color sensor.  Return the Alpha channel.",
            "    double getBrightness() {",
            "        NormalizedRGBA colors = colorSensor.getNormalizedColors();",
            "        telemetry.addData(\\\"Light Level (0 to 1)\\\",  \\\"%4.2f\\\", colors.alpha);",
            "        telemetry.update();",
            "",
            "        return colors.alpha;",
            "    }",
            "}",
            ""
        ]
    },
    "RobotHardware": {
        "prefix": "robotHardware",
        "description": "    Send the two hand-servos to opposing (mirrored) positions, based on the passed offset.\n    \n    @param offset\n     ",
        "body": [
            "public class RobotHardware {",
            "",
            "    /* Declare OpMode members. */",
            "    private LinearOpMode myOpMode = null;   // gain access to methods in the calling OpMode.",
            "",
            "    // Define Motor and Servo objects  (Make them private so they can't be accessed externally)",
            "    private DcMotor leftDrive   = null;",
            "    private DcMotor rightDrive  = null;",
            "    private DcMotor armMotor = null;",
            "    private Servo   leftHand = null;",
            "    private Servo   rightHand = null;",
            "",
            "    // Define Drive constants.  Make them public so they CAN be used by the calling OpMode",
            "    public static final double MID_SERVO       =  0.5 ;",
            "    public static final double HAND_SPEED      =  0.02 ;  // sets rate to move servo",
            "    public static final double ARM_UP_POWER    =  0.45 ;",
            "    public static final double ARM_DOWN_POWER  = -0.45 ;",
            "",
            "    // Define a constructor that allows the OpMode to pass a reference to itself.",
            "    public RobotHardware (LinearOpMode opmode) {",
            "        myOpMode = opmode;",
            "    }",
            "",
            "    /**",
            "     * Initialize all the robot's hardware.",
            "     * This method must be called ONCE when the OpMode is initialized.",
            "     *",
            "     * All of the hardware devices are accessed via the hardware map, and initialized.",
            "     */",
            "    public void init()    {",
            "        // Define and Initialize Motors (note: need to use reference to actual OpMode).",
            "        leftDrive  = myOpMode.hardwareMap.get(DcMotor.class, \"left_drive\\\");",
            "        rightDrive = myOpMode.hardwareMap.get(DcMotor.class, \\\"right_drive\\\");",
            "        armMotor   = myOpMode.hardwareMap.get(DcMotor.class, \\\"arm\\\");",
            "",
            "        // To drive forward, most robots need the motor on one side to be reversed, because the axles point in opposite directions.",
            "        // Pushing the left stick forward MUST make robot go forward. So adjust these two lines based on your first test drive.",
            "        // Note: The settings here assume direct drive on left and right wheels.  Gear Reduction or 90 Deg drives may require direction flips",
            "        leftDrive.setDirection(DcMotor.Direction.REVERSE);",
            "        rightDrive.setDirection(DcMotor.Direction.FORWARD);",
            "",
            "        // If there are encoders connected, switch to RUN_USING_ENCODER mode for greater accuracy",
            "        // leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "        // rightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "",
            "        // Define and initialize ALL installed servos.",
            "        leftHand = myOpMode.hardwareMap.get(Servo.class, \\\"left_hand\\\");",
            "        rightHand = myOpMode.hardwareMap.get(Servo.class, \\\"right_hand\\\");",
            "        leftHand.setPosition(MID_SERVO);",
            "        rightHand.setPosition(MID_SERVO);",
            "",
            "        myOpMode.telemetry.addData(\\\">\\\", \\\"Hardware Initialized\\\");",
            "        myOpMode.telemetry.update();",
            "    }",
            "",
            "    /**",
            "     * Calculates the left/right motor powers required to achieve the requested",
            "     * robot motions: Drive (Axial motion) and Turn (Yaw motion).",
            "     * Then sends these power levels to the motors.",
            "     *",
            "     * @param Drive     Fwd/Rev driving power (-1.0 to 1.0) +ve is forward",
            "     * @param Turn      Right/Left turning power (-1.0 to 1.0) +ve is CW",
            "     */",
            "    public void driveRobot(double Drive, double Turn) {",
            "        // Combine drive and turn for blended motion.",
            "        double left  = Drive + Turn;",
            "        double right = Drive - Turn;",
            "",
            "        // Scale the values so neither exceed +/- 1.0",
            "        double max = Math.max(Math.abs(left), Math.abs(right));",
            "        if (max > 1.0)",
            "        {",
            "            left /= max;",
            "            right /= max;",
            "        }",
            "",
            "        // Use existing function to drive both wheels.",
            "        setDrivePower(left, right);",
            "    }",
            "",
            "    /**",
            "     * Pass the requested wheel motor powers to the appropriate hardware drive motors.",
            "     *",
            "     * @param leftWheel     Fwd/Rev driving power (-1.0 to 1.0) +ve is forward",
            "     * @param rightWheel    Fwd/Rev driving power (-1.0 to 1.0) +ve is forward",
            "     */",
            "    public void setDrivePower(double leftWheel, double rightWheel) {",
            "        // Output the values to the motor drives.",
            "        leftDrive.setPower(leftWheel);",
            "        rightDrive.setPower(rightWheel);",
            "    }",
            "",
            "    /**",
            "     * Pass the requested arm power to the appropriate hardware drive motor",
            "     *",
            "     * @param power driving power (-1.0 to 1.0)",
            "     */",
            "    public void setArmPower(double power) {",
            "        armMotor.setPower(power);",
            "    }",
            "",
            "    /**",
            "     * Send the two hand-servos to opposing (mirrored) positions, based on the passed offset.",
            "     *",
            "     * @param offset",
            "     */",
            "    public void setHandPositions(double offset) {",
            "        offset = Range.clip(offset, -0.5, 0.5);",
            "        leftHand.setPosition(MID_SERVO + offset);",
            "        rightHand.setPosition(MID_SERVO - offset);",
            "    }",
            "}",
            ""
        ]
    },
    "RobotAutoDriveByTime Linear": {
        "prefix": "robotAutoDriveByTimeLinear",
        "description": "This file illustrates the concept of driving a path based on time.\nThe code is structured as a LinearOpMode\n\nThe code assumes that you do NOT have encoders on the wheels,\n  otherwise you would use: RobotAutoDriveByEncoder;\n\n  The desired path in this example is:\n  - Drive forward for 3 seconds\n  - Spin right for 1.3 seconds\n  - Drive Backward for 1 Second\n\n The code is written in a simple form with no optimizations.\n However, there are several ways that this type of sequence could be streamlined,\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this OpMode to the Driver Station OpMode list\n ",
        "body": [
            "public class RobotAutoDriveByTime_Linear extends LinearOpMode {",
            "",
            "    /* Declare OpMode members. */",
            "    private DcMotor         leftDrive   = null;",
            "    private DcMotor         rightDrive  = null;",
            "",
            "    private ElapsedTime     runtime = new ElapsedTime();",
            "",
            "",
            "    static final double     FORWARD_SPEED = 0.6;",
            "    static final double     TURN_SPEED    = 0.5;",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        // Initialize the drive system variables.",
            "        leftDrive  = hardwareMap.get(DcMotor.class, \"left_drive\\\");",
            "        rightDrive = hardwareMap.get(DcMotor.class, \\\"right_drive\\\");",
            "",
            "        // To drive forward, most robots need the motor on one side to be reversed, because the axles point in opposite directions.",
            "        // When run, this OpMode should start both motors driving forward. So adjust these two lines based on your first test drive.",
            "        // Note: The settings here assume direct drive on left and right wheels.  Gear Reduction or 90 Deg drives may require direction flips",
            "        leftDrive.setDirection(DcMotor.Direction.REVERSE);",
            "        rightDrive.setDirection(DcMotor.Direction.FORWARD);",
            "",
            "        // Send telemetry message to signify robot waiting;",
            "        telemetry.addData(\\\"Status\\\", \\\"Ready to run\\\");    //",
            "        telemetry.update();",
            "",
            "        // Wait for the game to start (driver presses PLAY)",
            "        waitForStart();",
            "",
            "        // Step through each leg of the path, ensuring that the Auto mode has not been stopped along the way",
            "",
            "        // Step 1:  Drive forward for 3 seconds",
            "        leftDrive.setPower(FORWARD_SPEED);",
            "        rightDrive.setPower(FORWARD_SPEED);",
            "        runtime.reset();",
            "        while (opModeIsActive() && (runtime.seconds() < 3.0)) {",
            "            telemetry.addData(\\\"Path\\\", \\\"Leg 1: %4.1f S Elapsed\\\", runtime.seconds());",
            "            telemetry.update();",
            "        }",
            "",
            "        // Step 2:  Spin right for 1.3 seconds",
            "        leftDrive.setPower(TURN_SPEED);",
            "        rightDrive.setPower(-TURN_SPEED);",
            "        runtime.reset();",
            "        while (opModeIsActive() && (runtime.seconds() < 1.3)) {",
            "            telemetry.addData(\\\"Path\\\", \\\"Leg 2: %4.1f S Elapsed\\\", runtime.seconds());",
            "            telemetry.update();",
            "        }",
            "",
            "        // Step 3:  Drive Backward for 1 Second",
            "        leftDrive.setPower(-FORWARD_SPEED);",
            "        rightDrive.setPower(-FORWARD_SPEED);",
            "        runtime.reset();",
            "        while (opModeIsActive() && (runtime.seconds() < 1.0)) {",
            "            telemetry.addData(\\\"Path\\\", \\\"Leg 3: %4.1f S Elapsed\\\", runtime.seconds());",
            "            telemetry.update();",
            "        }",
            "",
            "        // Step 4:  Stop",
            "        leftDrive.setPower(0);",
            "        rightDrive.setPower(0);",
            "",
            "        telemetry.addData(\\\"Path\\\", \\\"Complete\\\");",
            "        telemetry.update();",
            "        sleep(1000);",
            "    }",
            "}",
            ""
        ]
    },
    "RobotAutoDriveByGyro Linear": {
        "prefix": "robotAutoDriveByGyroLinear",
        "description": "    Reset the \"offset\" heading back to zero\n     ",
        "body": [
            "public class RobotAutoDriveByGyro_Linear extends LinearOpMode {",
            "",
            "    /* Declare OpMode members. */",
            "    private DcMotor         leftDrive   = null;",
            "    private DcMotor         rightDrive  = null;",
            "    private BNO055IMU       imu         = null;      // Control/Expansion Hub IMU",
            "",
            "    private double          robotHeading  = 0;",
            "    private double          headingOffset = 0;",
            "    private double          headingError  = 0;",
            "",
            "    // These variable are declared here (as class members) so they can be updated in various methods,",
            "    // but still be displayed by sendTelemetry()",
            "    private double  targetHeading = 0;",
            "    private double  driveSpeed    = 0;",
            "    private double  turnSpeed     = 0;",
            "    private double  leftSpeed     = 0;",
            "    private double  rightSpeed    = 0;",
            "    private int     leftTarget    = 0;",
            "    private int     rightTarget   = 0;",
            "",
            "    // Calculate the COUNTS_PER_INCH for your specific drive train.",
            "    // Go to your motor vendor website to determine your motor's COUNTS_PER_MOTOR_REV",
            "    // For external drive gearing, set DRIVE_GEAR_REDUCTION as needed.",
            "    // For example, use a value of 2.0 for a 12-tooth spur gear driving a 24-tooth spur gear.",
            "    // This is gearing DOWN for less speed and more torque.",
            "    // For gearing UP, use a gear ratio less than 1.0. Note this will affect the direction of wheel rotation.",
            "    static final double     COUNTS_PER_MOTOR_REV    = 537.7 ;   // eg: GoBILDA 312 RPM Yellow Jacket",
            "    static final double     DRIVE_GEAR_REDUCTION    = 1.0 ;     // No External Gearing.",
            "    static final double     WHEEL_DIAMETER_INCHES   = 4.0 ;     // For figuring circumference",
            "    static final double     COUNTS_PER_INCH         = (COUNTS_PER_MOTOR_REV * DRIVE_GEAR_REDUCTION) /",
            "                                                      (WHEEL_DIAMETER_INCHES * 3.1415);",
            "",
            "    // These constants define the desired driving/control characteristics",
            "    // They can/should be tweaked to suit the specific robot drive train.",
            "    static final double     DRIVE_SPEED             = 0.4;     // Max driving speed for better distance accuracy.",
            "    static final double     TURN_SPEED              = 0.2;     // Max Turn speed to limit turn rate",
            "    static final double     HEADING_THRESHOLD       = 1.0 ;    // How close must the heading get to the target before moving to next step.",
            "                                                               // Requiring more accuracy (a smaller number) will often make the turn take longer to get into the final position.",
            "    // Define the Proportional control coefficient (or GAIN) for \"heading control\\\".",
            "    // We define one value when Turning (larger errors), and the other is used when Driving straight (smaller errors).",
            "    // Increase these numbers if the heading does not corrects strongly enough (eg: a heavy robot or using tracks)",
            "    // Decrease these numbers if the heading does not settle on the correct value (eg: very agile robot with omni wheels)",
            "    static final double     P_TURN_GAIN            = 0.02;     // Larger is more responsive, but also less stable",
            "    static final double     P_DRIVE_GAIN           = 0.03;     // Larger is more responsive, but also less stable",
            "",
            "",
            "    @Override",
            "    public void runOpMode() {",
            "",
            "        // Initialize the drive system variables.",
            "        leftDrive  = hardwareMap.get(DcMotor.class, \\\"left_drive\\\");",
            "        rightDrive = hardwareMap.get(DcMotor.class, \\\"right_drive\\\");",
            "",
            "        // To drive forward, most robots need the motor on one side to be reversed, because the axles point in opposite directions.",
            "        // When run, this OpMode should start both motors driving forward. So adjust these two lines based on your first test drive.",
            "        // Note: The settings here assume direct drive on left and right wheels.  Gear Reduction or 90 Deg drives may require direction flips",
            "        leftDrive.setDirection(DcMotor.Direction.REVERSE);",
            "        rightDrive.setDirection(DcMotor.Direction.FORWARD);",
            "",
            "        // define initialization values for IMU, and then initialize it.",
            "        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();",
            "        parameters.angleUnit            = BNO055IMU.AngleUnit.DEGREES;",
            "        imu = hardwareMap.get(BNO055IMU.class, \\\"imu\\\");",
            "        imu.initialize(parameters);",
            "",
            "        // Ensure the robot is stationary.  Reset the encoders and set the motors to BRAKE mode",
            "        leftDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);",
            "        rightDrive.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);",
            "        leftDrive.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);",
            "        rightDrive.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);",
            "",
            "        // Wait for the game to start (Display Gyro value while waiting)",
            "        while (opModeInInit()) {",
            "            telemetry.addData(\\\">\\\", \\\"Robot Heading = %4.0f\\\", getRawHeading());",
            "            telemetry.update();",
            "        }",
            "",
            "        // Set the encoders for closed loop speed control, and reset the heading.",
            "        leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "        rightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "        resetHeading();",
            "",
            "        // Step through each leg of the path,",
            "        // Notes:   Reverse movement is obtained by setting a negative distance (not speed)",
            "        //          holdHeading() is used after turns to let the heading stabilize",
            "        //          Add a sleep(2000) after any step to keep the telemetry data visible for review",
            "",
            "        driveStraight(DRIVE_SPEED, 24.0, 0.0);    // Drive Forward 24\\\"",
            "        turnToHeading( TURN_SPEED, -45.0);               // Turn  CW to -45 Degrees",
            "        holdHeading( TURN_SPEED, -45.0, 0.5);   // Hold -45 Deg heading for a 1/2 second",
            "",
            "        driveStraight(DRIVE_SPEED, 17.0, -45.0);  // Drive Forward 17\\\" at -45 degrees (12\\\"x and 12\\\"y)",
            "        turnToHeading( TURN_SPEED,  45.0);               // Turn  CCW  to  45 Degrees",
            "        holdHeading( TURN_SPEED,  45.0, 0.5);    // Hold  45 Deg heading for a 1/2 second",
            "",
            "        driveStraight(DRIVE_SPEED, 17.0, 45.0);  // Drive Forward 17\\\" at 45 degrees (-12\\\"x and 12\\\"y)",
            "        turnToHeading( TURN_SPEED,   0.0);               // Turn  CW  to 0 Degrees",
            "        holdHeading( TURN_SPEED,   0.0, 1.0);    // Hold  0 Deg heading for 1 second",
            "",
            "        driveStraight(DRIVE_SPEED,-48.0, 0.0);    // Drive in Reverse 48\\\" (should return to approx. staring position)",
            "",
            "        telemetry.addData(\\\"Path\\\", \\\"Complete\\\");",
            "        telemetry.update();",
            "        sleep(1000);  // Pause to display last telemetry message.",
            "    }",
            "",
            "    /*",
            "     * ====================================================================================================",
            "     * Driving \\\"Helper\\\" functions are below this line.",
            "     * These provide the high and low level methods that handle driving straight and turning.",
            "     * ====================================================================================================",
            "     */",
            "",
            "    // **********  HIGH Level driving functions.  ********************",
            "",
            "    /**",
            "    *  Method to drive in a straight line, on a fixed compass heading (angle), based on encoder counts.",
            "    *  Move will stop if either of these conditions occur:",
            "    *  1) Move gets to the desired position",
            "    *  2) Driver stops the opmode running.",
            "    *",
            "    * @param maxDriveSpeed MAX Speed for forward/rev motion (range 0 to +1.0) .",
            "    * @param distance   Distance (in inches) to move from current position.  Negative distance means move backward.",
            "    * @param heading      Absolute Heading Angle (in Degrees) relative to last gyro reset.",
            "    *                   0 = fwd. +ve is CCW from fwd. -ve is CW from forward.",
            "    *                   If a relative angle is required, add/subtract from the current robotHeading.",
            "    */",
            "    public void driveStraight(double maxDriveSpeed,",
            "                              double distance,",
            "                              double heading) {",
            "",
            "        // Ensure that the opmode is still active",
            "        if (opModeIsActive()) {",
            "",
            "            // Determine new target position, and pass to motor controller",
            "            int moveCounts = (int)(distance * COUNTS_PER_INCH);",
            "            leftTarget = leftDrive.getCurrentPosition() + moveCounts;",
            "            rightTarget = rightDrive.getCurrentPosition() + moveCounts;",
            "",
            "            // Set Target FIRST, then turn on RUN_TO_POSITION",
            "            leftDrive.setTargetPosition(leftTarget);",
            "            rightDrive.setTargetPosition(rightTarget);",
            "",
            "            leftDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);",
            "            rightDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);",
            "",
            "            // Set the required driving speed  (must be positive for RUN_TO_POSITION)",
            "            // Start driving straight, and then enter the control loop",
            "            maxDriveSpeed = Math.abs(maxDriveSpeed);",
            "            moveRobot(maxDriveSpeed, 0);",
            "",
            "            // keep looping while we are still active, and BOTH motors are running.",
            "            while (opModeIsActive() &&",
            "                   (leftDrive.isBusy() && rightDrive.isBusy())) {",
            "",
            "                // Determine required steering to keep on heading",
            "                turnSpeed = getSteeringCorrection(heading, P_DRIVE_GAIN);",
            "",
            "                // if driving in reverse, the motor correction also needs to be reversed",
            "                if (distance < 0)",
            "                    turnSpeed *= -1.0;",
            "",
            "                // Apply the turning correction to the current driving speed.",
            "                moveRobot(driveSpeed, turnSpeed);",
            "",
            "                // Display drive status for the driver.",
            "                sendTelemetry(true);",
            "            }",
            "",
            "            // Stop all motion & Turn off RUN_TO_POSITION",
            "            moveRobot(0, 0);",
            "            leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "            rightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "        }",
            "    }",
            "",
            "    /**",
            "     *  Method to spin on central axis to point in a new direction.",
            "     *  Move will stop if either of these conditions occur:",
            "     *  1) Move gets to the heading (angle)",
            "     *  2) Driver stops the opmode running.",
            "     *",
            "     * @param maxTurnSpeed Desired MAX speed of turn. (range 0 to +1.0)",
            "     * @param heading Absolute Heading Angle (in Degrees) relative to last gyro reset.",
            "     *              0 = fwd. +ve is CCW from fwd. -ve is CW from forward.",
            "     *              If a relative angle is required, add/subtract from current heading.",
            "     */",
            "    public void turnToHeading(double maxTurnSpeed, double heading) {",
            "",
            "        // Run getSteeringCorrection() once to pre-calculate the current error",
            "        getSteeringCorrection(heading, P_DRIVE_GAIN);",
            "",
            "        // keep looping while we are still active, and not on heading.",
            "        while (opModeIsActive() && (Math.abs(headingError) > HEADING_THRESHOLD)) {",
            "",
            "            // Determine required steering to keep on heading",
            "            turnSpeed = getSteeringCorrection(heading, P_TURN_GAIN);",
            "",
            "            // Clip the speed to the maximum permitted value.",
            "            turnSpeed = Range.clip(turnSpeed, -maxTurnSpeed, maxTurnSpeed);",
            "",
            "            // Pivot in place by applying the turning correction",
            "            moveRobot(0, turnSpeed);",
            "",
            "            // Display drive status for the driver.",
            "            sendTelemetry(false);",
            "        }",
            "",
            "        // Stop all motion;",
            "        moveRobot(0, 0);",
            "    }",
            "",
            "    /**",
            "     *  Method to obtain & hold a heading for a finite amount of time",
            "     *  Move will stop once the requested time has elapsed",
            "     *  This function is useful for giving the robot a moment to stabilize it's heading between movements.",
            "     *",
            "     * @param maxTurnSpeed      Maximum differential turn speed (range 0 to +1.0)",
            "     * @param heading    Absolute Heading Angle (in Degrees) relative to last gyro reset.",
            "     *                   0 = fwd. +ve is CCW from fwd. -ve is CW from forward.",
            "     *                   If a relative angle is required, add/subtract from current heading.",
            "     * @param holdTime   Length of time (in seconds) to hold the specified heading.",
            "     */",
            "    public void holdHeading(double maxTurnSpeed, double heading, double holdTime) {",
            "",
            "        ElapsedTime holdTimer = new ElapsedTime();",
            "        holdTimer.reset();",
            "",
            "        // keep looping while we have time remaining.",
            "        while (opModeIsActive() && (holdTimer.time() < holdTime)) {",
            "            // Determine required steering to keep on heading",
            "            turnSpeed = getSteeringCorrection(heading, P_TURN_GAIN);",
            "",
            "            // Clip the speed to the maximum permitted value.",
            "            turnSpeed = Range.clip(turnSpeed, -maxTurnSpeed, maxTurnSpeed);",
            "",
            "            // Pivot in place by applying the turning correction",
            "            moveRobot(0, turnSpeed);",
            "",
            "            // Display drive status for the driver.",
            "            sendTelemetry(false);",
            "        }",
            "",
            "        // Stop all motion;",
            "        moveRobot(0, 0);",
            "    }",
            "",
            "    // **********  LOW Level driving functions.  ********************",
            "",
            "    /**",
            "     * This method uses a Proportional Controller to determine how much steering correction is required.",
            "     *",
            "     * @param desiredHeading        The desired absolute heading (relative to last heading reset)",
            "     * @param proportionalGain      Gain factor applied to heading error to obtain turning power.",
            "     * @return                      Turning power needed to get to required heading.",
            "     */",
            "    public double getSteeringCorrection(double desiredHeading, double proportionalGain) {",
            "        targetHeading = desiredHeading;  // Save for telemetry",
            "",
            "        // Get the robot heading by applying an offset to the IMU heading",
            "        robotHeading = getRawHeading() - headingOffset;",
            "",
            "        // Determine the heading current error",
            "        headingError = targetHeading - robotHeading;",
            "",
            "        // Normalize the error to be within +/- 180 degrees",
            "        while (headingError > 180)  headingError -= 360;",
            "        while (headingError <= -180) headingError += 360;",
            "",
            "        // Multiply the error by the gain to determine the required steering correction/  Limit the result to +/- 1.0",
            "        return Range.clip(headingError * proportionalGain, -1, 1);",
            "    }",
            "",
            "    /**",
            "     * This method takes separate drive (fwd/rev) and turn (right/left) requests,",
            "     * combines them, and applies the appropriate speed commands to the left and right wheel motors.",
            "     * @param drive forward motor speed",
            "     * @param turn  clockwise turning motor speed.",
            "     */",
            "    public void moveRobot(double drive, double turn) {",
            "        driveSpeed = drive;     // save this value as a class member so it can be used by telemetry.",
            "        turnSpeed  = turn;      // save this value as a class member so it can be used by telemetry.",
            "",
            "        leftSpeed  = drive - turn;",
            "        rightSpeed = drive + turn;",
            "",
            "        // Scale speeds down if either one exceeds +/- 1.0;",
            "        double max = Math.max(Math.abs(leftSpeed), Math.abs(rightSpeed));",
            "        if (max > 1.0)",
            "        {",
            "            leftSpeed /= max;",
            "            rightSpeed /= max;",
            "        }",
            "",
            "        leftDrive.setPower(leftSpeed);",
            "        rightDrive.setPower(rightSpeed);",
            "    }",
            "",
            "    /**",
            "     *  Display the various control parameters while driving",
            "     *",
            "     * @param straight  Set to true if we are driving straight, and the encoder positions should be included in the telemetry.",
            "     */",
            "    private void sendTelemetry(boolean straight) {",
            "",
            "        if (straight) {",
            "            telemetry.addData(\\\"Motion\\\", \\\"Drive Straight\\\");",
            "            telemetry.addData(\\\"Target Pos L:R\\\",  \\\"%7d:%7d\\\",      leftTarget,  rightTarget);",
            "            telemetry.addData(\\\"Actual Pos L:R\\\",  \\\"%7d:%7d\\\",      leftDrive.getCurrentPosition(),",
            "                    rightDrive.getCurrentPosition());",
            "        } else {",
            "            telemetry.addData(\\\"Motion\\\", \\\"Turning\\\");",
            "        }",
            "",
            "        telemetry.addData(\\\"Angle Target:Current\\\", \\\"%5.2f:%5.0f\\\", targetHeading, robotHeading);",
            "        telemetry.addData(\\\"Error:Steer\\\",  \\\"%5.1f:%5.1f\\\", headingError, turnSpeed);",
            "        telemetry.addData(\\\"Wheel Speeds L:R.\\\", \\\"%5.2f : %5.2f\\\", leftSpeed, rightSpeed);",
            "        telemetry.update();",
            "    }",
            "",
            "    /**",
            "     * read the raw (un-offset Gyro heading) directly from the IMU",
            "     */",
            "    public double getRawHeading() {",
            "        Orientation angles   = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);",
            "        return angles.firstAngle;",
            "    }",
            "",
            "    /**",
            "     * Reset the \\\"offset\\\" heading back to zero",
            "     */",
            "    public void resetHeading() {",
            "        // Save a new heading offset equal to the current raw heading.",
            "        headingOffset = getRawHeading();",
            "        robotHeading = 0;",
            "    }",
            "}",
            ""
        ]
    },
    "RobotTeleopTank Iterative": {
        "prefix": "robotTeleopTankIterative",
        "description": "This particular OpMode executes a Tank Drive control TeleOp a direct drive robot\nThe code is structured as an Iterative OpMode\n\nIn this mode, the left and right joysticks control the left and right motors respectively.\nPushing a joystick forward will make the attached motor drive forward.\nIt raises and lowers the claw using the Gamepad Y and A buttons respectively.\nIt also opens and closes the claws slowly using the left and right Bumper buttons.\n\nUse Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this OpMode to the Driver Station OpMode list\n ",
        "body": [
            "public class RobotTeleopTank_Iterative extends OpMode{",
            "",
            "    /* Declare OpMode members. */",
            "    public DcMotor  leftDrive   = null;",
            "    public DcMotor  rightDrive  = null;",
            "    public DcMotor  leftArm     = null;",
            "    public Servo    leftClaw    = null;",
            "    public Servo    rightClaw   = null;",
            "",
            "    double clawOffset = 0;",
            "",
            "    public static final double MID_SERVO   =  0.5 ;",
            "    public static final double CLAW_SPEED  = 0.02 ;        // sets rate to move servo",
            "    public static final double ARM_UP_POWER    =  0.50 ;   // Run arm motor up at 50% power",
            "    public static final double ARM_DOWN_POWER  = -0.25 ;   // Run arm motor down at -25% power",
            "",
            "    /*",
            "     * Code to run ONCE when the driver hits INIT",
            "     */",
            "    @Override",
            "    public void init() {",
            "        // Define and Initialize Motors",
            "        leftDrive  = hardwareMap.get(DcMotor.class, \"left_drive\\\");",
            "        rightDrive = hardwareMap.get(DcMotor.class, \\\"right_drive\\\");",
            "        leftArm    = hardwareMap.get(DcMotor.class, \\\"left_arm\\\");",
            "",
            "        // To drive forward, most robots need the motor on one side to be reversed, because the axles point in opposite directions.",
            "        // Pushing the left and right sticks forward MUST make robot go forward. So adjust these two lines based on your first test drive.",
            "        // Note: The settings here assume direct drive on left and right wheels.  Gear Reduction or 90 Deg drives may require direction flips",
            "        leftDrive.setDirection(DcMotor.Direction.REVERSE);",
            "        rightDrive.setDirection(DcMotor.Direction.FORWARD);",
            "",
            "        // If there are encoders connected, switch to RUN_USING_ENCODER mode for greater accuracy",
            "        // leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "        // rightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);",
            "",
            "        // Define and initialize ALL installed servos.",
            "        leftClaw  = hardwareMap.get(Servo.class, \\\"left_hand\\\");",
            "        rightClaw = hardwareMap.get(Servo.class, \\\"right_hand\\\");",
            "        leftClaw.setPosition(MID_SERVO);",
            "        rightClaw.setPosition(MID_SERVO);",
            "",
            "        // Send telemetry message to signify robot waiting;",
            "        telemetry.addData(\\\">\\\", \\\"Robot Ready.  Press Play.\\\");    //",
            "    }",
            "",
            "    /*",
            "     * Code to run REPEATEDLY after the driver hits INIT, but before they hit PLAY",
            "     */",
            "    @Override",
            "    public void init_loop() {",
            "    }",
            "",
            "    /*",
            "     * Code to run ONCE when the driver hits PLAY",
            "     */",
            "    @Override",
            "    public void start() {",
            "    }",
            "",
            "    /*",
            "     * Code to run REPEATEDLY after the driver hits PLAY but before they hit STOP",
            "     */",
            "    @Override",
            "    public void loop() {",
            "        double left;",
            "        double right;",
            "",
            "        // Run wheels in tank mode (note: The joystick goes negative when pushed forward, so negate it)",
            "        left = -gamepad1.left_stick_y;",
            "        right = -gamepad1.right_stick_y;",
            "",
            "        leftDrive.setPower(left);",
            "        rightDrive.setPower(right);",
            "",
            "        // Use gamepad left & right Bumpers to open and close the claw",
            "        if (gamepad1.right_bumper)",
            "            clawOffset += CLAW_SPEED;",
            "        else if (gamepad1.left_bumper)",
            "            clawOffset -= CLAW_SPEED;",
            "",
            "        // Move both servos to new position.  Assume servos are mirror image of each other.",
            "        clawOffset = Range.clip(clawOffset, -0.5, 0.5);",
            "        leftClaw.setPosition(MID_SERVO + clawOffset);",
            "        rightClaw.setPosition(MID_SERVO - clawOffset);",
            "",
            "        // Use gamepad buttons to move the arm up (Y) and down (A)",
            "        if (gamepad1.y)",
            "            leftArm.setPower(ARM_UP_POWER);",
            "        else if (gamepad1.a)",
            "            leftArm.setPower(ARM_DOWN_POWER);",
            "        else",
            "            leftArm.setPower(0.0);",
            "",
            "        // Send telemetry message to signify robot running;",
            "        telemetry.addData(\\\"claw\\\",  \\\"Offset = %.2f\\\", clawOffset);",
            "        telemetry.addData(\\\"left\\\",  \\\"%.2f\\\", left);",
            "        telemetry.addData(\\\"right\\\", \\\"%.2f\\\", right);",
            "    }",
            "",
            "    /*",
            "     * Code to run ONCE after the driver hits STOP",
            "     */",
            "    @Override",
            "    public void stop() {",
            "    }",
            "}",
            ""
        ]
    }
}